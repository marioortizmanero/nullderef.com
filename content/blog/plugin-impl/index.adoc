---
title: "Plugins in Rust: Getting our Hands Dirty"
description: "Finally implementing the plugin system!"
author: "Mario Ortiz Manero"
tags: ["rust", "rustlang", "dynamic-loading", "plugin", "ffi", "abi"]
series: ["rust-plugins"]
date: 2021-11-08
GHissueID: 30
---

:sectnums:
:stem: latexmath

:repr-c: pass:quotes[`#[repr\(C)]`]
:work: pass:quotes["`just make it work`"]

// TODO: review that both abi_stable and raw are considered
// TODO: review that both changing from existing codebase and from scratch are
// considered

Welcome to one of the last articles of
https://nullderef.com/series/rust-plugins/[this series]!
https://nullderef.com/blog/plugin-abi-stable[Previously], we covered how to use
external dependencies to lessen the work necessary to implement our plugin
system. Now that we know how to actually get started, we will implement it once
and for all. I will personally use the crate {{< crate abi_stable >}}, but the
concepts should be roughly the same for any dynamic loading method.

[[advice]]
== Some prototyping advice

Before anything else, I'd like to give out some advice regarding refactoring
with Rust, based on my experience. You'll be introducing a good amount of
changes, so it'd be wise to do some brief planning beforehand -- otherwise it'll
take forever with a complex enough codebase. Maybe all of this will be obvious
to you, or you will prefer taking a different approach. But it certainly worked
for me, so it's worth a shot. I'm personally very satisfied about how much I've
learned about the process.

=== The {work} approach

What I struggled the most to get drilled into my head is not getting lost in the
details. *We just want it to work first of all*. I'll repeat. We just want it to
*work* first of all. As long as the plugin system runs, the following are
completely fine:

* Ugly code (non-idiomatic, repetitive, somewhat messy, etc)
* Non-performant code
* Poor documentation
* No tests
* No clippy

Or, more specific examples:

* If stuck with lifetimes, just slap a `.clone()` in there and call it a day.
* A good ol' `.unwrap()` will make your life easier in case of doubt.
* You can resort to "`dirty`" or unnecessary type conversions if necessary.
* Just pulling in a new dependency instead of implementing something more
  tailored to your use-case from scratch will save you a lot of time.
* If something that's not really important is taking you too much time, you can
  always resort to `// TODO` or `// FIXME`.

I will say that not working on tests until the plugin system is running is
definitely arguable for those who prefer to follow test-driven development.
However, I personally didn't feel the need to write any tests; my progress
basically consisted on making some changes and then trying to make the compiler
happy about them, repeatedly. I only moved to the testing step once I was happy
enough with the results, and everything seemed to work when running it manually.

Furthermore, premature optimization is the source of all evil. You're not at a
point where that's important yet. Once you're done, you can actually spend some
time profiling and benchmarking in order to know which optimizations are worth
your time. Don't get me wrong -- you can certainly worry about choosing an
approach that's appropiate in terms of performance, which is why I discarded
WebAssembly or IPC at the beginning. But definitely give up on trying to avoid a
`clone` that might not actually affect your program speed after all.

My point is that every test, cleanup or optimization you try to make at this
stage will most likely end up being wasted effort. You'll reach a blocker at
some point later on and have to rethink and rewrite lots of stuff. When
everything compiles, seemingly runs fine, and you consider it a decent approach,
you can actually start working on these points. It's okay to "`waste`" effort on
wrong approaches, because you aren't really "`wasting`" it; they're a necessary
step to arrive to the final solution. But it's painful to delete code you've
spent time thinking about, so we should at least try to minimize it.

=== Specific to Rust

// TODO: more tips like these?

The first thing I did was remove a few warnings the compiler will print when
you're prototyping. By default, a Rust program still compiles with warnings, but
in my experience they're always in the way when trying to deal with actual
errors. For example, I don't care that an import is unused at all. I'll fix it
once I'm done, but please let me keep trying to "`make this work`"!

[source, rust]
----
// TODO: disable and cleanup with `cargo fix` automatically once done
#![allow(unused)]
#![allow(dead_code)]
----

Note that I'm not using `#![allow(warnings)]`, because most warnings will
actually be really helpful when refactoring to avoid early bugs. We just want to
get rid of the annoying ones, such as unused functions or imports, or dead code
that we haven't cleaned up yet, which are harmless most of the times.

One month later, I was able to finally compile `tremor-runtime` with the initial
PDK prototype. The following screenshot made my day, as simple as it may seem:

image::compilation.png[width=80%, align=center]

At this point, you can remove these `allow` statements and just run `cargo fix
&& cargo fmt`. They're built-in, and will automatically take care of the trivial
warnings, such as unused imports, saving _lots_ of time doing cumbersome work.

== Defining the plugin interface

The first step that we can do is define the interface of the plugin system, i.e.
what a plugin binary must implement in order to be loadable by the runtime. If
you're doing this over an already existing codebase, you'll probably get tons of
errors. We'll ignore them for now; this is only our first sketch and you'll end
up changing it a thousand times anyway. Some of the types in the interface may
not exist yet, or they may not be meant to be used for FFI. But it'll serve us
as an initial list of things to work on.

In my case, it first looked as follows. The specifics about how this works with
{{< crate abi_stable >}} are explained in the
https://nullderef.com/blog/plugin-abi-stable/[previous post].

[source, rust]
----
/// This type represents a connector plugin that has been loaded with
/// `abi_stable`. It serves as a builder, making it possible to construct a
/// trait object of `RawConnector`.
#[repr(C)]
#[derive(StableAbi)]
#[sabi(kind(Prefix))]
pub struct ConnectorMod {
    /// the type of the connector
    pub connector_type: extern "C" fn() -> ConnectorType,

    /// create a connector from the given `id` and `config`
    ///
    /// # Errors
    ///  * If the config is invalid for the connector
    #[sabi(last_prefix_field)]
    pub from_config: extern "C" fn(
        id: RString,
        config: ROption<PdkValue<'static>>,
    ) -> FfiFuture<RResult<BoxedRawConnector>>,
}

// Marking `ConnectorMod` as the main module in this plugin. Note that
// `ConnectorMod_Ref` is just a pointer to the prefix of `ConnectorMod`.
impl RootModule for ConnectorMod_Ref {
    // The name of the dynamic library
    const BASE_NAME: &'static str = "connector";
    // The name of the library for logging and similars
    const NAME: &'static str = "connector";
    // The version of this plugin's crate
    const VERSION_STRINGS: VersionStrings = package_version_strings!();

    // Implements the `RootModule::root_module_statics` function, which is the
    // only required implementation for the `RootModule` trait.
    declare_root_module_statics! {ConnectorMod_Ref}
}
----

In my case, I had to basically turn the `Connector` trait into a plugin. Its
implementations were meant to be constructed with `ConnectorBuilder`, and from
that moment on Tremor was able to treat a connector generically with `dyn
Connector`. Thus, I thought the best idea would be to turn `ConnectorBuilder`
into my `RootModule`, making it possible to construct the implementor once the
plugin was loaded with the `from_config` function. It would now be called
`ConnectorMod`, and instead of `dyn Connector` I used
``abi_stable::sabi_trait``'s macro functionality, making its usage possible
within FFI.

For reference, when I first wrote `ConnectorMod`, `PdkValue` wasn't even
{repr-c}. I had also added the `#[sabi_trait]` call to the `RawConnector` trait
declaration, but the types used there weren't {repr-c} either. So I had tons of
errors everywhere, but that was OK. I would be working on them step by step
until it compiled again.

If you're using {{< crate libloading >}} directly then you would be implementing
the interface via a struct with function pointers instead, and you'd need to
store metadata about the plugin with constants. But in the end, it boils down to
the same thing; just with different amounts of boilerplate.

=== Recursively making everything {repr-c}

Now, this is the actually complicated part. The previous step may have seemed
simple, but you might find yourself falling into madness as you realize that you
need to make all the types in the interface {repr-c}, and also all the fields
each of these types hold, and so on...

It's very likely that you eventually find out about types in the standard
library that don't have an alternative in {{< crate abi_stable >}}. These will
most likely be external ones, but things like async are a bit complicated to
deal with as well. In the case of Tremor, the most problematic part was the
`Value` type. It's used to represent a JSON-like payload; roughly defined as
follows:

[[value_decl]]
[source, rust]
----
pub enum Value {
    /// Static values (integers, booleans, etc)
    Static(StaticNode),
    /// String type
    String(String),
    /// Array type
    Array(Vec<Value>),
    /// Object type
    Object(Box<HashMap<String, Value>>),
    /// A binary type
    Bytes(Vec<u8>),
}
----

In order to be able to use `Value` in the plugin system, it can be converted to:

[source, rust]
----
#[repr(C)]
#[derive(StableAbi)] // Only necessary with abi_stable
pub enum Value {
    /// Static values (integers, booleans, etc)
    Static(StaticNode),
    /// String type
    String(RString),
    /// Array type
    Array(RVec<Value>),
    /// Object type
    Object(RBox<RHashMap<RString, Value>>),
    /// A binary type
    Bytes(RVec<u8>),
}
----

The first problem arises in the `Static` variant.
https://docs.rs/value-trait/latest/value_trait/enum.StaticNode.html[`StaticNode`]
is a type from our {{< crate value_trait >}} dependency, which may hold a list
of basic types: numbers, booleans, or null:

[source, rust]
----
pub enum StaticNode {
    I64(i64),
    U64(u64),
    F64(f64),
    Bool(bool),
    Null,
}
----

The solution would be as easy as applying the very same procedure again (hence
_recursively_ until everything is {repr-c}). Here it will finally work because
there aren't any other non-trivial types in `StaticNode`. But since it's an
external library, we'll have to make a Pull Request and hope that the author is
okay with the changes. It should be optional under a feature flag so that it's
applied only for those that actually need {repr-c} in the library:

[source, rust]
----
#[cfg_attr(feature = "c-abi", repr(C))]
#[cfg_attr(feature = "c-abi", derive(abi_stable::StableAbi))]
pub enum StaticNode {
    I64(i64),
    U64(u64),
    F64(f64),
    Bool(bool),
    Null,
}
----

That's exactly what I did in my case:

[.text-center]
{{< gh pr "simd-lite/value-trait" 14 "Add support for StableAbi" >}}

=== Overcoming problems with {repr-c}

Awesome. We got `Value` working now for FFI. Right? No? Oh. It seems like the
compiler strongly disagrees. By changing the variants of `Value`, a great amount
of the code that used it will now fail to compile in multiple ways:

[source, rust]
----
// Won't work because Value::String holds a RString now
let value = Value::String(String::new());
----

That's the easiest one, we just need to change `String` to `RString` and it
should be fine. The types in {{< crate abi_stable >}} are meant to be a drop-in
replacement for the ones in `std`:

[source, rust]
----
let value = Value::String(RString::new());
----

It gets a bit more complicated when the types are exposed in methods, because
you have to decide whether or not to expand the FFI barrier from the _internals_
of `Value` to the _users_ of `Value`. For instance, the `Value::Object` variant
holds a `RHashMap` now, but the method `Value::as_object` used to return a
reference to a `HashMap`. You'll get another error in there, which raises a
decision that must be made: returning `RHashMap` or adding an internal
conversion to `HashMap`.

[source, rust]
----
impl Value {
    // Original code
    fn as_object(&self) -> Option<&HashMap<String, Value>> {
        match self {
            // Problem: `m` is a `RHashMap` now, but the function returns a
            // `HashMap`.
            //
            // Solution 1: change the return type to `RHashMap`
            // Solution 2: convert `m` to a `HashMap` with `m.into()`
            Self::Object(m) => Some(m),
            _ => None,
        }
    }
}
----

* If the return type is changed to `RHashMap`, almost every caller to
  `as_object` in the program will now fail to compile because it expects a
  `HashMap`. You'll have to clean it up one by one and figure out how `RHashMap`
  can be used in that case instead. This is very messy because in order to avoid
  conversions, your plugin system will _infect_ the entire codebase.
+
You'll quickly find yourself propagating the usage of `RHashMap` everywhere,
even when the PDK isn't that important. For example, `Value` was also used in
Trickle's implementation, the scripting language used to configure Tremor's
pipelines. Having to use `RHashMap` in there was a bit confusing, and I was
modifying _tons_ of files unrelated to the plugin system.
* If you perform an internal conversion to `HashMap` in `as_object` we'll avoid
  all of these errors, but we're adding a small overhead. It's by far the
  easiest choice, but if `Value::as_object` is frequently used in e.g. your hot
  loop, you may notice a considerable performance degradation.
+
I https://nullderef.com/blog/plugin-abi-stable/#_type_conversions[already
investigated in the past], and the good news is that converting between types in
`std` and `abi_stable` is stem:[O(1)]. Most of the times it's equivalent to a
pointer cast or a match. So here's when the {work} approach is useful: we'll
just keep the FFI barrier minimal and add conversions as early as possible.
After we're done, we'll see if there are any performance issues, and then work
on them.

=== Reaching {repr-c} blockers

That was my first attempt at making `Value` FFI-compatible, and unfortunately,
it didn't end there. Converting from `std` to {{< crate abi_stable >}} is a
relatively painless experience; their usage intends to be the same. You may
find that a method in {{< crate abi_stable >}} isn't available because it's not
updated as regularly. But most of the times you can just copy-paste the
implementation from `std` into {{< crate abi_stable >}}'s and create a new Pull
Request, which is what I did a few times:

[.text-center]
{{< gh pr "rodrimati1992/abi_stable_crates" 58 "Add support for .keys() and .values() in RHashMap" >}}

[.text-center]
{{< gh pr "rodrimati1992/abi_stable_crates" 59 "Implement `Index` for slices and vectors" >}}

[.text-center]
{{< gh pr "rodrimati1992/abi_stable_crates" 61 "Support for `f32` and `f64`" >}}

[.text-center]
{{< gh pr "rodrimati1992/abi_stable_crates" 68 "Implement `ROption::as_deref`" >}}

[.text-center]
{{< gh pr "rodrimati1992/abi_stable_crates" 70 "Implement RVec::append" "paragraph" >}}

However, this stops being as "`easy`" when you have to convert from _an external
library_ to {{< crate abi_stable >}}. The <<value_decl,declaration of `Value`
that I included in this post>> was an oversimplification. For performance
reasons, Tremor actually uses {{< crate halfbrown >}}'s implementation of a hash
map instead of `std::collections::HashMap`. It's based on {{< crate hashbrown
>}}, which was actually merged into the standard library at some point.

// TODO: check this with Heinz before publishing
{{< crate halfbrown >}} also has some additional functionality over ``std``'s
implementation. Some of it is actually available on Nightly, but for that reason
it's not meant to be in the stable `RHashMap` either. This is used in Tremor,
for example with
https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#method.raw_entry[`raw_entry`].
There is an optimization for JSON handling that consists on memoizing the hash
of a known item in a map in order to access its value directly with it. After
switching to `RHashMap`, it becomes an impossible task without writing an FFI
wrapper for {{< crate halfbrown >}}.

Even if I managed to fix the hash map mess, the same story repeats itself for
`Cow`. Tremor uses {{< crate beef >}}'s `Cow` instead of `std::borrow::Cow`
because it's faster and more compact, at the cost of a slightly different usage.

There are a few possible ways to approach these kinds of issues, which I'll
cover in the following subsections.

==== Avoid the type in the first place

As always, we'll try to follow the {work} advice in here. It's a perfectly valid
solution to just comment out the optimizations and add a `// TODO` above so that
they can be reviewed later. You might be asking for too much complexity in your
plugin system and limiting yourself to the functionality in `std` may be more
than enough for now. You'll see in the following sections that it's always
possible to fix it, but it might be too much effort at the moment.

In ``Value``'s specific case, it seems like removing the optimizations that are
giving us trouble is the easiest way to fix this problem. And it would, if
removing code wasn't also tricky when the optimizations aren't performed
internally and transparently to the hash map functionality. After trying to
remove them I eventually gave up because I considered it was getting out of
hands with so many changes.

==== Implement a wrapper

Another possibility is to write a _wrapper_ for {{< crate halfbrown >}}. Opaque
types, for instance, may be used to wrap the functionality of an underlying type
that's not FFI-safe, as I covered in previous articles. This is what {{< crate
abi_stable >}} does in its `external_types` module for crates like {{< crate
crossbeam >}} or {{< crate parking_lot >}}.

As you may see with the
https://github.com/rodrimati1992/abi_stable_crates/tree/edfb2a97a7b5d7ecbc29c1f9f115f61e26f42da6/abi_stable/src/external_types[already
existing examples], however, implementing wrappers can be quite a cumbersome
task. And even after you're done you'll have to keep them up to date, so this
will increase your maintainance burden. {{< crate halfbrown >}} and {{< crate
beef >}} are somewhat complex libraries, so I decided this wasn't the best
choice at that moment.

==== Re-implement with {repr-c} from scratch

Similar to implementing a wrapper, but on steroids. It might seem like overkill,
but as far as I know it's the only choice in some scenarios, because we can make
sure the type is as performant as it can get. In ``Value``'s example, the
problematic types are optimizations, so writing a wrapper over them may have a
performance hit and render them useless (e.g. if we used opaque types we would
introduce a mandatory pointer indirection).

// TODO: fact-check `Value` comment
If this part of the project is important enough, or you consider yourself with
enough manpower, then it might not be such a bad idea to create a new
implementation with your use-case in mind. It's actually why Tremor's `Value`
was created in the first place; `simd_json::Value` wasn't flexible enough for
them, so they decided to define their own version. Same thing could be applied
for your plugin system.

==== Simplifying the type at the FFI boundary

The last idea I came up with, that ended up being the easiest one, was just
copy-pasting the type and adding an intermediate conversion. We can just
simplify the type as much as possible in order to pass it through the FFI
boundary, and then convert it back to access its full functionality.

[source, rust]
----
#[repr(C)]
#[derive(StableAbi)]
pub enum PdkValue {
    /// Static values (integers, booleans, etc)
    Static(StaticNode),
    /// String type
    String(RString),
    /// Array type
    Array(RVec<PdkValue>),
    /// Object type
    Object(RBox<RHashMap<RString, PdkValue>>),
    /// A binary type
    Bytes(RVec<u8>),
}
----

We don't implement any methods at all for the new `Value`, only its variants and
conversions in both ways. If `PdkValue` is simple enough, these conversions can
be lightweight and not affect performance that much. But in some cases it's
impossible to avoid iterating the data in order to convert it. For example, the
object is a pointer to a hashmap. Unlike the array, we can't just cast it to a
pointer and know that it will work

// TODO: update and simplify after it's more definitive
[source, rust]
----
impl<'value> From<Value<'value>> for PdkValue<'value> {
    fn from(original: Value<'value>) -> Self {
        match original {
            // No conversion needed; `StaticNode` implements `StableAbi`
            Value::Static(s) => PdkValue::Static(s),
            // This conversion is cheap
            Value::String(s) => PdkValue::String(s.into()),
            // This unfortunately requires iterating the array
            Value::Array(a) => {
                let a = a.into_iter().map(Into::into).collect();
                PdkValue::Array(a)
            }
            // This unfortunately requires iterating the map and a new
            // allocation
            Value::Object(m) => {
                let m: halfbrown::HashMap<_, _> = *m;
                let m = m.into_iter().map(Into::into).collect();
                PdkValue::Object(RBox::new(m))
            }
            // This conversion is cheap
            Value::Bytes(b) => PdkValue::Bytes(conv_u8(b)),
        }
    }
}

impl<'value> From<PdkValue<'value>> for Value<'value> {
    fn from(original: PdkValue<'value>) -> Self {
        match original {
            // No conversion needed; `StaticNode` implements `StableAbi`
            PdkValue::Static(s) => Value::Static(s),
            // This conversion is cheap
            PdkValue::String(s) => Value::String(conv_str_inv(s)),
            // This unfortunately requires iterating the array
            PdkValue::Array(a) => {
                let a = a.into_iter().map(Into::into).collect();
                Value::Array(a)
            }
            // This unfortunately requires iterating the map and a new
            // allocation
            PdkValue::Object(m) => {
                let m = (*m).clone(); // FIXME: remove this super ugly clone
                let m = m.into_iter().map(Into::into).collect();
                Value::Object(Box::new(m))
            }
            // This conversion is cheap
            PdkValue::Bytes(b) => Value::Bytes(conv_u8_inv(b)),
        }
    }
}
----

The main issue here is usability. In order to use our new value, we will need
to:

* Convert from `Value` to `PdkValue`
* Pass it through the FFI boundary (e.g. call a plugin function)
* Convert from `PdkValue` to `Value`

// TODO insert pretty diagram here

[source, rust]
----
fn something(value: PdkValue) {
    
}
----

=== Plugins with `async`

As much as I wanted to avoid communication primitives with the plugins other
than plain synchronous calls, some parts _need_ asynchronous communication. For
example, the connector context passed to the plugin holds the `Sender<T>` part
of a channel that can be used to indicate the runtime that the connection has
been lost. This is because it's very likely that this connection drop happens at
any point of the plugin execution. Many plugins will spawn a new task to run in
the background (think of a TCP server), which is what's going to notify the
runtime. We can't delay that until the next synchronous call happens because we
don't know when that might happen, and we want to keep Tremor low-latency.

We have two options here:

* Keep using a channel: turns out `abi_stable` includes an FFI-safe wrapper for
  {{< crate crossbeam >}}. We could just switch the usage of `Sender<T>` to
  https://docs.rs/abi_stable/latest/abi_stable/external_types/crossbeam_channel/struct.RSender.html[`RSender<T>`]
  and that's it.
* Try to use something simpler: I was wondering if we could manage to avoid
  pulling in `crossbeam` and using channels.

// TODO: talk about callbacks

[source, text]
----
error[E0308]: mismatched types
  --> src/lib.rs:22:17
   |
22 |           sender: |x| {
   |  _________________^
23 | |             i += x;
24 | |             println!("callback invoked v3! {}", x)
25 | |         }
   | |_________^ expected fn pointer, found closure
   |
   = note: expected fn pointer `fn(i32)`
                 found closure `[closure@src/lib.rs:22:17: 25:10]`
note: closures can only be coerced to `fn` types if they do not capture any variables
  --> src/lib.rs:23:13
   |
23 |             i += x;
   |             ^ `i` captured here

For more information about this error, try `rustc --explain E0308`.
----

== Separating runtime and interface

In the previous articles I've been assuming the following structure for the
plugin system:

* The runtime crate, which loads and runs the plugins.
* The `common` crate, with the interface shared between the plugin and the
  runtime.
* The plugin crates, with the loadable functionality.

This is essential in order to actually improve compilation times, which is one
of the main objectives of our plugin system. There are two ways to look at
compilation times:

. For runtime development
. For plugin development

In both cases, we want to compile _only_ either component. If we're developing a
plugin, it makes no sense to be forced to compile the runtime as well, because
we aren't actually changing it. And if we're working on the runtime, we don't
want to re-compile the functionality from the plugins.

If we just separate the runtime from the plugins, we can achieve the first
point. Your functionality is now in separate plugin binaries, so the runtime
will have considerably lower compilation times.

But in order to also improve plugin compilation times, if the interface is in
the same crate as the runtime, we'll have to compile both. The shared parts
should be written in a separate crate.

However, if you aren't starting from scratch, it's very likely that you don't
have a `common` crate. You'll just have a single binary crate with both the
runtime and the functionality in `common`.

This isn't really a problem, since you can just have the plugins depend on the
runtime crate rather than `common`, and skip it altogether. But one of the
points of making this PDK is decreasing your compile times

== Getting it ready for deployment

== Conclusion

That's basically how I managed to implement the PDK for Tremor. As I covered in
the <<advice,first section>>, though, it's only a prototype, and we need to
polish it. It seems to work perfectly when I execute the runtime manually and
load some simple plugins I've implemented. But the final step consists on making
the PDK ready for deployment. This means cleaning up, testing, and benchmarking.
For instance, I managed to make Tremor... 35% slower on release!

// TODO: insert picture in presentation

So yeah, I still have some work to do in that regard. But it's super cool to
finally have it compiling and running. The next and last article will cover my
last step in trying to make the PDK ready for Tremor's next version.

Lastly, I've found it especially rewarding to do all of this in an open source
environment. Even if you're working for a company with propietary software,
please try to contribute upstream instead of forking or patching. Try to be nice
to those who are saving you so much work, and submit a PR or an issue:

// TODO: use github shortcode
.Most of my contributions while implementing the PDK
* https://github.com/oxalica/async-ffi/pull/10
* https://github.com/oxalica/async-ffi/pull/11
* https://github.com/rodrimati1992/abi_stable_crates/pull/58
* https://github.com/rodrimati1992/abi_stable_crates/pull/59
* https://github.com/rodrimati1992/abi_stable_crates/pull/61
* https://github.com/rodrimati1992/abi_stable_crates/pull/68
* https://github.com/rodrimati1992/abi_stable_crates/pull/70
* https://github.com/rodrimati1992/abi_stable_crates/pull/74
* https://github.com/simd-lite/simd-json-derive/pull/9
* https://github.com/simd-lite/value-trait/pull/14
* https://github.com/simd-lite/value-trait/pull/16
* https://github.com/simd-lite/value-trait/pull/18

[bibliography]
== References

- [[[nginx-perf,      1]]] http://httpd.apache.org/docs/2.4/dso.html#advantages
- [[[libloading-th,   2]]] https://docs.rs/libloading/0.7.1/libloading/struct.Library.html#thread-safety
- [[[dlerror-th,      3]]] https://pubs.opengroup.org/onlinepubs/009604499/functions/dlerror.html
- [[[linux-th,        4]]] https://man7.org/linux/man-pages/man3/dlerror.3.html#ATTRIBUTES
- [[[macos-th,        5]]] https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlerror.3.html
- [[[windows-th,      6]]] https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setthreaderrormode
- [[[unwinding,       7]]] https://doc.rust-lang.org/nomicon/unwinding.html
