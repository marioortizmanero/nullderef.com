---
title: "Plugins in Rust: Getting our Hands Dirty"
description: "Finally implementing the plugin system!"
author: "Mario Ortiz Manero"
tags: ["rust", "rustlang", "dynamic-loading", "plugin", "ffi", "abi"]
series: ["rust-plugins"]
date: 2021-11-08
GHissueID: 30
---

:sectnums:
:stem: latexmath

:repr-c: pass:quotes[`#[repr\(C)]`]
:repr-rust: pass:quotes[`#[repr(Rust)]`]
:work: pass:quotes["`just make it work`"]

// TODO: review that both abi_stable and raw are considered
// TODO: review that both changing from existing codebase and from scratch are
// considered

Welcome to one of the last articles of
https://nullderef.com/series/rust-plugins/[this series]!
https://nullderef.com/blog/plugin-abi-stable[Previously], we covered how to use
external dependencies to lessen the work necessary to implement our plugin
system. Now that we know how to actually get started, we will implement it once
and for all. I will personally use the crate {{< crate abi_stable >}}, but the
concepts should be roughly the same for any dynamic loading method.

[[advice]]
== Some prototyping advice

Before anything else, I'd like to give out some advice regarding refactoring
with Rust, based on my experience. You'll be introducing a good amount of
changes, so it'd be wise to do some brief planning beforehand -- otherwise it'll
take forever with a complex enough codebase. Maybe all of this will be obvious
to you, or you will prefer taking a different approach. But it certainly worked
for me, so it's worth a shot. I'm personally very satisfied about how much I've
learned about the process.

=== The {work} approach

What I struggled the most to get drilled into my head is not getting lost in the
details. *We just want it to work first of all*. I'll repeat. We just want it to
*work* first of all. As long as the plugin system runs, the following are
completely fine:

* Ugly code (non-idiomatic, repetitive, somewhat messy, etc)
* Non-performant code
* Poor documentation
* No tests
* No clippy

Or, more specific examples:

* If stuck with lifetimes, just slap a `.clone()` in there and call it a day.
* A good ol' `.unwrap()` will make your life easier in case of doubt.
* You can resort to "`dirty`" or unnecessary type conversions if necessary.
* Just pulling in a new dependency instead of implementing something more
  tailored to your use-case from scratch will save you a lot of time.
* If something that's not really important is taking you too much time, you can
  always resort to `// TODO` or `// FIXME`.

I will say that not working on tests until the plugin system is running is
definitely arguable for those who prefer to follow test-driven development.
However, I personally didn't feel the need to write any tests; my progress
basically consisted on making some changes and then trying to make the compiler
happy about them, repeatedly. I only moved to the testing step once I was happy
enough with the results, and everything seemed to work when running it manually.

Furthermore, premature optimization is the source of all evil. You're not at a
point where that's important yet. Once you're done, you can actually spend some
time profiling and benchmarking in order to know which optimizations are worth
your time. Don't get me wrong -- you can certainly worry about choosing an
approach that's appropiate in terms of performance, which is why I discarded
WebAssembly or IPC at the beginning. But definitely give up on trying to avoid a
`clone` that might not actually affect your program speed after all.

My point is that every test, cleanup or optimization you try to make at this
stage will most likely end up being wasted effort. You'll reach a blocker at
some point later on and have to rethink and rewrite lots of stuff. When
everything compiles, seemingly runs fine, and you consider it a decent approach,
you can actually start working on these points. It's okay to "`waste`" effort on
wrong approaches, because you aren't really "`wasting`" it; they're a necessary
step to arrive to the final solution. But it's painful to delete code you've
spent time thinking about, so we should at least try to minimize it.

=== Specific to Rust

// TODO: more tips like these?

==== Disable the annoying warnings

The first thing I did was remove a few warnings the compiler will print when
you're prototyping. By default, a Rust program still compiles with warnings, but
in my experience they're always in the way when trying to deal with actual
errors. For example, I don't care that an import is unused at all. I'll fix it
once I'm done, but please let me keep trying to "`make this work`"!

[source, rust]
----
// TODO: disable and cleanup with `cargo fix` automatically once done
#![allow(unused)]
#![allow(dead_code)]
----

Note that I'm not using `#![allow(warnings)]`, because most warnings will
actually be really helpful when refactoring to avoid early bugs. We just want to
get rid of the annoying ones, such as unused functions or imports, or dead code
that we haven't cleaned up yet, which are harmless most of the times.

One month later, I was able to finally compile `tremor-runtime` with the initial
PDK prototype. The following screenshot made my day, as simple as it may seem:

image::compilation.png[width=80%, align=center]

Afterwards, I removed these `allow` statements and just ran `cargo fix && cargo
fmt`. Both cargo commands are built-in, and will automatically take care of the
trivial warnings, such as unused imports, saving _lots_ of time doing cumbersome
work.

==== Don't touch previous `use` statements

As my Pull Request got bigger and bigger, I started running into problems with
Git. The parent branch was also under work from a team of three people, so it
changed quite often. All of this resulted into frequent conflicts, and having to
painfully resolve them many times until I got the hang of it.

Say, you have a number of `use` statements at the top of your file. After adding
some changes related to the PDK, you now need to import `PdkValue` as well.
You'd usually do:

.Before
[source, rust]
----
use tremor_value::{Value, ValueTrait};
----
.After
[source, rust]
----
use tremor_value::{Value, ValueTrait, PdkValue};
----

The problem is that if the parent branch later adds or removes one of the items
in that `use` statement, you may encounter a conflict. Git isn't smart enough to
handle Rust import statements (although that'd be pretty cool). Multiply this by
100 statements, and you might eventually go crazy. You can keep your sanity by
adding the new item in a separate block of ``use``s instead:

[source, rust]
----
use tremor_value::{Value, ValueTrait};

use tremor_value::PdkValue; // <--
----

Same thing may happen if `tremor_value` wasn't imported and you have to add a
new line to the already existing `use` block:

.Before
[source, rust]
----
use more_stuff::{X, Y, Z};
use other_stuff::{A, B, C};
----

.After
[source, rust]
----
use more_stuff::{X, Y, Z};
use tremor_value::PdkValue;
use other_stuff::{A, B, C};
----

In my experience, Git also trips up with this sometimes. You can follow the same
advice:

[source, rust]
----
use more_stuff::{X, Y, Z};
use other_stuff::{A, B, C};

use tremor_value::PdkValue; // <--
----

In summary, you can just add a new block after all the previous ``use``s and add
your stuff in there. You can clean it up at the end or in a different pull
request.

This is harder to do if you're _removing_ `use` statements. But if you also
followed the previous section about ignoring annoying warnings, it won't be a
problem in the first place. You can just leave the unused imports and clean up
when you're done with the PR.

== Defining the plugin interface

The first step that we can do is define the interface of the plugin system, i.e.
what a plugin binary must implement in order to be loadable by the runtime. If
you're doing this over an already existing codebase, you'll probably get tons of
errors. We'll ignore them for now; this is only our first sketch and you'll end
up changing it a thousand times anyway. Some of the types in the interface may
not exist yet, or they may not be meant to be used for FFI. But it'll serve us
as an initial list of things to work on.

In my case, it first looked as follows. The specifics about how this works with
{{< crate abi_stable >}} are explained in the
https://nullderef.com/blog/plugin-abi-stable/[previous post].

[source, rust]
----
/// This type represents a connector plugin that has been loaded with
/// `abi_stable`. It serves as a builder, making it possible to construct a
/// trait object of `RawConnector`.
#[repr(C)]
#[derive(StableAbi)]
#[sabi(kind(Prefix))]
pub struct ConnectorMod {
    /// the type of the connector
    pub connector_type: extern "C" fn() -> ConnectorType,

    /// create a connector from the given `id` and `config`
    ///
    /// # Errors
    ///  * If the config is invalid for the connector
    #[sabi(last_prefix_field)]
    pub from_config: extern "C" fn(
        id: RString,
        config: ROption<PdkValue<'static>>,
    ) -> FfiFuture<RResult<BoxedRawConnector>>,
}

// Marking `ConnectorMod` as the main module in this plugin. Note that
// `ConnectorMod_Ref` is just a pointer to the prefix of `ConnectorMod`.
impl RootModule for ConnectorMod_Ref {
    // The name of the dynamic library
    const BASE_NAME: &'static str = "connector";
    // The name of the library for logging and similars
    const NAME: &'static str = "connector";
    // The version of this plugin's crate
    const VERSION_STRINGS: VersionStrings = package_version_strings!();

    // Implements the `RootModule::root_module_statics` function, which is the
    // only required implementation for the `RootModule` trait.
    declare_root_module_statics! {ConnectorMod_Ref}
}
----

In my case, I had to basically turn the `Connector` trait into a plugin. All
`Connector` implementations were meant to be constructed with
`ConnectorBuilder`, and from that moment on Tremor was able to use them
generically with `dyn Connector`. Thus, I thought the best idea would be to turn
`ConnectorBuilder` into my `RootModule` under the name `ConnectorMod`. Once the
plugin was loaded, it would be possible to construct the connector with the
`from_config` function. I used ``abi_stable::sabi_trait``'s macro functionality,
making `dyn` usage possible within FFI.

For reference, when I first wrote `ConnectorMod`, `PdkValue` wasn't even
{repr-c}. I had also added the `#[sabi_trait]` call to the `RawConnector` trait
declaration, but the types used there weren't {repr-c} either. So I had tons of
errors everywhere, but that was OK. I would be working on them step by step
until it compiled again.

If you're using {{< crate libloading >}} directly then you would be implementing
the interface via a struct with function pointers instead, and you'd need to
store metadata about the plugin with constants. But in the end, it boils down to
the same thing; just with different amounts of boilerplate.

=== Recursively making everything {repr-c}

Now, this is the actually complicated part. The previous step may have seemed
simple, but you might find yourself falling into madness as you realize that you
need to make all the types in the interface {repr-c}, and also all the fields
each of these types hold, and so on...

It's very likely that you'll eventually find types without an FFI alternative in
{{< crate abi_stable >}}. These will most likely be external types, but things
like async are a bit complicated to deal with as well. In the case of Tremor,
the most problematic part was the `Value` type. It's used to represent a
JSON-like payload; roughly defined as follows:

[[value_decl]]
[source, rust]
----
pub enum Value {
    /// Static values (integers, booleans, etc)
    Static(StaticNode),
    /// String type
    String(String),
    /// Array type
    Array(Vec<Value>),
    /// Object type
    Object(Box<HashMap<String, Value>>),
    /// A binary type
    Bytes(Vec<u8>),
}
----

In order to be able to use `Value` in the plugin system, it can be converted to:

[source, rust]
----
#[repr(C)]
#[derive(StableAbi)] // Only necessary with abi_stable
pub enum Value {
    /// Static values (integers, booleans, etc)
    Static(StaticNode),
    /// String type
    String(RString),
    /// Array type
    Array(RVec<Value>),
    /// Object type
    Object(RBox<RHashMap<RString, Value>>),
    /// A binary type
    Bytes(RVec<u8>),
}
----

The first problem arises in the `Static` variant:
https://docs.rs/value-trait/latest/value_trait/enum.StaticNode.html[`StaticNode`]
is a {repr-rust} _external_ type. It's from our {{< crate value_trait >}}
dependency, and it may hold different basic types: numbers, booleans, or null:

[source, rust]
----
pub enum StaticNode {
    I64(i64),
    U64(u64),
    F64(f64),
    Bool(bool),
    Null,
}
----

This could be fixed by simply applying the very same procedure again (hence
_recursively_ until everything is {repr-c}). Here it will finally work because
there aren't any other {repr-rust} types in `StaticNode`:

[source, rust]
----
#[cfg_attr(feature = "abi_stable", repr(C))]
#[cfg_attr(feature = "abi_stable", derive(abi_stable::StableAbi))]
pub enum StaticNode {
    I64(i64),
    U64(u64),
    F64(f64),
    Bool(bool),
    Null,
}
----

`abi_stable` should be optional so that this change is applied only to those
that actually need {repr-c} in the library. You could also go a step further and
differentiate between enabling {repr-c} and deriving `StableAbi` for those that
don't need the latter. Since it's an external library, we'll have to make a Pull
Request and hope that the author is okay with the changes:

[.text-center]
{{< gh pr "simd-lite/value-trait" 14 "Add support for StableAbi" "paragraph" >}}

=== Overcoming problems with {repr-c}

Awesome. We got `Value` working now for FFI. Right? No? Oh. It seems like the
compiler strongly disagrees. By changing the variants of `Value`, a great amount
of the code that used it will now fail to compile in multiple ways:

[source, rust]
----
// Won't work because Value::String holds a RString now
let value = Value::String(String::new());
----

That's the easiest one, we just need to change `String` to `RString` and it
should be fine. The types in {{< crate abi_stable >}} are meant to be a drop-in
replacement for the ones in `std`:

[source, rust]
----
let value = Value::String(RString::new());
----

It gets a bit more complicated when the old types are exposed in methods,
because you have to decide whether or not to expand the FFI barrier from the
_internals_ of `Value` to the _users_ of `Value`. For instance, the
`Value::Object` variant holds a `RHashMap` now, but the method
`Value::as_object` used to return a reference to a `HashMap`. You'll get another
error in there, which raises a decision that must be made: returning `RHashMap`
or adding an internal conversion to `HashMap`.

[source, rust]
----
impl Value {
    // Original code
    fn as_object(&self) -> Option<&HashMap<String, Value>> {
        match self {
            // Problem: `m` is a `RHashMap` now, but the function returns a
            // `HashMap`.
            //
            // Solution 1: change the return type to `RHashMap`
            // Solution 2: convert `m` to a `HashMap` with `m.into()`
            Self::Object(m) => Some(m),
            _ => None,
        }
    }
}
----

* If the return type is changed to `RHashMap`, almost every caller to
  `as_object` in the program will now fail to compile because it expects a
  `HashMap`. You'll have to clean it up one by one and figure out how `RHashMap`
  can be used in that case instead. This is very messy because in order to avoid
  conversions, your plugin system will _infect_ the entire codebase.
+
You may quickly find yourself propagating the usage of `RHashMap` everywhere,
even when the PDK isn't that important. For example, `Value` was also used in
Trickle's implementation, the scripting language used to configure Tremor's
pipelines. Having to use `RHashMap` in there was a bit confusing, and I was
modifying lots of files unrelated to the plugin system.
* If you perform an internal conversion to `HashMap` in `as_object` we'll avoid
  all of these errors, but we're adding a small overhead. It's by far the
  easiest choice, but if `Value::as_object` is frequently used in e.g. your hot
  loop, you may notice a considerable performance degradation.
+
I https://nullderef.com/blog/plugin-abi-stable/#_type_conversions[already
investigated in the past], and the good news is that converting between types in
`std` and `abi_stable` is stem:[O(1)]. Most of the times it's equivalent to a
pointer cast or a match. So here's when the {work} approach is useful: we'll
just keep the FFI barrier minimal and add conversions as early as possible.
After we're done, we'll see if there are any performance issues, and then work
on them.

=== Reaching {repr-c} blockers

That was my first attempt at making `Value` FFI-compatible, and unfortunately,
it didn't end there. Converting from `std` to {{< crate abi_stable >}} is a
relatively painless experience; their usage intends to be the same. The only
issue I found in that regard is that some methods from `std` weren't yet
available in {{< crate abi_stable >}} because it's not updated as regularly.
Most of the times you can just copy-paste the implementation from `std` into {{<
crate abi_stable >}}'s and create a new Pull Request, which is what I did a few
times:

[.text-center]
{{< gh pr "rodrimati1992/abi_stable_crates" 58 "Add support for .keys() and .values() in RHashMap" >}}

[.text-center]
{{< gh pr "rodrimati1992/abi_stable_crates" 59 "Implement `Index` for slices and vectors" >}}

[.text-center]
{{< gh pr "rodrimati1992/abi_stable_crates" 61 "Support for `f32` and `f64`" >}}

[.text-center]
{{< gh pr "rodrimati1992/abi_stable_crates" 68 "Implement `ROption::as_deref`" >}}

[.text-center]
{{< gh pr "rodrimati1992/abi_stable_crates" 70 "Implement RVec::append" "paragraph" >}}

However, this stops being as "`easy`" when you have to convert from _an external
library_ to {{< crate abi_stable >}}. I lied at the beginning of the article:
the <<value_decl,declaration of `Value`>> was an oversimplification. For
performance reasons, Tremor actually uses {{< crate halfbrown >}}'s
implementation of a hash map instead of `std::collections::HashMap`.

{{< crate halfbrown >}} is based on {{< crate hashbrown >}}, which was, in fact,
merged into the standard library at some point. Although with this plugin system
we're suffering the consequences of not having a stable ABI, seeing that it
enables things like that makes me less bitter.

{{< crate halfbrown >}} has some additional functionality over ``std``'s
implementation. Some of it is actually available on Nightly, but for that reason
it's not meant to be in the stable `RHashMap` either. This extra functionality
is used in Tremor for example with
https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#method.raw_entry[`raw_entry`].
There is an optimization for JSON handling that consists on memoizing the hash
of a known item in a map in order to access its value directly with it. After
switching to `RHashMap`, this becomes an impossible task.

Even if I managed to fix the hash map mess, the same story repeats itself for
`Cow`. Tremor uses {{< crate beef >}}'s
https://docs.rs/beef/latest/beef/generic/struct.Cow.html[`Cow`] instead of
`std::borrow::Cow` because it's faster and more compact, at the cost of a
slightly different usage.

There are a few possible ways to approach these kinds of issues, which I'll
cover in the following subsections.

[[avoid]]
==== Avoid the type in the first place

As always, we'll try to follow the {work} advice in here. It's a perfectly valid
solution to just comment out the optimizations and add a `// TODO` above so that
they can be reviewed later. You might be asking for too much complexity in your
plugin system; limiting yourself to the functionality in `std` may be more than
enough for now. You'll see in the following sections that it's always possible
to fix this properly. It just might be too much effort at the moment.

In ``Value``'s specific case, it seems like removing the optimizations that are
giving us trouble is the easiest way to fix this problem. And it would, if
removing code wasn't also tricky when the optimizations aren't performed
internally and transparently to the hash map functionality. After trying to
remove them I eventually gave up because I considered it was getting out of
hands with so many changes:

.You're looking at *120* errors after attempting to remove the optimizations, most of them about lifetime hell
image::errors.png[width=100%, align=center]

==== Implement a wrapper

Another possibility is to write a _wrapper_ for {{< crate halfbrown >}}. Opaque
types, for instance, may be used to wrap the functionality of an underlying type
that's not FFI-safe, as I covered in previous articles. This is what {{< crate
abi_stable >}} does in its `external_types` module for crates like {{< crate
crossbeam >}} or {{< crate parking_lot >}}.

However, as you may see with the
https://github.com/rodrimati1992/abi_stable_crates/tree/edfb2a97a7b5d7ecbc29c1f9f115f61e26f42da6/abi_stable/src/external_types[already
existing examples], implementing wrappers can be quite a cumbersome task. And
even after you're done you'll have to keep them up to date, so this will
increase your maintainance burden. {{< crate halfbrown >}} and {{< crate beef
>}} are somewhat complex libraries, so I decided this wasn't the best choice at
that moment.

==== Re-implement with {repr-c} from scratch

Similar to implementing a wrapper, but on steroids. It might seem like overkill,
but as far as I know it's the only choice in some scenarios, because we can make
sure the type is as performant as it can get. In ``Value``'s example, the
problematic types are part of optimizations, so writing a wrapper over them may
have a performance hit and render them useless (e.g. if we used opaque types we
would introduce at least a mandatory pointer indirection).

If this part of the project is important enough, or you consider that there's
enough manpower, then it might not be such a bad idea to create a new
implementation with your use-case in mind. It's actually why Tremor's `Value`
was created in the first place; `simd_json::Value` wasn't flexible enough for
them, so they decided to define their own version. Same thing could be applied
for your plugin system.

==== Simplifying the type at the FFI boundary

The last idea I came up with was the easiest one: creating a copy of `Value`
meant to be used _only_ for FFI communication, `PdkValue`:

image::simplify.png[width=75%, align=center]

Since it's a new type, we won't run into the breaking changes I showed in the
<<avoid>> section, and it's quite easy to implement:

[source, rust]
----
#[repr(C)]
#[derive(StableAbi)]
pub enum PdkValue {
    /// Static values (integers, booleans, etc)
    Static(StaticNode),
    /// String type
    String(RString),
    /// Array type
    Array(RVec<PdkValue>),
    /// Object type
    Object(RBox<RHashMap<RString, PdkValue>>),
    /// A binary type
    Bytes(RVec<u8>),
}
----

We don't need to write any additional methods for the new `PdkValue`, only its
conversions in both ways. The problem is that these conversions are now
stem:[O(n)] instead of stem:[O(1)], because we have to iterate the objects and
arrays in order to convert its inner values as well:

[source, rust]
----
impl<'value> From<Value<'value>> for PdkValue<'value> {
    fn from(original: Value<'value>) -> Self {
        match original {
            // No conversion needed; `StaticNode` implements `StableAbi`
            Value::Static(s) => PdkValue::Static(s),
            // This conversion is cheap
            Value::String(s) => PdkValue::String(s.into()),
            // This unfortunately requires iterating the array
            Value::Array(a) => {
                let a = a.into_iter().map(Into::into).collect();
                PdkValue::Array(a)
            }
            // This unfortunately requires iterating the map and a new
            // allocation
            Value::Object(m) => {
                let m = m.into_iter().map(Into::into).collect();
                PdkValue::Object(RBox::new(m))
            }
            // This conversion is cheap
            Value::Bytes(b) => PdkValue::Bytes(conv_u8(b)),
        }
    }
}

// Same as before, but inversely
impl<'value> From<PdkValue<'value>> for Value<'value> {
    fn from(original: PdkValue<'value>) -> Self {
        match original {
            PdkValue::Static(s) => Value::Static(s),
            PdkValue::String(s) => Value::String(s.into()),
            PdkValue::Array(a) => {
                let a = a.into_iter().map(Into::into).collect();
                Value::Array(a)
            }
            PdkValue::Object(m) => {
                let m = m
                    .into_inner() // No Box dereference move magic with RBox :(
                    .into_iter()
                    .map(|Tuple2(k, v)| (k.into(), v.into()))
                    .collect();
                Value::Object(Box::new(m))
            }
            PdkValue::Bytes(b) => Value::Bytes(conv_u8_inv(b)),
        }
    }
}
----

And then we can use it like:

[source, rust]
----
// This is implemented in the plugin
pub extern "C" fn plugin_stuff(value: PdkValue) {
    let value = Value::from(value);
    value.do_stuff()
}

// This is implemented in the runtime
fn runtime_wrapper(value: Value) {
    plugin_stuff(value.into());
}
----

Surprisingly easy to get working! Two problems, though:

* *Usability*: the snippet of code above shows that the conversions introduce
  some noise in our code, as opposed to having a single {repr-c} `Value`. It
  could be worse, but it can get annoying when you have many ``Value``s in your
  runtime and have to pass them to the plugins.
+
This is acutally trivial enough to simplify with a macro, perferrably
procedural, at the cost of introducing more complexity. We're currently
following {work} so we'll leave that for the future.
* *Performance*: passing the value to the plugin and converting it back in there
  means we're iterating the data twice. With experiments that I'll include in
  the next article, I found out that these conversions make up 5 to 10% of
  Tremor's execution time. Which is less than I expected, but still not good
  enough for production.

// TODO: explain that it was my final choice

=== Asynchronous plugins

==== `async_ffi`

As much as I wanted to avoid communication primitives with the plugins other
than plain synchronous calls, it may inevitable if your program uses
asynchronous programming heavily, which is the case of Tremor. But turns out
that using `async` in FFI isn't that complicated!

In the previous post I introduced the {{< crate async_ffi >}} crate, which
exports FFI-compatible ``Future``s. And it's quite easy to use:

.Example from the docs
[source, rust]
----
use async_ffi::{FfiFuture, FutureExt};

#[no_mangle]
pub extern "C" fn work(arg: u32) -> FfiFuture<u32> {
    async move {
        let ret = do_some_io(arg).await;
        do_some_sleep(42).await;
        ret
    }
    .into_ffi()
}
----

The types in {{< crate async_ffi >}} implement `Future`, so calling that
function is as easy as usual; just adding an `.await` after the parenthesis.

It's admittedly a bit ugly to use `async move { }.into_ffi()` everywhere,
specially because it increases the indentation in one level. But that's
something that can be fixed with a
https://github.com/oxalica/async-ffi/issues/12[procedural macro in the future].

The only problem was that the futures didn't implement `StableAbi`, so it wasn't
possible to use with {{< crate abi_stable >}}. It took me a while to understand
the crate, but it's nothing a Pull Request can't fix:

[.text-center]
{{< gh pr "oxalica/async-ffi" 10 "Support for `abi_stable`" "paragraph" >}}

One concern here may be performance. I imagine that it's not a huge problem
because the crate is actualy quite small and only introduces some pointer
juggling. I will confirm this in the next post with some benchmarks, though.

==== Channels

Tremor also needs some channels for asynchronous communication. For example, a
connector may need to indicate the runtime that the connection has been lost at
any point of its execution.

This is because it's very likely that this connection drop
happens at any point of the plugin execution. Many plugins will spawn a new task
to run in the background (think of a TCP server), which is what's going to
notify the runtime. We can't delay that until the next synchronous call happens
because we don't know when that might happen, and we want to keep Tremor
low-latency.

We have two options here:

* Keep using a channel: turns out `abi_stable` includes an FFI-safe wrapper for
  {{< crate crossbeam >}}. We could just switch the usage of `Sender<T>` to
  https://docs.rs/abi_stable/latest/abi_stable/external_types/crossbeam_channel/struct.RSender.html[`RSender<T>`]
  and that's it.
* Try to use something simpler: I was wondering if we could manage to avoid
  pulling in `crossbeam` and using channels.

// TODO: talk about callbacks

[source, text]
----
error[E0308]: mismatched types
  --> src/lib.rs:22:17
   |
22 |           sender: |x| {
   |  _________________^
23 | |             i += x;
24 | |             println!("callback invoked v3! {}", x)
25 | |         }
   | |_________^ expected fn pointer, found closure
   |
   = note: expected fn pointer `fn(i32)`
                 found closure `[closure@src/lib.rs:22:17: 25:10]`
note: closures can only be coerced to `fn` types if they do not capture any variables
  --> src/lib.rs:23:13
   |
23 |             i += x;
   |             ^ `i` captured here

For more information about this error, try `rustc --explain E0308`.
----

== Separating runtime and interface

In the previous articles I've been assuming the following structure for the
plugin system:

* The runtime crate, which loads and runs the plugins.
* The `common` crate, with the interface shared between the plugin and the
  runtime.
* The plugin crates, with the loadable functionality.

This is essential in order to actually improve compilation times, which is one
of the main objectives of our plugin system. There are two ways to look at
compilation times:

. For runtime development
. For plugin development

In both cases, we want to compile _only_ either component. If we're developing a
plugin, it makes no sense to be forced to compile the runtime as well, because
we aren't actually changing it. And if we're working on the runtime, we don't
want to re-compile the functionality from the plugins.

If we just separate the runtime from the plugins, we can achieve the first
point. Your functionality is now in separate plugin binaries, so the runtime
will have considerably lower compilation times.

But in order to also improve plugin compilation times, if the interface is in
the same crate as the runtime, we'll have to compile both. The shared parts
should be written in a separate crate.

However, if you aren't starting from scratch, it's very likely that you don't
have a `common` crate. You'll just have a single binary crate with both the
runtime and the functionality in `common`.

This isn't really a problem, since you can just have the plugins depend on the
runtime crate rather than `common`, and skip it altogether. But one of the
points of making this PDK is decreasing your compile times

== Getting it ready for deployment

== Conclusion

That's basically how I managed to implement the PDK for Tremor. As I covered in
the <<advice,first section>>, though, it's only a prototype, and we need to
polish it. It seems to work perfectly when I execute the runtime manually and
load some simple plugins I've implemented. But the final step consists on making
the PDK ready for deployment. This means cleaning up, testing, and benchmarking.
For instance, I managed to make Tremor... 35% slower on release!

// TODO: insert picture in presentation

So yeah, I still have some work to do in that regard. But it's super cool to
finally have it compiling and running. The next and last article will cover my
last step in trying to make the PDK ready for Tremor's next version.

Lastly, I've found it especially rewarding to do all of this in an open source
environment. Even if you're working for a company with propietary software,
please try to contribute upstream instead of forking or patching. Try to be nice
to those who are saving you so much work, and submit a PR or an issue:

// TODO: use github shortcode
.Most of my contributions while implementing the PDK
* https://github.com/oxalica/async-ffi/pull/10
* https://github.com/oxalica/async-ffi/pull/11
* https://github.com/rodrimati1992/abi_stable_crates/pull/58
* https://github.com/rodrimati1992/abi_stable_crates/pull/59
* https://github.com/rodrimati1992/abi_stable_crates/pull/61
* https://github.com/rodrimati1992/abi_stable_crates/pull/68
* https://github.com/rodrimati1992/abi_stable_crates/pull/70
* https://github.com/rodrimati1992/abi_stable_crates/pull/74
* https://github.com/simd-lite/simd-json-derive/pull/9
* https://github.com/simd-lite/value-trait/pull/14
* https://github.com/simd-lite/value-trait/pull/16
* https://github.com/simd-lite/value-trait/pull/18

[bibliography]
== References

- [[[nginx-perf,      1]]] http://httpd.apache.org/docs/2.4/dso.html#advantages
- [[[libloading-th,   2]]] https://docs.rs/libloading/0.7.1/libloading/struct.Library.html#thread-safety
- [[[dlerror-th,      3]]] https://pubs.opengroup.org/onlinepubs/009604499/functions/dlerror.html
- [[[linux-th,        4]]] https://man7.org/linux/man-pages/man3/dlerror.3.html#ATTRIBUTES
- [[[macos-th,        5]]] https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlerror.3.html
- [[[windows-th,      6]]] https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setthreaderrormode
- [[[unwinding,       7]]] https://doc.rust-lang.org/nomicon/unwinding.html
