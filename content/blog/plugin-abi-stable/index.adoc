---
title: "Plugins in Rust: Reducing the Pain with abi_stable"
description: "TODO"
author: "Mario Ortiz Manero"
tags: ["rust", "dynamic-loading"]
series: ["rust-plugins"]
date: 2021-10-15
GHissueID: 30
---

:sectnums:
:stem: latexmath

:repr-c: pass:quotes[`#[repr\(C)]`]

https://nullderef.com/blog/plugin-dynload/[The last article] of this
https://nullderef.com/series/rust-plugins/[series] covered how the plugin system
could be implemented from scratch. We all know that this isn't a good idea, so
let's try doing the same things with the {{< crate abi_stable >}} crate, which
was specifically created for this kind of task.

I've already talked a lot about `abi_stable` in this series, but I haven't
really tried it out myself. Will it actually make plugin-writing an easier and
safer task, or is the additional complexity too much? Are there any alternatives
that we perhaps should consider? This is what I'll try to cover in this post.

== About Tremor

== Async with the C ABI

In a previous post I mentioned that async was not supported in `abi_stable`.
While this is true, because there is no FFI-safe `Future` in the crate, it's
certainly possible, and it might be of interest later on.

Matthew recently let me know about the {{< crate async_ffi >}} crate, which lets
us do exactly that. It exports the type `FfiFuture<T>`, which provides the same
functionality as `Box<dyn Future<Output = T> + Send>`:

[source, rust]
----
// This is how regular async works: the first function is practically equivalent
// to the second.
async fn example() -> String {
    read_file().await
}
fn example() -> impl Future<Output = String> {
    async {
        read_file().await
    }
}

// For FFI-safe interfaces there can't be generics involved, so the future is a
// struct instead of a trait. This conversion from `Future` to `FfiFuture` can
//be done with `into_ffi`.
fn example() -> FfiFuture<String> {
    async move {
        read_file().await
    }
    .into_ffi()
}
// `FfiFuture<T>` implements `Future<Output = T>`, so it can be awaited as usual
async fn user() {
    example().await
}
----

https://github.com/rodrimati1992/abi_stable_crates/issues/25[Someone asked for
this feature in `abi_stable` back in 2019], but noone seemed interested enough
to implement it at that time, so maybe in the future.

[[cglue]]
== An alternative to `abi_stable`: `cglue`

I very recently discovered the {{< crate cglue >}} crate. It takes a different
approach to ABI stability, which I think is pretty interesting. Instead of
rewriting parts of the standard library using {repr-c}, `cglue` achieves
FFI-safety by using _opaque types_.

An opaque type is simply one for which you don't know its concrete layout.
There's no {repr-c} needed at all, because one can only interact with it via
void pointers and its associated wrapper vtables.

`cglue` is not a simple library either. It seems easier to use than
`abi_stable`, but that might be because it's more barebones and work-in-progress
as of this writing; `abi_stable` provides functionality to even _load_ the
plugins safely. Its README showcases the following snippet of code, and the repo
even includes an https://github.com/h33p/cglue/tree/main/examples[example of a
plugin system].

.Sample usage for `cglue`
[source, rust]
----
use cglue::*;

// One annotation for the trait.
#[cglue_trait]
pub trait InfoPrinter {
    fn print_info(&self);
}

struct Info {
    value: usize
}

impl InfoPrinter for Info {
    fn print_info(&self) {
        println!("Info struct: {}", self.value);
    }
}

fn use_info_printer(printer: &impl InfoPrinter) {
    println!("Printing info:");
    printer.print_info();
}

fn main() -> () {
    let mut info = Info {
        value: 5
    };

    // Here, the object is fully opaque, and is FFI and ABI safe.
    let obj = trait_obj!(&mut info as InfoPrinter);

    use_info_printer(&obj);
}
----

The main benefit it seems to provide is that with `cglue` you can generate
bindings for C/C++, which means that plugins can be written in languages other
than Rust, unlike `abi_stable`. It's not useful for my case, but if you're
interested in that, perhaps you should take a deeper look.

I will personally keep using `abi_stable` simply because it seems like the
safest bet, but I'll definitely keep an eye on `cglue`, as it might turn into a
neater way to implement plugin systems.

== Setting up Miri (?)

TODO not sure if this is necessary

== Setting up cbindgen

For the first steps with dynamic loading I think {{< crate cbindgen >}} will
help us understand what's going on. We can take a look at the generated headers
and see how it works internally. Unfortunately, it fails to run for the
`abi_stable` crate:

[source, text]
----
(...)
WARN: Skip abi_stable::CONST - (...)
 
thread 'main' panicked at 'RResult has 2 params but is being instantiated with 1 values', src/bindgen/ir/enumeration.rs:596:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
----

This _probably_ has to do with the following warning found in
https://github.com/eqrion/cbindgen/blob/master/docs.md[``cbindgen``'s
documentation]:

____
pass:[NOTE:] A major limitation of cbindgen is that it does not understand
Rust's module system or namespacing. This means that if cbindgen sees that it
needs the definition for `MyType` and there exists two things in your project
with the type name `MyType`, it won't know what to do. Currently, cbindgen's
behaviour is unspecified if this happens. However this may be ok if they have
https://github.com/eqrion/cbindgen/blob/master/docs.md#defines-and-cfgs[different
cfgs].
____

After letting the maintainers of `abi_stable` know about this in
https://github.com/rodrimati1992/abi_stable_crates/issues/52[an issue], they
pointed out that this was expected and that they don't plan on supporting
`cbindgen` because it would take too much effort. Understandable, so let's move
on.

== Working with `abi_stable`

Let's start comparing `abi_stable` with the raw dynamic linking information I
wrote in the previous post.

I've created the `abi-stable-simple` experiment
https://github.com/marioortizmanero/pdk-experiments[in the pdk-experiments
repository]. I'll be taking a look at the already implemented
https://github.com/rodrimati1992/abi_stable_crates/tree/master/examples[examples]
in order to make the learning experience smoother.

The base structure for a plugin system with `abi_stable` is the same as always:
a crate for the plugin, another for the runtime, and the last one for `common`,
with the interface that's shared between the two.

The
https://docs.rs/abi_stable/latest/abi_stable/abi_stability/stable_abi_trait/trait.StableAbi.html[`StableAbi`]
trait indicates that a type is FFI-safe. It contains information about the
layout of the type, and it can be
https://docs.rs/abi_stable/latest/abi_stable/derive.StableAbi.html[derived
automatically]. `abi_stable` exports many alternatives to the standard library
that implement `StableAbi`: `RStr`, `RSlice<T>`, `RArc<T>`, etc.

== Versioning

`abi_stable` states this regarding versioning:

[quote, 'https://github.com/rodrimati1992/abi_stable_crates#safety[`abi_stable` README]']
____
This library ensures that the loaded libraries are safe to use through these
mechanisms:

* The abi_stable ABI of the library is checked, Each `0.y.0` version and `x.0.0`
  version of abi_stable defines its own ABI which is incompatible with previous
  versions.
* Types are recursively checked when the dynamic library is loaded, before any
  function can be called.
____

In summary, `abi_stable` isn't always backward compatible, but it automatically
makes sure that its versions are compatible when running the plugin. While it
doesn't exactly stick to semantic versioning, it's good enough for us.

The base version checking for the entire `common` crate I talked about in raw
dynamic loading is already implemented, but we could also add a version string
for each kind of plugin if more fine-grained control is needed.

== Loading plugins

`abi_stable` plugins are structured in _modules_, which can help us split up our
functionality into smaller independent pieces. There must always be a
https://docs.rs/abi_stable/latest/abi_stable/library/trait.RootModule.html[root
module] that initializes the entire library and provides metadata such as the
name or the version strings. Then, we can have submodules to organize the
functions exported by the library nicely.

This example also introduces the concept of
https://docs.rs/abi_stable/latest/abi_stable/docs/prefix_types/index.html[_prefix
types_]. When a type derives `StableAbi` and has the
`#[sabi(kind(Prefix(....)))]` attribute, two more types are generated:

* `<name>_Prefix`, which contains all the fields up to the
  `#[sabi(last_prefix_field)]` attribute in the original type.
* `<name>_Ref`, which is a pointer to `<name>_Prefix` that can actually be
  passed through the FFI barrier safely.

Prefix types are needed because `abi_stable` doesn't just need {repr-c} structs,
but also some kind of versioning to avoid breakage in future patches. It will
let us add more fields to the module _after_ `last_prefix_field` in patch
(0.0.x) updates to the interface. Moving this attribute requires a
backward-incompatible version bump. Prefix types are used for modules and
vtables, the only parts exported by the plugin.

For now, I'll just have a single root module and call it `MinMod`, implementing
the `min` function:

[source, rust]
----
// Using the stable C ABI
#[repr(C)]
// Deriving the `StableAbi` trait, which defines the layout of the struct at
// compile-time:
// https://docs.rs/abi_stable/0.10.2/abi_stable/derive.StableAbi.html
#[derive(StableAbi)]
// Marking the struct as a prefix-type:
// https://docs.rs/abi_stable/0.10.2/abi_stable/docs/prefix_types/index.html
#[sabi(kind(Prefix))]
pub struct MinMod {
    /// Initializes the state, which will be passed to the functions in this
    /// module.
    pub new: extern "C" fn() -> State,

    /// Calculates the minimum between two integers
    pub min: extern "C" fn(&mut State, i32, i32) -> i32,
}
----

Most of the loading functionality is already handled by `abi_stable`. The module
we're exporting implements the `RootModule` trait, which includes functions to
load the plugin, such as
https://docs.rs/abi_stable/latest/abi_stable/library/trait.RootModule.html#method.load_from_file[`RootModule::load_from_file`]
or
https://docs.rs/abi_stable/latest/abi_stable/library/trait.RootModule.html#method.load_from_directory[`RootModule::load_from_directory`]:

[source, rust]
----
// Marking `MinMod` as the main module in this plugin. Note that `MinMod_Ref` is
// a pointer to the prefix of `MinMod`.
impl RootModule for MinMod_Ref {
    // The name of the dynamic library
    const BASE_NAME: &'static str = "min";
    // The name of the library for logging and similars
    const NAME: &'static str = "min";
    // The version of this plugin's crate
    const VERSION_STRINGS: VersionStrings = package_version_strings!();

    // Implements the `RootModule::root_module_statics` function, which is the
    // only required implementation for the `RootModule` trait.
    declare_root_module_statics!{MinMod_Ref}
}
----

When loading directories, it makes the following decisions, by default (we could
change them if we wanted to):

* It does so non-recursively, i.e. only checking the immediate files in the
  given directory.
* The name of the library must be the `RootModule::BASE_NAME` in lowercase,
  according to the https://doc.rust-lang.org/std/env/consts/index.html[Operating
  System's defaults]. For example, in Linux our plugin would be `libmin.so`, and
  on Windows it'd be `min.dll`.

This means that we should add the following parameter to the plugin's
`Cargo.toml` file:

[source, toml]
----
[lib]
# This way, the shared object will be saved as `abi_stable` prefers, for example
# `libmin.so`.
name = "min"
----

== Handling state

If we wanted to define a state trait that plugins implement so that it can be
"`generically`" passed to functions in the plugin interface, it might look like
this:

.In the `common` crate
[source, rust]
----
trait State: Serialize, Deserialize, Debug, PartialEq {}

type StateBox = Box<dyn State>;

// Remember that we can't use generics, so we need `dyn`, either by itself as a
// reference, or in a box.
fn usage(state: &mut StateBox) {}
----

Unfortunately, regular `dyn` is not FFI-safe. We can resort to ``abi_stable``'s
alternative, which is used as follows:

[source, rust]
----
#[repr(C)]
#[derive(StableAbi)]
// An `InterfaceType` describes which traits are required when constructing
// `StateBox` and are then usable afterwards.
#[sabi(impl_InterfaceType(Serialize, Deserialize, Debug, PartialEq))]
struct State;

// A trait object for `State`
type StateBox = DynTrait<'static, RBox<()>, State>;

// It can then be used easily like this
fn usage(state: &mut StateBox) {}
----

Here we first declare a `State`
https://docs.rs/abi_stable/latest/abi_stable/trait.InterfaceType.html[_interface
type_]. Note that even though it's defined as a `struct`, this is a translation
of the previous snippet of code, which would be located in the `common` crate.
It sets `Serialize`, `Deserialize`, `Debug` and `PartialEq` as its supertraits.

Since
https://docs.rs/abi_stable/latest/abi_stable/struct.DynTrait.html[`DynTrait<T>`],
implements `StableAbi`, we can safely use it through the FFI barrier.

== Error handling

TODO nginx modules: https://www.nginx.com/resources/wiki/extending/

TODO apache https modules: http://httpd.apache.org/docs/2.4/developer/modguide.html http://httpd.apache.org/docs/2.4/dso.html

With the exception of the wrong address example, because we don't even need to
pass pointers.

=== Missing fields and wrong types

`abi_stable` recursively checks the layouts of the types before trying to load
them to make sure they're compatible.

[source, text]
----
$ make debug-wrongtype
Error when running the plugin:
Compared <this>:
    --- Type Layout ---
    type:PrefixRef<'a, MinMod>
    (...)
To <other>:
    --- Type Layout ---
    type:PrefixRef<'a, MinMod>
    (...)

0 error(s).

1 error(s)inside:
    <other>

    field_name:0
    type:MinMod
    size:0 align:8
    package:'common-sabi-simple-wrong' version:'0.2.0'

Layout of expected type:
    --- Type Layout ---
    type:MinMod
    (...)

Layout of found type:
    --- Type Layout ---
    type:MinMod
    (...)

Error:mismatched package
Expected:
    common-sabi-simple
Found:
    common-sabi-simple-wrong
----

=== Version mismatch

[source, text]
----
$ make debug-versionmismatch
----

=== Panicking

`abi_stable` can't do anything about the unsafety of panicking in plugins. It
will simply abort the program, similarly to what happens with raw FFI:

[source, text]
----
$ make debug-panic
Loading plugin min
initial state: State { counter: 0 }
thread '<unnamed>' panicked at 'This will crash everything', src/lib.rs:26:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

file:src/lib.rs
line:24
Attempted to panic across the ffi boundary.
Aborting to handle the panic...
----

Plugins should still use
https://doc.rust-lang.org/std/panic/fn.catch_unwind.html[`catch_unwind`] in
order to avoid this from happening.

== Type conversions to `abi_stable`

It's important to know the complexity of conversions from/to `abi_stable` types.
If `std::Vec` -> `abi_stable::RVec` wasn't stem:[O(n)] it might be worth using
only the latter throughout the entirety of Tremor.

This means that I should spend at least a bit of my time on understanding how
the `abi_stable` types are implemented and making sure this isn't the case. In
`std`, the definition of `Vec` is actually quite simple if we remove most of the
noise:

[source, rust]
----
// A non-null pointer to `T` that indicates ownership.
pub struct Unique<T: ?Sized> {
    pointer: *const T, // The data itself
    _marker: PhantomData<T>, // Indicating that we own a `T`
}

// Low level type related to allocation
pub struct RawVec<T> {
    ptr: Unique<T>,
    cap: usize,
}

pub struct Vec<T> {
    buf: RawVec<T>,
    len: usize,
}
----

It's mostly self-explanatory; a `Vec<T>` is a pointer to `T` with a set capacity
and length. What about ``abi_stable``'s implementation?

[source, rust]
----
#[repr(C)] // Notice this, so that it's FFI-safe
#[derive(StableAbi)] // This trait marks `RVec` as FFI-safe, with info about its layout
pub struct RVec<T> {
    pub(super) buffer: *mut T,
    pub(super) length: usize,
    capacity: usize,
    vtable: VecVTable_Ref<T>,
    _marker: PhantomData<T>,
}
----

Yup, basically the same, but packed inside a single struct. The only real
difference is that we have a field with the vtable, which I'll cover later on.
The conversion between these types is written with a macro, but if expanded, it
looks like this:

[source, rust]
----
impl<T> From<Vec<T>> for RVec<T> {
    fn from(this: Vec<T>) -> RVec<T> {
        let mut this = std::mem::ManuallyDrop::new(this);
        RVec {
            vtable: VTableGetter::<T>::LIB_VTABLE,
            buffer: this.as_mut_ptr(),
            length: this.len(),
            capacity: this.capacity(),
            _marker: PhantomData,
        }
    }
}
----

The only "`weird`" part is the usage of `std::mem::ManuallyDrop`, which simply
is a wrapper that indicates Rust to not call the destructor of its contents
automatically. In this case it's basically a less error prone
`std::mem::forget`, as
https://doc.rust-lang.org/stable/std/mem/fn.forget.html#relationship-with-manuallydrop[its
docs explain]. Thanks to it, the memory from the vector won't be dropped when
this function ends, and it can be safely moved into the `RVec`, with no copying.

This happens for every type I checked in `abi_stable`, including `RSlice<T>`,
which contains a reference to a slice, `RStr`, which is just a `RSlice<u8>`, and
`RString`, which is just a `RVec`.

== Performance

I moved to criterion after using it for X post.

These are the results of the benchmarks.

[source, text]
----
dynamic setup           time:   [6.8134 us 6.8284 us 6.8448 us]
Found 7 outliers among 100 measurements (7.00%)
  1 (1.00%) low mild
  3 (3.00%) high mild
  3 (3.00%) high severe

abi_stable setup        time:   [36.056 ns 36.134 ns 36.210 ns]
Found 3 outliers among 100 measurements (3.00%)
  1 (1.00%) low mild
  1 (1.00%) high mild
  1 (1.00%) high severe

dynamic runtime         time:   [1.8568 ns 1.8601 ns 1.8635 ns]
Found 6 outliers among 100 measurements (6.00%)
  4 (4.00%) high mild
  2 (2.00%) high severe

abi_stable runtime      time:   [2.1087 ns 2.1138 ns 2.1203 ns]
Found 4 outliers among 100 measurements (4.00%)
  1 (1.00%) high mild
  3 (3.00%) high severe

native runtime          time:   [817.08 ps 819.60 ps 822.79 ps]
Found 5 outliers among 100 measurements (5.00%)
  2 (2.00%) high mild
  3 (3.00%) high severe
----

TODO conclusion (setup doesn't matter that much, is stable_abi fast enough?,
native was optimized away with fixed inputs)

The problem with the native runtime benchmark was that the Rust compiler is too
smart.

You can find more detailed information in the `criterion-reports` directory of
the repository.

== Thread safety (?)

////
TODO: note that abi_stable uses libloading, which is not fully thread-safe in
some situations, mostly in error handling (dlerror).
////

== Full implementation

Since it may be simpler to get `native-connector` running, let's start with
that. We'll just copy all the necessary code for the
https://github.com/tremor-rs/tremor-runtime/tree/883f13e29b4c6ec7b6703f2487aac321c738e7c8[current
implementation] of connectors as a standalone program:

== Conclusion

////
== Benchmarking

I've always wanted to run some benchmarks in order to find out the actual
difference in performance between dynamic loading (with native code) and Wasm
(with interpreted code). Of course, the former will be faster. But, is it
noticeable?

TODO compare with already existing benchmarks, what to expect, etc

Now that I have some examples of both dynamic loading and Wasm plugins, I can
make a few benchmarks in order to see the difference by myself. The `wasm-bench`
and `dynamic-bench` directories in
https://github.com/marioortizmanero/pdk-experiments[pdk-experiments] can be
compiled and then ran with
https://doc.rust-lang.org/1.7.0/book/benchmark-tests.html[Rust's integrated
benchmarking system] (which requires nightly for now)
////

[bibliography]
== References

- [[[extern,          1]]] https://doc.rust-lang.org/std/keyword.extern.html
