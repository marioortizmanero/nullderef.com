---
title: "Plugins in Rust: Reducing the Pain with abi_stable"
description: "TODO"
author: "Mario Ortiz Manero"
tags: ["rust", "dynamic-loading"]
series: ["rust-plugins"]
date: 2021-10-15
GHissueID: 30
---

:sectnums:
:stem: latexmath

:repr-c: pass:quotes[`#[repr\(C)]`]

https://nullderef.com/blog/plugin-dynload/[The last article] of this
https://nullderef.com/series/rust-plugins/[series] covered how the plugin system
could be implemented from scratch. This is really complicated if you're dealing
with a relatively large codebase and therefore a complex interface in your
plugin system, so let's see how we can make our lives easier. I've been wanting
to try {{< crate abi_stable >}} for this since the beginning, which was
specifically created for plugins. But we aren't really locked to that crate, so
I'll show other alternatives as well.

== About Tremor

== Handy tools for our Plugin System

=== Async with the C ABI

In a previous post I mentioned that async was not supported in `abi_stable`.
While this is true, because there is no FFI-safe `Future` in the crate, it's
certainly possible, and it might be of interest later on.

Matthew recently let me know about the {{< crate async_ffi >}} crate, which lets
us do exactly that. It exports the type `FfiFuture<T>`, which provides the same
functionality as `Box<dyn Future<Output = T> + Send>`:

[source, rust]
----
// This is how regular async works: the first function is practically equivalent
// to the second.
async fn example() -> String {
    read_file().await
}
fn example() -> impl Future<Output = String> {
    async {
        read_file().await
    }
}

// For FFI-safe interfaces there can't be generics involved, so the future is a
// struct instead of a trait. This conversion from `Future` to `FfiFuture` can
//be done with `into_ffi`.
fn example() -> FfiFuture<String> {
    async move {
        read_file().await
    }
    .into_ffi()
}
// `FfiFuture<T>` implements `Future<Output = T>`, so it can be awaited as usual
async fn user() {
    example().await
}
----

https://github.com/rodrimati1992/abi_stable_crates/issues/25[Someone asked for
this feature in `abi_stable` back in 2019], but noone seemed interested enough
to implement it at that time, so maybe in the future.

=== LCCC

// TODO: research https://github.com/LightningCreations/lccc/tree/riir/xlang/xlang_abi/src/

=== CGlue

// TODO: ask if it's the same as `sabi_trait` but with trait groups

I very recently discovered the {{< crate cglue >}} crate. It takes a different
approach to ABI stability, which I think is pretty interesting. Instead of
rewriting parts of the standard library using {repr-c}, `cglue` achieves
FFI-safety by using _opaque types_.

An opaque type is simply one for which you don't know its concrete layout.
There's no {repr-c} needed at all, because one can only interact with it via
void pointers and its associated wrapper vtables.

`cglue` is not a simple library either. It seems easier to use than
`abi_stable`, but that might be because it's more barebones and work-in-progress
as of this writing; `abi_stable` provides functionality to even _load_ the
plugins safely. Its README showcases the following snippet of code, and the repo
even includes an https://github.com/h33p/cglue/tree/main/examples[example of a
plugin system].

.Sample usage for `cglue`
[source, rust]
----
use cglue::*;

// One annotation for the trait.
#[cglue_trait]
pub trait InfoPrinter {
    fn print_info(&self);
}

struct Info {
    value: usize
}

impl InfoPrinter for Info {
    fn print_info(&self) {
        println!("Info struct: {}", self.value);
    }
}

fn use_info_printer(printer: &impl InfoPrinter) {
    println!("Printing info:");
    printer.print_info();
}

fn main() -> () {
    let mut info = Info {
        value: 5
    };

    // Here, the object is fully opaque, and is FFI and ABI safe.
    let obj = trait_obj!(&mut info as InfoPrinter);

    use_info_printer(&obj);
}
----

The main benefit it seems to provide is that with `cglue` you can generate
bindings for C/C++, which means that plugins can be written in languages other
than Rust, unlike `abi_stable`. It's not useful for my case, but if you're
interested in that, perhaps you should take a deeper look.

I will personally keep using `abi_stable` simply because it seems like the
safest bet, but I'll definitely keep an eye on `cglue`, as it might turn into a
neater way to implement plugin systems.

=== Miri

TODO not sure if this is necessary

=== cbindgen

For the first steps with dynamic loading I think {{< crate cbindgen >}} will
help us understand what's going on. We can take a look at the generated headers
and see how it works internally. Unfortunately, it fails to run for the
`abi_stable` crate:

[source, text]
----
(...)
WARN: Skip abi_stable::CONST - (...)
 
thread 'main' panicked at 'RResult has 2 params but is being instantiated with 1 values', src/bindgen/ir/enumeration.rs:596:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
----

This _probably_ has to do with the following warning found in
https://github.com/eqrion/cbindgen/blob/master/docs.md[``cbindgen``'s
documentation]:

____
pass:[NOTE:] A major limitation of cbindgen is that it does not understand
Rust's module system or namespacing. This means that if cbindgen sees that it
needs the definition for `MyType` and there exists two things in your project
with the type name `MyType`, it won't know what to do. Currently, cbindgen's
behaviour is unspecified if this happens. However this may be ok if they have
https://github.com/eqrion/cbindgen/blob/master/docs.md#defines-and-cfgs[different
cfgs].
____

After letting the maintainers of `abi_stable` know about this in
https://github.com/rodrimati1992/abi_stable_crates/issues/52[an issue], they
pointed out that this was expected and that they don't plan on supporting
`cbindgen` because it would take too much effort. Understandable, so let's move
on.

== Working with `abi_stable`

Let's start comparing `abi_stable` with the raw dynamic linking information I
wrote in the previous post. I've created the `abi-stable-simple` experiment
https://github.com/marioortizmanero/pdk-experiments[in the pdk-experiments
repository]. I'll be taking a look at the already implemented
https://github.com/rodrimati1992/abi_stable_crates/tree/master/examples[examples]
in order to make the learning experience smoother.

The base structure for a plugin system with `abi_stable` is the same as always:
a crate for the plugin, another for the runtime, and `common`, with the
shared interface.

== Versioning

`abi_stable` states this regarding versioning:

[quote, 'https://github.com/rodrimati1992/abi_stable_crates#safety[`abi_stable` README]']
____
This library ensures that the loaded libraries are safe to use through these
mechanisms:

* The abi_stable ABI of the library is checked, Each `0.y.0` version and `x.0.0`
  version of abi_stable defines its own ABI which is incompatible with previous
  versions.
* Types are recursively checked when the dynamic library is loaded, before any
  function can be called.
____

In summary, `abi_stable` isn't always backward compatible, but it automatically
makes sure that its versions are compatible when running the plugin. While it
doesn't exactly stick to semantic versioning, it's good enough for us.

The base version checking for the entire `common` crate I talked about in raw
dynamic loading is already implemented, but we could also add a version string
for each kind of plugin if more fine-grained control is needed.

== Loading plugins

`abi_stable` plugins are structured in _modules_, which can help us split up our
functionality into smaller independent pieces. There must always be a
https://docs.rs/abi_stable/latest/abi_stable/library/trait.RootModule.html[root
module] that initializes the entire library and provides metadata such as the
name or the version strings. Then, we can have submodules to organize the
functions exported by the library nicely.

The
https://docs.rs/abi_stable/latest/abi_stable/abi_stability/stable_abi_trait/trait.StableAbi.html[`StableAbi`]
trait in `abi_stable` indicates that a type is FFI-safe. It contains information
about the layout of the type, and it can be
https://docs.rs/abi_stable/latest/abi_stable/derive.StableAbi.html[derived
automatically]. `abi_stable` exports many alternatives to the standard library
that implement this trait: `RStr`, `RSlice<T>`, `RArc<T>`, etc.

This example also introduces the concept of
https://docs.rs/abi_stable/latest/abi_stable/docs/prefix_types/index.html[_prefix
types_]. When a type derives `StableAbi` and has the
`#[sabi(kind(Prefix(...)))]` attribute, two more types are generated:

* `<name>_Prefix`, which contains all the fields up to the
  `#[sabi(last_prefix_field)]` attribute in the original type.
* `<name>_Ref`, which is a pointer to `<name>_Prefix` that can actually be
  passed through the FFI barrier safely.

Prefix types are needed because `abi_stable` doesn't just need {repr-c} structs,
but also some kind of versioning to avoid breakage in future patches. It will
let us add more fields to the module after the `last_prefix_field` attribute in
patch (0.0.x) updates. Moving this attribute requires a backward-incompatible
version bump. Prefix types are used for modules and vtables, the only parts
exported by the plugin.

For now, I'll just have a single root module and call it `MinMod`, implementing
the `min` function:

[source, rust]
----
// Using the stable C ABI
#[repr(C)]
// Deriving the `StableAbi` trait, which defines the layout of the struct at
// compile-time:
// https://docs.rs/abi_stable/0.10.2/abi_stable/derive.StableAbi.html
#[derive(StableAbi)]
// Marking the struct as a prefix-type:
// https://docs.rs/abi_stable/0.10.2/abi_stable/docs/prefix_types/index.html
#[sabi(kind(Prefix))]
pub struct MinMod {
    /// Initializes the state, which will be passed to the functions in this
    /// module. I'll explain more about the state later on.
    pub new: extern "C" fn() -> State,

    /// Calculates the minimum between two integers
    pub min: extern "C" fn(&mut State, i32, i32) -> i32,
}
----

Most of the loading functionality is already handled by `abi_stable`. The module
we're exporting implements the `RootModule` trait, which includes functions to
load the plugin, such as
https://docs.rs/abi_stable/latest/abi_stable/library/trait.RootModule.html#method.load_from_file[`RootModule::load_from_file`]
or
https://docs.rs/abi_stable/latest/abi_stable/library/trait.RootModule.html#method.load_from_directory[`RootModule::load_from_directory`]:

[source, rust]
----
// Marking `MinMod` as the main module in this plugin. Note that `MinMod_Ref` is
// a pointer to the prefix of `MinMod`.
impl RootModule for MinMod_Ref {
    // The name of the dynamic library
    const BASE_NAME: &'static str = "min";
    // The name of the library for logging and similars
    const NAME: &'static str = "min";
    // The version of this plugin's crate
    const VERSION_STRINGS: VersionStrings = package_version_strings!();

    // Implements the `RootModule::root_module_statics` function, which is the
    // only required implementation for the `RootModule` trait.
    declare_root_module_statics!{MinMod_Ref}
}
----

When loading directories, it makes the following decisions by default (though we
could change them if we wanted to):

* It does so non-recursively, i.e. only checking the immediate files in the
  given directory.
* The name of the library must be the `RootModule::BASE_NAME` in lowercase,
  according to the https://doc.rust-lang.org/std/env/consts/index.html[Operating
  System's defaults]. For example, in Linux our plugin would be `libmin.so`, and
  on Windows it'd be `min.dll`.

This means that we should add the following parameter to the plugin's
`Cargo.toml` file:

[source, toml]
----
[lib]
# This way, the shared object will be saved as `abi_stable` prefers, for example
# `libmin.so`.
name = "min"
----

== Handling state

If we wanted to define a state trait that plugins implement so that it can be
"`generically`" passed to functions in the plugin interface, it might look like
this:

.In the `common` crate
[source, rust]
----
trait State: Serialize, Deserialize, Debug, PartialEq {}

type StateBox = Box<dyn State>;

// Remember that we can't use generics, so we need `dyn`, either by itself as a
// reference, or in a box.
fn usage(state: &mut StateBox) {}
----

Unfortunately, regular `dyn` is not FFI-safe. We can resort to ``abi_stable``'s
alternative, which is used as follows:

[source, rust]
----
#[repr(C)]
#[derive(StableAbi)]
// An `InterfaceType` describes which traits are required when constructing
// `StateBox` and are then usable afterwards.
#[sabi(impl_InterfaceType(Serialize, Deserialize, Debug, PartialEq))]
struct State;

// A trait object for `State`
type StateBox = DynTrait<'static, RBox<()>, State>;

// It can then be used easily like this
fn usage(state: &mut StateBox) {}
----

Here we first declare a `State`
https://docs.rs/abi_stable/latest/abi_stable/trait.InterfaceType.html[_interface
type_]. Note that even though it's defined as a `struct`, this is a translation
of the previous snippet of code, so it acts as the trait. Additionally, it sets
`Serialize`, `Deserialize`, `Debug` and `PartialEq` as its supertraits. Since
https://docs.rs/abi_stable/latest/abi_stable/struct.DynTrait.html[`DynTrait<T>`],
implements `StableAbi`, we can safely use it through the FFI barrier.

TODO: research https://docs.rs/abi_stable/0.10.2/abi_stable/attr.sabi_trait.html

== Error handling

`abi_stable` is just a wrapper over {{< crate libloading >}} after all. It
doesn't include a sandbox, so if the plugin developer was a malicious actor,
they'd have full access to the computer the runtime is being executed on. Other
popular plugin systems such as
https://www.nginx.com/resources/wiki/extending/[nginx's] or
http://httpd.apache.org/docs/2.4/dso.html[apache's] suffer from the same issues,
for reference.

However, I think it's not so bad to assume that no bad actors will be involved
here. A sandbox would be mandatory if we were working on something like
https://solana.com/[Solana] (one of the main users of eBPF in Rust), which
basically executes random code from the internet. But with Tremor we can assume
that the plugins come from trusted sources because they're installed and
configured manually by the user. There are still some security measures that
could be implemented in the future, like checking the integrity of the plugins
and verifying they come from a trusted source before loading them.

Still, we trust that the plugin developer has good intentions, but not
necessarily that they know what they're doing. We should make fatal errors as
hard as possible to happen so that Tremor isn't constantly crashing. The fewer
pitfalls, the better.

=== Version mismatch

The versions of the `common` library are checked before the types. In case
there's a mismatch in those considered incompatible (x.0.0 and 0.x.0), this is
what will show up:

[source, text]
----
$ make debug-versionmismatch
Error when running the plugin:

'min' library version mismatch:
user:0.2.0
library:0.1.0
----

We can absolutely catch this error gracefully and continue with the execution of
the runtime, just like with raw dynamic loading (but it's even easier).

=== Missing fields and wrong types

The layout of every type is recursively checked before trying to use them to
make sure they are compatible. Unlike raw dynamic loading, these errors can be
caught gracefully, which is a huge plus (it used to segfault):

[source, text]
----
$ make debug-wrongtype
Error when running the plugin:
Compared <this>:
    --- Type Layout ---
    type:PrefixRef<'a, MinMod>
    (...)
To <other>:
    --- Type Layout ---
    type:PrefixRef<'a, MinMod>
    (...)

0 error(s).

0 error(s)inside:
    <other>

    (...)

Layout of expected type:
    --- Type Layout ---
    type:MinMod
    (...)

Layout of found type:
    --- Type Layout ---
    type:MinMod
    (...)

3 error(s)inside:
    <other>
    (...)

Layout of expected type:
    --- Type Layout ---
    type:State
    (...)

Layout of found type:
    --- Type Layout ---
    type:State
    (...)

Error:incompatible type size
Expected:
    4
Found:
    1

Error:incompatible type alignment
Expected:
    4
Found:
    1

Error:unexpected field
Expected:
    field_name:counter
    type:i32
    size:4 align:4
    package:'std' version:'1.0.0'
Found:
    field_name:has_ran
    type:bool
    size:1 align:1
    package:'std' version:'1.0.0'
----

The error message is too long to show here, but it basically shows the entire
layout tree of the types that don't match for each of its versions (runtime and
plugin). For this example, I changed a field in the `State` struct from an
integer to a boolean, which the message describes perfectly: their sizes,
alignments and types differ.

=== Panicking

`abi_stable` can't do anything about the unsafety of panicking in plugins. It
will simply abort the program:

[source, text]
----
$ make debug-panic
Loading plugin min
initial state: State { counter: 0 }
thread '<unnamed>' panicked at 'This will crash everything', src/lib.rs:26:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

file:src/lib.rs
line:24
Attempted to panic across the ffi boundary.
Aborting to handle the panic...
----

Still, this is _undefined behaviour_; we aren't guaranteed that the plugin will
abort. It may just continue its execution in a completely invalid state, which
is scary. I will cover this topic in detail in the next section, since it
requires some in-depth investigation.

== Unwinding and FFI

////
TODO:
research https://rust-lang.github.io/rfcs/2945-c-unwind-abi.html
https://github.com/rust-lang/rust/pull/76570
////

As we've already seen, plugins cannot panic at the FFI boundary under any
circumstance. This means that every single function we export in the plugin
should wrap its contents in
https://doc.rust-lang.org/std/panic/fn.catch_unwind.html[`catch_unwind`].

_Unwinding_ simply means destroying all local objects and properly calling all
the destructors in the thread in order to continue execution safely
<<unwinding>>. This is something taken for granted when taking a look at
documentation about exceptions in Rust, but it wasn't so clear to me at the
beginning.

For example, the following snippet will panic after creating the vector. If
panics were configured to abort, the contents of the vector wouldn't be cleaned
up at all; the program would just end abruptly. But if it _unwinds_, Rust will
call its destructor, cleaning up its allocated memory properly, and being able
to continue the execution of the program.

[source, rust]
----
{
    let data = vec![1, 2, 3];
    panic!("oh no!");
    println!("My data: {:?}", data); // Unreachable
}
----

In a typical usage of Rust, the panic usually means that your program writes
some message to stdout and then ends. This is because unwinding is propagated
and it may end up aborting the program if it's not stopped. But that's exacty
what `catch_unwind` is for:

[source, rust]
----
let result = panic::catch_unwind(|| {
    let data = vec![1, 2, 3];
    panic!("oh no!");
    println!("My data: {:?}", data); // Unreachable
});

println!("Did it panic? {}", result.is_err()); // This will run just fine
----

Rust makes it very clear that `catch_unwind` is not intended for regular error
handling (you have `Result` for that). But in our case we are _forced_ to use it
in order to not invoke undefined behaviour when panicking through the FFI
boundary. Every single function in the FFI interface that has a possibility of
panicking should use `panic::catch_unwind`. And this is quite tricky because
even things like addition may cause a panic (overflow in debug mode).

=== `MayPanic<T>`

In order to make this somewhat more painless and safe, I created the
`MayPanic<T>` enum for my own plugin system, basically equivalent to
`Option<T>`:

[source, rust]
----
#[repr(C)]
#[derive(Debug, StableAbi)]
pub enum MayPanic<T> {
    Panic,
    NoPanic(T)
}
----

Panic errors should be treated differently from a regular error. Apart from the
fact that `panic::catch_unwind` returns a `Box<dyn Any>`, which is not
compatible with a `Box<dyn Error>` (so you can't just return `Result<T, Box<dyn
Error>` as usual), panics happen when the plugin reaches an unrecoverable state
and cannot continue.

Instead of using `RResult`, this is a different type that only returns the
original type if the function finished without panicking. Since the contents
returned by `catch_unwind` are just `dyn Any` and don't provide much value for
us, they're discarded. The panicking information will be printed automatically
as output anyway (or whatever is configured with
https://doc.rust-lang.org/std/panic/fn.set_hook.html[the panic hook]).

We will use it in FFI contexts, so it also implements `StableAbi` and it's
{repr-c}.

Ideally, this would be accompanied with a `\#[may_panic]` procedural macro that
adds the `MayPanic<T>` return type automatically and the `catch_unwind` to the
function it's attached to. Additionally, it could come with a `#[may_not_panic]`
proc macro as well that attaches the `\#[no_panic]` macro from the {{< crate
no-panic >}} crate to make sure the statement is true at compile time. However,
`no-panic` isn't too reliable, so perhaps it could be opt-in with something like
`#[may_not_panic(enforce)]`.

With macros like these we could make this task a bit easier for the plugin
developers so that they don't mess it up or straight up ignore it. If I end up
writing a crate for it, I will make sure ???

=== Exception safety

Something that complicates the macro I proposed considerably is the concept of
_exception safety_. `catch_unwind` isn't as easy to use as slapping your code
into its closure/function, as there are some types that aren't considered unwind
safe.

[source, rust]
----
let mut x = 7;

let result = panic::catch_unwind(|| {
    *x += 3;
});
----

[source, rust]
----
let mut x = 7;

let result = panic::catch_unwind(AssertUnwindSafe(|| {
    x += 3;
}));
----

[source, rust]
----
let mut x = 7;

let result = {
    let x = AssertUnwindSafe(&mut x);
    panic::catch_unwind(move || {
        *x += 3;
    })
}
----

=== Recovering from panics on the plugins

* Just unwrapping on the runtime
* Recovering

=== Functions that don't panic

* They either panic, or are constant. Don't try to export functions that are
  forbidden to panic because they will, in fact, panic.

=== What if we need performance?

* Setting panics to just abort in `Cargo.toml` -> no debug information though.
* Setting a panic hook that logs and then aborts on the plugin-side -> is it
  safe though?
* Run some benchmarks, perhaps add reference to the end

== Type conversions to `abi_stable`

It's important to know the complexity of conversions from/to `abi_stable` types.
If `std::Vec` -> `abi_stable::RVec` wasn't stem:[O(n)] it might be worth using
only the latter throughout the entirety of Tremor.

This means that I should spend at least a bit of my time on understanding how
the `abi_stable` types are implemented and making sure this isn't the case. In
`std`, the definition of `Vec` is actually quite simple if we remove most of the
noise:

[source, rust]
----
// A non-null pointer to `T` that indicates ownership.
pub struct Unique<T: ?Sized> {
    pointer: *const T, // The data itself
    _marker: PhantomData<T>, // Indicating that we own a `T`
}

// Low level type related to allocation
pub struct RawVec<T> {
    ptr: Unique<T>,
    cap: usize,
}

pub struct Vec<T> {
    buf: RawVec<T>,
    len: usize,
}
----

It's mostly self-explanatory; a `Vec<T>` is a pointer to `T` with a set capacity
and length. What about ``abi_stable``'s implementation?

[source, rust]
----
#[repr(C)] // Notice this, so that it's FFI-safe
#[derive(StableAbi)] // This trait marks `RVec` as FFI-safe, with info about its layout
pub struct RVec<T> {
    pub(super) buffer: *mut T,
    pub(super) length: usize,
    capacity: usize,
    vtable: VecVTable_Ref<T>,
    _marker: PhantomData<T>,
}
----

Yup, basically the same, but packed inside a single struct. The only real
difference is that we have a field with the vtable, which I'll cover later on.
The conversion between these types is written with a macro, but if expanded, it
looks like this:

[source, rust]
----
impl<T> From<Vec<T>> for RVec<T> {
    fn from(this: Vec<T>) -> RVec<T> {
        let mut this = std::mem::ManuallyDrop::new(this);
        RVec {
            vtable: VTableGetter::<T>::LIB_VTABLE,
            buffer: this.as_mut_ptr(),
            length: this.len(),
            capacity: this.capacity(),
            _marker: PhantomData,
        }
    }
}
----

The only "`weird`" part is the usage of `std::mem::ManuallyDrop`, which simply
is a wrapper that indicates Rust to not call the destructor of its contents
automatically. In this case it's basically a less error prone
`std::mem::forget`, as
https://doc.rust-lang.org/stable/std/mem/fn.forget.html#relationship-with-manuallydrop[its
docs explain]. Thanks to it, the memory from the vector won't be dropped when
this function ends, and it can be safely moved into the `RVec`, with no copying.

This happens for every type I checked in `abi_stable`, including `RSlice<T>`,
which contains a reference to a slice, `RStr`, which is just a `RSlice<u8>`, and
`RString`, which is just a `RVec`.

== Performance

As I talked about in previous posts, I've been wanting to create some benchmarks
to measure the performance impact the PDK will have. I first tried to write
these benchmarks with
https://doc.rust-lang.org/nightly/cargo/commands/cargo-bench.html?highlight=feature[cargo
nightly's implementation]. However, since it's so basic, not updated regularly,
and requires nightly, I moved to {{< crate criterion >}}, which I quite liked
after using it for https://nullderef.com/blog/web-api-client/[another post].

First, we can take a look at already implemented plugin systems in order to have
an idea of the performance hit we'll experience in Tremor. This is what we
should expect once out PDK is polished and ready for deployment:

* nginx reports 20% slower startup times and up to a 5% slowdown in execution
  time <<nginx-perf>>. 
* https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html[This
  article] explains that the only performance difference is saving the
  https://en.wikipedia.org/wiki/Position-independent_code[resolved address] of
  the symbol in a table the first time, and then it's just a couple more
  instructions to access it. Also, obviously the fact that the compiler can't
  optimize parts of the code (e.g. inlining function calls).

These are the results of the benchmarks I wrote:

[source, text]
----
dynamic setup           time:   [6.8134 us 6.8284 us 6.8448 us]
Found 7 outliers among 100 measurements (7.00%)
  1 (1.00%) low mild
  3 (3.00%) high mild
  3 (3.00%) high severe

abi_stable setup        time:   [36.056 ns 36.134 ns 36.210 ns]
Found 3 outliers among 100 measurements (3.00%)
  1 (1.00%) low mild
  1 (1.00%) high mild
  1 (1.00%) high severe

dynamic runtime         time:   [1.8568 ns 1.8601 ns 1.8635 ns]
Found 6 outliers among 100 measurements (6.00%)
  4 (4.00%) high mild
  2 (2.00%) high severe

abi_stable runtime      time:   [2.1087 ns 2.1138 ns 2.1203 ns]
Found 4 outliers among 100 measurements (4.00%)
  1 (1.00%) high mild
  3 (3.00%) high severe

native runtime          time:   [817.08 ps 819.60 ps 822.79 ps]
Found 5 outliers among 100 measurements (5.00%)
  2 (2.00%) high mild
  3 (3.00%) high severe
----

Note that the benchmarks don't represent a real usage of Tremor; it's just using
the initial plugin with the `min` function. But we _can_ analyze other things,
such as the performance differences between `abi_stable` and raw dynamic loading
-- I doubt it's worth implementing the final version with both methods in order
to run some benchmarks. And even if the results aren't too meaningful I already
have something I can use for the more-reliable future benchmarks.

The loading times don't matter much in our case because they only happen once at
the beginning of the program. Still, it's clear that ``abi_stable``'s way of
recursively checking the types in the plugins is not free; the difference with
raw dynamic loading is huge. -> FALSE!! turns out `abi_stable` caches the
library (somehow??) with `LateStaticRef`, so it's actually faster. I was able to
prove that the `Library::new` function is only called once in the entire
benchmark.

Once the dynamic library is loaded, the difference shouldn't be that noticeable.
Using types like `Dyn` instead of a `void*` introduce an overhead of about 13%
in execution time. But it's much worse if we compare it to not using dynamic
loading at all: a performance degradation of 127%, or 157% with `abi_stable`.

The problem with the native benchmark was, and most likely still is, that the
Rust compiler is too smart. If I called `min` with fixed parameters (say,
`10.min(3)`, it was optimized away, so I had to write a more complicated example
that was different for each loop.

You can find the full statistical reports in the `criterion-reports` directory
of the https://github.com/marioortizmanero/pdk-experiments/[repository].

== Thread safety

`abi_stable` uses `libloading`, whose error-handling is not fully thread-safe on
some platforms, such as `dlerror` on FreeBSD <<libloading-th>> <<dlerror-th>>.
It's fully thread-safe on Linux <<linux-th>>, macOS <<macos-th>>, and Windows
<<windows-th>>, so for Tremor specifically we don't have to worry about this.
But if your programs supports other Operating Systems, you might want to check
their manuals one by one in order to make sure.

However, for the first version of our PDK this won't be a problem at all. For
simplicity's sake, loading plugins after the startup will not be implemented
yet, and we'll do it sequentially. But it's good to know it for the future.

== Current Limitations

=== External/Complex types

If your codebase is large enough, you'll eventually find out that there are
types in the standard library that don't have an alternative in `abi_stable`:

____
Non-trivial `StableAbi` implementations in Tremor:

* Connectors:
** Sources:
*** `serde_yaml::Value` in `SourceReply`
*** `Pin` in `EventPayload` (in `SourceReply` and by itself)
*** `tremor_value::Value` in `ValueAndMeta` in `EventPayload`
** Sinks:
*** `Pin` in `EventPayload` (in `Event` and by itself)
*** `tremor_value::Value` in `ValueAndMeta` in `EventPayload` (in `Event` and by
    itself)
*** `simd_json::Value` in `OpMeta` in `Event`
*** `serde_yaml::Value` in `ConfigMap` in `config::Codec` in `EventSerializer`
* Codecs:
** `tremor_value::Value` for encoding and decoding
* Preprocessors: none! The interface only needs basic types.
* Postprocessors: same as preprocessors. These two seem trivial to implement
  (_famous last words before death_)

Final unique list:

* `Pin` -> it's only a hint so we can avoid it
* `value_trait::StaticNode` -> hard but fixable {{< gh pr TODO "simd-lite/value-trait" "TODO" >}}
* `serde_yaml::Value` -> it's avoidable

Thoughts:

* There is only an `RHashMap` in `abi_stable`, no `RBTreeMap`, so we'll have to
  use it instead if it's OK. Not sure if trees are used for performance or
  they're just an inconsistency and don't matter much for maps.
* Can we avoid `EventSerializer` in the sinks or make it an opaque type instead?
* How can we modify an external crate such as `value_trait::StaticNode` so that
  it implements `StableAbi`?

////
TODO: The JSON codec actually exports both `json` and `json-sorted`: how could
we do that with plugins? Definitely doable but needs some thinking.
////

We would be _**very**_ dependant on `abi_stable`; Tremor should definitely help
maintain it or provide resources so that it doesn't get obsolete. It's a huge
crate that's currently maintained by a single person,
https://github.com/rodrimati1992[@rodrimati1992], so it's quite the risk.

Required contributions to upstream packages:

* https://github.com/rodrimati1992/abi_stable_crates/pull/58
* https://github.com/rodrimati1992/abi_stable_crates/pull/61
* https://github.com/simd-lite/value-trait/pull/14
____

Adding wrappers to each of these individual types has a complexity so large that
makes this task practically impossible for Tremor. For reference, the
https://github.com/rodrimati1992/abi_stable_crates/blob/f7136dbc3d00fa7e97eddd36c06368ce524eeb8f/abi_stable/src/external_types/serde_json.rs[current
wrapper for `serde_json`] (the simplest one) is 597 lines of untested code.
Others such as `crossbeam` are over 1500 lines.

:rmutex: https://github.com/rodrimati1992/abi_stable_crates/blob/f7136dbc3d00fa7e97eddd36c06368ce524eeb8f/abi_stable/src/external_types/parking_lot/mutex.rs#L77
:opaque-mutex: https://github.com/rodrimati1992/abi_stable_crates/blob/f7136dbc3d00fa7e97eddd36c06368ce524eeb8f/abi_stable/src/external_types/parking_lot/mutex.rs#L29
:vtable: https://github.com/rodrimati1992/abi_stable_crates/blob/f7136dbc3d00fa7e97eddd36c06368ce524eeb8f/abi_stable/src/external_types/parking_lot/mutex.rs#L338
:wrapping: https://github.com/rodrimati1992/abi_stable_crates/blob/f7136dbc3d00fa7e97eddd36c06368ce524eeb8f/abi_stable/src/external_types/parking_lot/mutex.rs#L267

The good news are that creating a wrapper can be considered "`trivial`". All you
need to do is wrap the FFI-unsafe type under an opaque type, and create a
https://en.wikipedia.org/wiki/Virtual_method_table[vtable] that has access to
all of its methods. You can see this for example in the wrapper for
`crossbeam::Mutex<T>`: the {rmutex}[FFI-safe `RMutex` type] holds an
{opaque-mutex}[opaque mutex] and also a {vtable}[vtable] with all of its
available methods, which then are {wrapping}[wrapped for ease of use under the
`RMutex` type].

I'll try to use `cglue` for that exact problem and see how it works out.

TIP #1: try to minimize the usage of complex types. Try to make the plugin
interface as simple as possible, ans move as much as you can to the runtime.

abi_stable ends up being propagated throughout the entire codebase. This means
that the functionality is also affected, and it's very painful. Should I
continue, or is it better to perhaps write wrappers for the higher level types
instead?

NOTE: create wrapper over raw abi_stable stuff and convert back to std, or use
as it is?

////
//! This showcases how even with external and complex types not supported by
//! `abi_stable` by defalut, it's still possible to create a stable ABI.
//!
//! This is thanks to opaque types: instead of using the original type as we
//! normally would, we write its functionality as a trait and then use it with
//! `dyn`.

use abi_stable::{
    std_types::{RBox, ROption, RString},
    StableAbi,
};

/// Internal type with types that aren't wrapped by `abi_stable`
#[repr(C)]
#[derive(StableAbi)]
pub struct ConnectorContext {
    /// unique identifier
    pub uid: u64,
    /// url of the connector
    pub url: RString,
    /// type name of the connector
    pub type_name: RString,
    /// oh no! there's no `serde_yaml::Value` in `abi_stable`, so we can't just
    /// add `#[derive(StableAbi)]` to `ConnectorContext`!
    ///
    /// Solution: using its opaque alternative
    pub enabled: Value_TO<'static, RBox<()>>,
}

#[abi_stable::sabi_trait]
pub trait Value {
    fn as_bool(&self) -> ROption<bool>;
    fn as_i64(&self) -> ROption<i64>;
    fn as_null(&self) -> ROption<()>;
}

impl Value for serde_yaml::Value {
    fn as_bool(&self) -> ROption<bool> {
        self.as_bool().into()
    }

    fn as_i64(&self) -> ROption<i64> {
        self.as_i64().into()
    }

    fn as_null(&self) -> ROption<()> {
        self.as_null().into()
    }
}
////

=== Not having a `common` crate

So far I've been assuming the following structure for the plugin system:

* The plugin crates
* The runtime crate that excutes the plugins
* The `common` crate, with the interface shared between the plugin and the
  runtime

However, if you aren't starting from scratch, it's very likely that you don't
have a `common` crate. Instead, it might be just have a single binary crate with
both the runtime and the functionality in `common`.

Now, this isn't really a problem, since you can just have the plugins depend on
the runtime crate rather than `common`, and skip it altogether. But one of the
points of making this PDK is decreasing your compile times

=== Generics

////
In the connectors plugin interface there is a single `new` function that exports
a `Connector` dynamic trait from the plugin. The runtime can then use that as a
generic connector just like how Tremor does now. On the plugin-side, the
`create_{source,sink}` methods call `builder.spawn`, which relies on the fact
that the type implements `Source` or `Sink`. This spawns the new task and
communicates with the connector. As I said, this happens on the implementor
side, so the runtime doesn't know if the concrete type implements `Sink` or
`Source`, only that it's a `Connector`, and the plugin handles the rest itself.

However, since we wanted to simplify the plugin interface as much as possible,
the communication details should happen on the runtime rather than on the
plugin. What I mean is that, instead of calling `builder.spawn` on the plugin
and creating the channel on the plugin, it should happen on the runtime. Thus,
the whole idea of `create_{source,sink}` is now somewhat pointless, because it's
handled by the runtime. We have a `dyn Connector`, with which we can't know if
`Source` or `Sink` are implemented as well. We'd need `dyn (Connector + Source +
Sink)` for that, but `Source` and `Sink` are actually optional, so it depends on
the plugin anyway.

There are two ways to fix this:

* The `new` function returns a `dyn (Connector + Source + Sink)` instead and has
  fields to make sure `Source` or `Sink` are properly implemented. All of the
  connectors implement `Source` and `Sink` always, but we can make it optional
  by adding a marker or something like that.

  Spoiler: that won't work with just `abi_stable` anyway. Only with `cglue`,
  which makes it possible to have groups of traits. So it *would* be possible,
  but unnecessarily complicated and not an ideal solution anyway.

* The `create_{source,sink}` functions in the connector trait return a `dyn
  Source`. This way the interface for the connectors has to be very slightly
  changed, but it's actually possible to do this.
////

== Full implementation

Since it may be simpler to get `native-connector` running, let's start with
that. We'll just copy all the necessary code for the
https://github.com/tremor-rs/tremor-runtime/tree/883f13e29b4c6ec7b6703f2487aac321c738e7c8[current
implementation] of connectors as a standalone program:

== Conclusion

////
== Benchmarking

I've always wanted to run some benchmarks in order to find out the actual
difference in performance between dynamic loading (with native code) and Wasm
(with interpreted code). Of course, the former will be faster. But, is it
noticeable?

TODO compare with already existing benchmarks, what to expect, etc

Now that I have some examples of both dynamic loading and Wasm plugins, I can
make a few benchmarks in order to see the difference by myself. The `wasm-bench`
and `dynamic-bench` directories in
https://github.com/marioortizmanero/pdk-experiments[pdk-experiments] can be
compiled and then ran with
https://doc.rust-lang.org/1.7.0/book/benchmark-tests.html[Rust's integrated
benchmarking system] (which requires nightly for now)
////

[bibliography]
== References

- [[[nginx-perf,      1]]] http://httpd.apache.org/docs/2.4/dso.html#advantages
- [[[libloading-th,   2]]] https://docs.rs/libloading/0.7.1/libloading/struct.Library.html#thread-safety
- [[[dlerror-th,      3]]] https://pubs.opengroup.org/onlinepubs/009604499/functions/dlerror.html
- [[[linux-th,        4]]] https://man7.org/linux/man-pages/man3/dlerror.3.html#ATTRIBUTES
- [[[macos-th,        5]]] https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlerror.3.html
- [[[windows-th,      6]]] https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setthreaderrormode
- [[[unwinding,       7]]] https://doc.rust-lang.org/nomicon/unwinding.html
