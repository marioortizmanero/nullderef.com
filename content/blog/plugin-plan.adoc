---
title: "Research on plugins"
description: "TODO"
author: "Mario Ortiz Manero"
tags: ["rust", "gsoc"]
categories: ["project"]
date: 2021-04-13
draft: true
---

== Introduction

In this article I will futher analyze how a Plugin Development Kit could be
implemented in Rust with more investigation and other ideas I've found since
then, based on what I discussed in the original link:{{< ref
"gsoc-proposal.adoc" >}}[proposal] post

== Requirements

After showing the proposal to the Tremor team, I was given an important
suggestion: in this case there isn't really a need to be able to write plugins
from multiple programming languages; it's not worth the additional complexity.
It would definitely be interesting but with this I can focus on the main problem
I discovered in my proposal: the ABI instability.

Besides that, the rest of the main points to consider remain the same:

. *Mandatory:* Being able to load/unload the plugins both at start-time and at
  run-time.
. *Mandatory:* Cross-platform support
. *Mandatory:* Low overhead
. *Mandatory:* Available at least from Rust
. *Extra:* As little `unsafe` as possible
. *Extra:* Binary compatibility
. *Extra*: Not much work to port from the current implementations

== Safety Concerns

Remote Code Execution on the Tremor machine via a plugin -> sandboxing?

Memory Leaks

Unsafe Code

== Possible Approaches

The following are absolutely all the technologies that could be used as the base
of the PDK. Some of the won't match the requirements I mentioned earlier, but
it's a good idea to at least _consider_ all of them. I will rate each of the
options in a scale from 1 to 5 in order to take the final decision.

=== Scripting Languages

Plently of projects use scripting languages to extend their functionality at
runtime, like Python, Ruby, Perl, Bash or JavaScript. Some games for example use
http://www.lua.org/[Lua], a quite simple language with a very performant JIT
implementation, which in any case I think would be the best option. It could be
embedded into tremor and used to load plugins at either start-time or run-time.
And knowing it's used in games, which are _obsessed_ with performance, I don't
think this is that much of a big deal in that case.

There are libraries in Rust like https://github.com/amethyst/rlua[`rlua`] which
provide bindings for interoperability with Lua. This one in particular seems
quite easy to use, although currently semi-abandoned.

The deal breaker with scripting languages in this case is that it would be
extremely complicated to port everything in tremor so that it can be used from
Lua. For new projects this could perhaps be something interesting, but not if
the entirety of the already existing plugins have to be rewritten.

Still, it's a pretty interesting option for new projects, as you have ABI
stability guarantees, don't need unsafe code, and is very straightforward to
use.

. *Loading at start-time and run-time*:  5/5
. *Cross-platform support*: 5/5
. *Low overhead*: 4/5
. *Rust availability*: 4/5
. *No `unsafe` usage*: 5/5
. *Binary compatibility*: 5/5
. *Ease of porting current implementations*: 0/5

=== RPC

. *Loading at start-time and run-time*:  5/5
. *Cross-platform support*: 5/5
. *Low overhead*: 4/5
. *Rust availability*: 4/5
. *No `unsafe` usage*: 5/5
. *Binary compatibility*: 5/5
. *Ease of porting current implementations*: 0/5

=== FFI

https://docs.rs/libloading/[`libloading`]

https://github.com/emoon/dynamic_reload[`dynamic_reload`]

==== C

==== Rust

https://github.com/dtolnay/inventory[`inventory`]

https://github.com/rodrimati1992/abi_stable_crates[`abi_stable`]

- It only supports native dynamic libraries right now,since AFAIK extern "C" fn
  with arbitrary types is not supported in the WASM abi.
- It requires that you use some types from abi_stable instead of stdlib ones for
  the values you'll pass through ffi.
- It's still immature,lacking a Map<K,V> type for example,since I've had to
  reinvent the wheel for many Rust types.

=== Webassembly Interface

Now, this is what I wanted to emphasize in this article! Turns out Wasm isn't
limited to web development anymore; it's slowly evolving into a portable
binary-code format. This is how it's described in their official website:

[quote, https://webassembly.org/]
____
WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based
virtual machine. Wasm is designed as a portable compilation target for
programming languages, enabling deployment on the web for client and server
applications.
____

https://github.com/bytecodealliance/wasmtime/blob/main/docs/WASI-tutorial.md#from-rust[WASI]

https://freemasen.com/blog/wasmer-plugin-pt-1/[Wasmer Tutorial]

https://github.com/FreeMasen/wasmer-plugin/[`wasmer-plugin`]

== Prior Art

* https://github.com/zellij-org/zellij[`zellij`]
* https://github.com/xi-editor/xi-editor[`xi`] (JSON RPC)
* https://lib.rs/crates/plugin-system[`plugin-system`] (2019, obsolete)

[bibliography]
== References

- [[[michael,1]]] https://adventures.michaelfbryan.com/posts/plugins-in-rust/
- [[[fasterthanlime,2]]] https://fasterthanli.me/articles/so-you-want-to-live-reload-rust
