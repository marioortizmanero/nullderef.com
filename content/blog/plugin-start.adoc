---
title: "Plugins in Rust: Getting Started"
description: "My first steps trying to implement the PDK"
summary: "Getting to know the Tremor team was exciting. Implementing the PDK
wasn't going to be easy, but it certainly sounded fun thanks to their dynamics.
I had to start somewhere, and this was the moment."
author: "Mario Ortiz Manero"
tags: ["journal"]
series: ["rust-plugins"]
date: 2021-08-06
GHissueID: ??
---

:sectnums:

== Introduction

Welcome to my second article about Plugins in Rust! Here I will try to actually
write some simple code of what a PDK would look like, and also do some research
about questions that arise while doing so. Please note that this is a series of
posts, so you might be interested in reading
https://nullderef.com/series/rust-plugins/[the previous ones for context].

Some probably weren't expecting me to continue the series, as in the
https://nullderef.com/blog/plugin-tech/[last article] I wrote that Google didn't
end up allocating a slot for my project (as this was initially going to be for
the https://summerofcode.withgoogle.com/[Google Summer of Code]). But the Tremor
team ended up talking with me and arranging the same thing via the
https://lfx.linuxfoundation.org/tools/mentorship/[The Linux Foundation
Mentorships], so I will be able to work on the PDK in the end!

Even though this project is specific to Tremor, I try to keep it relatively
generic so that it's useful to future rustaceans interested in plugins. If you
don't really care about Tremor's specific case, you can skip to the
<<actual_start,next section>>.

== About Tremor

=== Getting to know the team

My first official meeting with the Tremor team took place in the beginnings of
August. I had already been lurking in their Discord server before, and I'd
talked with them a few times, so I more or less knew what to expect. But I was
still surprised by their welcomingness and how refreshing their dynamics were.

Starting to work on Tremor for the first time with such a large task at first
sounds daunting. I was somewhat overwhelmed by that and felt quite some pressure
on me. But their words helped me de-stress about it; finishing the PDK would of
course be hard, but no need to worry about things you can't control yet.

I particularly liked the three "`rules`" of their workflow:

* Have fun
* Take good notes
* Don't worry

Matthias, Darach and Heinz seemed like very different kinds of people; something
they knew and took advantage of. Decision-taking is hard; it requires good
communication and an open mind. I also took note of this quote (roughly) from
them:

[quote, Darach]
____
When I have an idea about something, I just post it on the Discord server and
wait for it to be destroyed by someone else. If it doesn't, maybe it's worth
considering.
____

Also note that while writing this post I quite literally broke my leg (tibia &
fibula). The team was very supportive and I took some rest until I went through
surgery (I'm still recovering). Which is another reason as to why this article
has taken me longer than usual to release. Thanks a lot to all of them ❤️.

=== Getting to know other mentees

In the first reunion I was suggested to meet the other LFX mentee at that
moment, @aryan9600 on Discord, which seemed like a good idea. I'd seen him a
couple times and knew he'd been contributing to Tremor even before the
mentorship.

Aryan turned out to be a very nice colleague! He was very enthusiastic about the
project and he explained me his progress in detail. In summary, he was starting
to add gRPC support to Tremor, and wasn't sure how to approach it so that new
interfaces could be added outside the compilation time. He had multiple ideas on
how to implement this, but the one that interested me the most was via Wasm or
dynamic linking, which was exactly what I was trying to do as well for the PDK.
This meant I'd probably spend more time with him, as our projects were more
interconnected than I thought.

=== Learning about the internals of Tremor

I've always known that the original intent for the PDK was the typical
architecture via dynamic linking, but I wanted to explore the viability of Wasm
or other alternatives before ruling it out. Would this idea be destroyed by
someone in the end, or does it stand a chance? In order to know that I'd first
need to find more specific requisites by defining the basic interfaces of the
PDK. Which is very hard at first because you need to know more about the
internals of Tremor and how it works.

Luckily, Matthias spent the second meeting explaining me how Tremor works, with
the help of some drawings, taking a look at the code, and running it. He also
taught me the novel concept of a _connector_, which is just an abstraction over
both sources and sinks. The thing was that connectors were still Work In
Progress, and Matthias needed to know how the PDK would work to modify the
`Connector` interface -- mainly how to approach a plugin interface with
generics. Which is what I'll try to figure out in this article.

Back when I talked to Aryan we ended up asking ourselves the same exact things.
Turns out that the generated code with `tonic` for gRPC uses generics, which
might not be compatible with dynamic loading.

[[actual_start]]
== The first steps

Up until now I had mostly investigated about the
https://nullderef.com/blog/plugin-tech/[technologies] that could be used for the
PDK, but I was suggested that I should first take a look at how the interfaces
would actually look like. That way it would be easier to take the final decision
for the PDK's technology, according to the requirements for these interfaces. In
summary, the following questions arose:

* Is it possible to use generics in the PDK?
* Otherwise, is it possible to use `dyn` in the PDK?
* If all else fails, what can be done to represent a "`generic`" trait object in
  the interface Tremor exports for plugins?

This meant I had to do more research. I spent a few days reading multiple
articles, but it's a rabbit hole 🐰! I would recommend the following ones:

// TODO add wasm articles?

* https://fasterthanli.me/articles/so-you-want-to-live-reload-rust[So you want
  to live-reload Rust - fasterthanli.me]
* https://adventures.michaelfbryan.com/posts/wasm-as-a-platform-for-abstraction/[WebAssembly
  as a Platform for Abstraction - adventures.michaelfbryan.com], recommended to
  me by Aryan
* https://adventures.michaelfbryan.com/posts/ffi-safe-polymorphism-in-rust/[FFI-Safe
  Polymorphism: Thin Trait Objects - adventures.michaelfbryan.com]
* https://adventures.michaelfbryan.com/posts/plugins-in-rust/[Plugins in Rust -
  adventures.michaelfbryan.com]
* https://michael-f-bryan.github.io/rust-ffi-guide/dynamic_loading.html[Dynamic
  Loading & Plugins - michael-f-bryan.github.io]

As you can see, Michael F. Bryan has put a lot of effort into teaching how
dynamic loading works in Rust. Thanks a lot to him!

== Experimenting with plugins

=== Dynamic Loading

First of all, I've created the
https://github.com/marioortizmanero/pdk-experiments[pdk-experiments] repository,
where I'll write various examples of how the PDK might work. The first
experiment is in the
https://github.com/marioortizmanero/pdk-experiments/tree/master/dynamic-simple[`dynamic-simple`
directory], with a small example of how to dynamically load plugins with Rust.

==== ABI unstability, it's much worse than it seems

I had this very late realization about ABI stability in Rust. Up until this
point I thought that even though Rust's ABI is _unstable_, one could dynamically
load a library safely as long as both the library and the main binary were
compiled with the same exact compiler/`std`/etc version. This is exactly what
other authors explain in their blog posts, like X or Y.

But turns out that the ABI may not only break between compiler versions, but
also _compiler runs_. Rust doesn't guarantee that a layout is going to be the
same in different compilation runs. This is proved by
https://github.com/rust-lang/compiler-team/issues/457[rust-lang/compiler-team#457],
the new unstable `-Z randomize-layout` flag. It's pretty much self-explanatory:
it randomly reorders `repr(rust)` layouts. The same thing could happen in the
future without an explicit flag; an optimization may cause the `repr(rust)`
layouts to be non-deterministic.

Props to the devs at the `#black-magic` channel in Rust's discord server, who
helped me understand this, specially Yandros and Kixiron.

////
TODO: talk about breakthrough on ABI instability
https://github.com/rust-lang/rust/pull/87868
https://github.com/rust-lang/compiler-team/issues/457


Well, rather, why is dylib even a thing?

Yandros ꜰʀ-ᴇꜱ — Today at 9:44 PM
Good question, I believe that dylib is a vestigial / historical artifact, and their main author, alexchriton even mentioned somewhere their wish to remove it or at least a regret of having featured it
////

==== Example

We first need a common library, called `common`, which defines the interface
exported by the plugin so that the main binary may load it. In this case it's
just a pointer to a function. To keep it simple it'll just compute the minimum
between two integers:

.`common/src/lib.rs`
[source, rust]
----
pub type MinFunction = fn(i32, i32) -> i32;
----

With it, the plugin crate may export its own implementation. In this case I'll
declare a `static` variable, but the example showcases how `extern` may work as
well (which will end up being the better choice). The crate's value of
`crate-type` must be set to a
https://doc.rust-lang.org/reference/linkage.html[dynamic library], which we'll
cover later. Note that `#[no_mangle]` is necessary so that the variable's name
isn't https://en.wikipedia.org/wiki/Name_mangling[_mangled_] and we can access
it when when dynamically loading the library.

.`plugin-sample/src/lib.rs`
[source, rust]
----
#[no_mangle]
pub static plugin_function: MinFunction = min;

fn min(a: i32, b: i32) -> i32 {
    a.min(b)
}
----

Finally, the main binary can load the library with {{< crate libloading >}},
which requires a bit of `unsafe`. I was looking forward to using a different
library because of how easy it seems to end up with undefined behaviour in that
case. I found out {{< crate sharedlib >}} was abandoned, as no commits had been
made since 2017, leaving {{< crate dlopen >}} as the only alternative. Which was
updated two years ago as well, but their GitHub repo seemed somewhat active in
comparison.

For now I'll just use `libloading` for being the most popular crate, and perhaps
I'll consider using `dlopen` in the future. In terms of relevant features and
performance they're pretty close anyway <<dynload-comp>>. Here's what the code
looks like:

.`src/main.rs`
[source, rust]
----
fn run_plugin(path: &str) -> Result<(), libloading::Error> {
    unsafe {
        let library = Library::new(path)?;
        let min = library.get::<*mut MinFunction>(b"plugin_function\0")?.read();
        println!("Running plugin:");
        println!("  min(1, 2): {}", min(1, 2));
        println!("  min(-10, 10): {}", min(-10, 10));
        println!("  min(2000, 2000): {}", min(2000, 2000));
    }

    Ok(())
}
----

Running it:

[source, commandline]
----
$ cd plugin-sample
$ cargo build --release
$ cd ..
$ cargo run --release -- plugin-sample/target/release/libplugin_sample.so
Running plugin:
  min(1, 2): 1
  min(-10, 10): -10
  min(2000, 2000): 2000
----

Cool! This raises a few questions that I should learn more about:

. Many plugin tutorials use `extern "C"` for the exported function's type in the
  plugin. What exactly does that mean? Do we need it if the FFI is Rust-to-Rust?
  Would https://doc.rust-lang.org/std/keyword.extern.html[`extern "Rust"`] work
  any better?
. There are many different options to configure `crate-type` as a
  https://doc.rust-lang.org/reference/linkage.html[dynamic library]. What are
  they and which one should I choose?
. I faintly remember that `rlib` files are Rust-only objects with additional
  metadata for things like generics. Could that possibly work at runtime? As in,
  is there an equivalent to
  https://en.wikipedia.org/wiki/Component_Object_Model[COM] in Rust, or maybe
  like JAR files in Java?

==== 1. `extern` values

The `extern` keyword can be used to either declare function interfaces that Rust
code can call foreign code by, or to export Rust code <<extern>>. Its parameter
specifies what ABI it should use, of which the only interesting values in this
case are:

* `extern "Rust"`: for the Rust ABI
* `extern "C"`: for the default C compiler's ABI in your system

Though most tutorials use `export "C"`, `export "Rust"` is the best choice for
Rust-to-Rust FFI because with it one can easily export Rust-only features like
enums with data fields (at the cost of not being a stable ABI). Otherwise, we'd
get this message when compiling the library:

[source, text]
----
warning: `extern` fn uses type `EnumWithDataFields`, which is not FFI-safe
  --> src/lib.rs:24:50
   |
24 | pub extern "C" fn with_extern(a: i32, b: i32) -> EnumWithDataFields {
   |                                                  ^^^^^^^^^^^^^^^^^^ not FFI-safe
   |
   = note: `#[warn(improper_ctypes_definitions)]` on by default
   = help: consider adding a `#[repr(C)]`, `#[repr(transparent)]`, or integer `#[repr(...)]` attribute to this enum
   = note: enum has no representation hint
note: the type is defined here
  --> src/lib.rs:3:1
   |
3  | / pub enum EnumWithDataFields {
4  | |     A,
5  | |     B(i32),
6  | |     C
7  | | }
   | |_^
----

Note that the default value for the ABI is `"C"`, so `"Rust"` must be explicitly
specified always when using `extern`.

==== 2. `crate-type` values

There are https://doc.rust-lang.org/reference/linkage.html[two ways to configure
dynamic linking with the `crate-type` field] in the crate's `Cargo.toml`:

* `dylib`
* `cdylib`

Once again, this difference has to do with the ABIs in the dynamic library
<<dylib>>. `cdylib` is meant for linking into C/C++ programs, and `dylib` for
Rust ones. More specifically, `cdylib` will strip away all functions that aren't
publicly exported. `dylib` means that `extern` isn't even needed; you just need
to set the external items as `pub`.

==== 3. `rlib` files

Also listed in the previous section, `rlib` is a value for `crate-type` that
might be of interest. `rlib` files are Rust *static* libraries, which can then
be imported with `extern crate crate_name` <<dylib>>. But since `rlib` files are
static libraries, they can't be loaded at runtime, so they're of no use in a
plugin system.

Here's a crazy idea though: What if the `rlib` files were dynamically loaded as
plugins with the help of https://github.com/rust-lang/miri[MIRI]? I recently
learned about it, and quoting its official documentation:

[quote]
____
[MIRI is] an experimental interpreter for Rust's mid-level intermediate
representation (MIR). It can run binaries and test suites of cargo projects and
detect certain classes of undefined behavior.

#You can use Miri to emulate programs on other targets#, e.g. to ensure that
byte-level data manipulation works correctly both on little-endian and
big-endian systems.
____

Hmm. Could it possibly be used to interpret Rust code? In some way this would be
very similar to using WebAssembly, but theoretically with less friction, as MIR
is specific to Rust and plugin development would be as easy as in the case of
dynamic loading with Rust-to-Rust FFI. A few things to consider:

. *Is this even possible?*
+
The Rust compiler itself uses MIRI to evaluate constant expressions
<<miri-compiler>> via the
https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/index.html[`rustc_mir`
crate]. But taking a quick look it seems to be created specifically for the
compiler, at a very low level, and without that much documentation. Plus, it's
nightly-only. It does seem possible, but I wasn't able to get a simple example
working.
. *Is MIR stable?*
+
MIR is unfortunately unstable <<miri-unstable>>, so we'd have the same
incompatibility problems between plugins and the main binary.
. *Is the overhead of MIRI worth it?*
+
Considering the previous answers, no, this approach doesn't seem like the right
tool for the job.

=== WebAssembly

I also tried to write a simple example of how plugins would work with
WebAssembly, which is available in the
https://github.com/marioortizmanero/pdk-experiments/tree/master/wasmer-simple[`wasmer-simple`
directory]. It took me considerably more effort to understand and get running
than with dynamic linking, even following
https://freemasen.com/blog/wasmer-plugin-pt-1/[Free Masen's guide] and
https://docs.rs/wasmer[Wasmer's official documentation]. But at least I didn't
have to write that much `unsafe` (I still needed some to load or store data from
Wasm's virtual memory, which I'll explain later on).

The following snippet is what the plugin would look like. Note that this time we
use `pub` without even considering `static` to export a pointer to the function.
Wasm does have support for globals, but since handling complex types -- a
function in this case -- isn't trivial, it's not worth it.

.`plugin-sample/src/lib.rs`
[source, rust]
----
#[no_mangle]
pub fn with_extern(a: i32, b: i32) -> i32 {
    a.min(b)
}
----


For the runtime, this time I'm using Wasmer instead of Wasmtime because in an
https://nullderef.com/blog/plugin-tech/[earlier post] it seemed like the best
alternative. I also wanted to try
{{< crate wasmer-plugin >}}, which includes
procedural macros to help reduce the overall boilerplate (which will be more
important later on), but it seems to be abandoned since 2019. I wanted to try
the lower-level interface of Wasmer myself to learn more about it anyway, so
I'll just use that for now. If we ended up using Wasm for Tremor I'd try
updating and maintaining `wasmer-plugin` to keep the code boilerplate-free.

.`src/main.rs`
[source, rust]
----
fn run_plugin(path: &str) -> Result<(), WasmerError> {
    // For reference, Feather also reads the plugins with `fs::read`:
    // https://github.com/feather-rs/feather/blob/07c64678f80ff77be3dbd3d99fbe5558b4e72c97/quill/cargo-quill/src/main.rs#L107
    let module_wat = fs::read(&path)?;
    let store = Store::default();
    let module = Module::new(&store, &module_wat)?;
    // No imports needed; the object will be empty for now
    let import_object = imports! {};
    let instance = Instance::new(&module, &import_object)?;

    println!("Running plugin:");
    let min_extern: NativeFunc<(i32, i32), i32> = instance.exports.get_native_function("with_extern")?;
    println!("  min(1, 2): {}", min_extern.call(1, 2)?);
    println!("  min(-10, 10): {}", min_extern.call(-10, 10)?);
    println!("  min(2000, 2000): {}", min_extern.call(2000, 2000)?);

    Ok(())
}
----

Running it:

[source, text]
----
$ rustup target add wasm32-wasi
$ cd plugin-simple
$ cargo build --target wasm32-wasi --release
$ cd ..
$ cargo run --release -- plugin-sample/target/wasm32-wasi/release/plugin_sample.wasm
Running plugin:
  min(1, 2): 1
  min(-10, 10): -10
  min(2000, 2000): 2000
----

I created a `Makefile` for this example so that it's easier to compile, though.
Running `make debug` or `make release` should do the trick. Some new questions
about WebAssembly:

// TODO: wasmer vs wasmtime?

* AFAIK there are multiple compilation targets for Wasm. Which one should I be
  using?
* What's the difference between the https://docs.rs/wasmer/[`wasmer`] crate and
  https://docs.rs/wasmer-runtime/[`wasmer_runtime`]?
* What about exporting types more complex than an `i32`? Is it possible to
  export a struct that implements a specific trait?

==== WebAssembly targets

Wasmer docs don't mention this much because is related to the plugin, rather
than the runtime. But Wasmtime's book does include a section about compiling
Rust to WebAssembly:

[quote, https://docs.wasmtime.dev/wasm-rust.html]
____
* `wasm32-wasi` - when using wasmtime this is likely what you'll be using. The
  WASI target is integrated into the standard library and is intended on
  producing standalone binaries.
* `wasm32-unknown-unknown` - this target, like the WASI one, is focused on
  producing single *.wasm binaries. The standard library, however, is largely
  stubbed out since the "unknown" part of the target means libstd can't assume
  anything. This means that while binaries will likely work in wasmtime, common
  conveniences like println! or panic! won't work.
* `wasm32-unknown-emscripten` - this target is intended to work in a web browser
  and produces a *.wasm file coupled with a *.js file, and it is not compatible
  with wasmtime.
____

So basically what we need is `wasm32-wasi`. Even though Wasmer was my initial
choice, to be honest I found Wasmtime's docs to be much more detailed and
well-organized.

==== `wasmer` vs `wasmer_runtime`

This was confusing for me at first, since both crates seem to have a very
similar interface and almost the same set of authors. Some tutorials used
`wasmer`, others `wasmer_runtime`.

The difference seems to be that `wasmer_runtime` was updated about a year ago,
while `wasmer` got bumped to v2.0.0 just two months ago. The last release of
`wasmer_runtime` is v0.17 (v0.18 seems to be yanked), and the first one of
`wasmer` is v0.17 as well, so my bet is that `wasmer_runtime` is the name of the
crate their team used previously, and they eventually deprecated it in favor of
`wasmer`.

I've opened an https://github.com/wasmerio/wasmer/issues/2539[issue] upstream so
that this is hopefully more clear to future users.

==== More complex types

Wasm only allows functions with parameters of basic types (integers and floating
point <<wasmer-types>>). There are currently two ways of handling this:

* Via the https://github.com/webassembly/interface-types[*Interface Types
  Proposal* for WebAssembly]. It defines the binary format for encoding and
  decoding the newly supported types, and specifies a set of instructions to
  transform the data between WebAssembly and the outside world. Note that it's
  not meant to define a fixed representation of e.g. a string in Wasm, it
  attempts to allow representation-agnostic high-level value types.
+
--
These new _high-level value types_ are called *interface types*. The current
proposal defines them as:

* Floating point of 32 and 64 bits
* Signed and unsigned integers of up to 64 bits
* Single characters
* Lists (a string would be a list of characters)
* Records (basically like Rust structs)
* Variants (basically like Rust enums, it would enable `Option`, `Result`,
  `union`, etc)

Additionally, language-neutral interfaces for WASI can be defined with the
experimental *`witx` files* <<witx>>, which makes it easy to define a common ABI
in order to interact from different programming languages <<witx-example>>
<<witx-guide>>. They look like this:

[source, lisp]
----
(use "errno.witx")

;;; Add two integers
(module $calculator
  (@interface func (export "add")
    (param $lh s32)
    (param $rh s32)
    (result $error $errno)
    (result $res s32)
  )
)
----

Please refer to the
https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md[proposal
itself] for more detailed information; it's very well explained.

However, this proposal is still at
https://github.com/WebAssembly/proposals#phase-1---feature-proposal-cg[Phase 1].
It's still actively being worked on and its specification is far from stable:

* At the plugin level the {{< crate wasm_bindgen >}} crate seems to be ideal.
  It's a very simple procedural macro that can be added to the exported
  functions in the plugin in order to automatically add support for Interface
  Types.
* Once the interface is defined, it can be loaded into Rust with a crate like
  https://docs.rs/wiggle/[`wiggle`]. For the previous example, wiggle's macro
  will generate a `Calculator` trait TODO
* Wasmtime did support this in the past until their implementation was removed
  after being considered outdated. As
  https://github.com/bytecodealliance/wasmtime/issues/677[this issue indicates],
  it still hasn't been updated.
* Wasmer has the
  https://docs.rs/wasmer-interface-types/[`wasmer_interface_types`] crate, but
  with a similar story; it's outdated. There's
  https://github.com/wasmerio/wasmer/issues/2480[this issue] as a continuation
  of Wasmtime's, which explains the situation.

In the end I wasn't able to get Interface Types working, nor I considered them
worth my time, as it's still too early.
--
* The hacky-but-working way, via *pointers and a shared
  https://docs.wasmer.io/integrations/examples/memory[memory]*. The user has to
  first construct and serialize the complex types, and then save them into
  Wasm's memory, which can be accessed directly by the runtime or the plugin
  with https://docs.wasmer.io/integrations/examples/memory-pointers[pointers].
+
--
Not only does this require a serialization and deserialization step, but also
it's very cumbersome to use and easy to mess up. It's somewhat trivial though,
so a procedural macro like the now outdated {{< crate wasmer-plugin >}} could
simplify it. For now, {{< crate bincode >}} can be used for the serialization
steps manually.

As to exporting structs that implement a specific trait, as long as the trait's
size is known, it should be possible to do so via pointers as well. I think...
--

== Generics

The traits I was trying to make plugin-compatible in Tremor had some instances
of generics. And they'd only get worse in the future with
https://github.com/rust-lang/rust/issues/44265[GATs] and `async` methods in
traits actually being generic (we currently use {{< crate async_trait >}}).

So, first of all let's cross this one out of the checklist. Can we use generics
in the plugins?

=== Why they are impossible

Well, no, generics in plugins are fundamentally impossible. In Rust,
monomorphization turns generic code into specific code by filling in the
concrete types that are used when *compiled* <<generics>>. Plugins are loaded at
runtime, so they may use types the compiler didn't generate code for.

It's really easy to prove in Rust with the following example. We'll try to
_load_ an external function with generics:

[source, rust]
----
extern "Rust" {
    fn foo<T>(_: T);
}
----

This results in the following error:

[source, text]
----
error[E0044]: foreign items may not have type parameters
 --> src/lib.rs:2:5
  |
2 |     fn foo<T>(_: T);
  |     ^^^^^^^^^^^^^^^^ can't have type parameters
  |
  = help: replace the type parameters with concrete types like `u32`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0044`.
----

Interestingly enough, the compiler lets you export generic functions declared
_in Rust_:

[source, rust]
----
extern fn foo<T>(_: T) {}
----

This confused me in the beginning; it made me think generic functions through
FFI would be possible. But as described in
https://github.com/rust-lang/rust/pull/15831[the original issue that allowed
them], they're only supported to pass callbacks to C functions.

Another interesting thing about generics in plugins is that it does work for
lifetimes. This will compile:

[source, rust]
----
extern "Rust" {
    fn foo<'a>(_: &'a str) -> &'a str;
}
----

That is mainly because even though lifetimes and generics share the same syntax,
in the case of lifetimes they are only annotations. No new versions of the
function are generated.

=== Alternatives

=== Dynamic Linking


=== WebAssembly

Can we somehow implement something similar with WebAssembly? The function
signature of the `wasmer-example` example only contains basic types supported by
Wasm: integers and floating points. Before even considering generics, how can we
use more complex types? Is it possible to write a function that takes or returns
a struct?

This is covered quite well in
https://freemasen.com/blog/wasmer-plugin-pt-1/[Free Masen's guide]. The author
is able to use more complex types by passing them inside.

TODO mention:

https://docs.rs/typetag/0.1.7/typetag/
https://docs.rs/serde_traitobject/0.2.7/serde_traitobject/

== Conclusion

TODO leave benchmarking for next week

== Benchmarking

I've always wanted to run some benchmarks in order to find out the actual
difference in performance between dynamic loading (with native code) and Wasm
(with interpreted code). Of course, the former will be faster. But, is it
noticeable?

TODO compare with already existing benchmarks, what to expect, etc

Now that I have some examples of both dynamic loading and Wasm plugins, I can
make a few benchmarks in order to see the difference by myself. The `wasm-bench`
and `dynamic-bench` directories in
https://github.com/marioortizmanero/pdk-experiments[pdk-experiments] can be
compiled and then ran with
https://doc.rust-lang.org/1.7.0/book/benchmark-tests.html[Rust's integrated
benchmarking system] (which requires nightly for now)

[bibliography]
== References

- [[[dynload-comp,    1]]] https://github.com/szymonwieloch/rust-dlopen#compare-with-other-libraries
- [[[extern,          2]]] https://doc.rust-lang.org/std/keyword.extern.html
- [[[dylib,           3]]] https://users.rust-lang.org/t/what-is-the-difference-between-dylib-and-cdylib/28847
- [[[miri-compiler,   4]]] https://rustc-dev-guide.rust-lang.org/miri.html
- [[[miri-unstable,   5]]] https://github.com/rust-lang/miri/blob/master/CONTRIBUTING.md#preparing-the-build-environment
- [[[wasmer-types,    6]]] https://docs.rs/wasmer-runtime-core/0.17.1/wasmer_runtime_core/types/trait.WasmExternType.html
- [[[wasmtime-inttyp, 7]]] https://github.com/bytecodealliance/wasmtime/issues/677
- [[[witx,            8]]] https://github.com/WebAssembly/WASI/blob/main/docs/witx.md
- [[[witx-guide,      9]]] https://radu-matei.com/blog/wasm-api-witx/
- [[[witx-example,   10]]] https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md#defining-language-neutral-interfaces-like-wasi-revisited
- [[[generics,       11]]] https://doc.rust-lang.org/book/ch10-01-syntax.html#performance-of-code-using-generics
