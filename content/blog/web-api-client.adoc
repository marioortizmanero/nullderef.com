---
title: "Designing a Web API Wrapper in Rust: New Rspotify Version a Year Later"
description: "Inspired by the Rspotify rewrite, a few tips on how to make a solid wrapper for most web APIs"
author: "Mario Ortiz Manero"
tags: ["rust", "open-source", "rspotify", "web-api"]
date: 2021-10-10
GHissueID: TODO
---

This article describes my journey of basically rewriting the entirety of
Rspotify; around 13 months of work (in my free time), starting at September of
2020, up until October of 2021. I think this has given me enough experience for
an article regarding API design on Rust, and hopefully it'll be useful for those
who attempt the same in the future. Specially considering how much I've gone in
circles and how much time I've "`wasted`" implementing things that ended up
being discarded.

// TODO: fact check
This is also going to be quite lengthy because I would like to give my reasoning
for every decision taken; every one of them isn't necessarily the most
appropiate one for your case, or you might just disagree. Most times there isn't
a perfect solution and you just have to pick whichever you consider is the best
one for your project's goals.

== The Story

If you don't care about Rspotify's specific story, you can jump to the
<<actual_start>> section, but I think knowing a bit the motives for this
rewrite is interesting for other open source maintainers in the same situation
as me. This all started when I wanted to use a Rust Spotify API wrapper for one
of my projects at that time, https://vidify.org/[Vidify]. I went to
https://crates.io/[crates.io] and looked for "Spotify", and all I found was
`rspotify`, the most popular one, `aspotify`, an asynchronous-only alternative,
and a bunch of other outdated or incomplete libraries.

The author of `aspotify` had made a brand new library from scratch, because as
he commented in its release, "`[rspotify's] API in general I found hard to use
and confusing`" <<aspotify-release>>. Depending on the state of the original
library this is the easiest choice because you don't have to worry about
backwards compatibility, old code, etc.

A year back I had also helped with the first steps of
https://github.com/felix-hilden/tekore[`tekore`], an alternative to
https://github.com/plamere/spotipy[`spotipy`], the most popular Spotify library
for Python out there. The problem was that back then Paul, spotipy's creator and
maintainer, was absent <<spotipy-absent>>, and the library really needed a push
to upgrade from Python 2 and improve the overall interface and
user-friendliness.

So Felix and a few more devs tried to start from scratch. Felix was the most
dedicated one and eventually got permissions from Paul to upload new spotipy
releases, meaning that he could rewrite the entire thing and upload it to PyPi
(Python's official third-party repositories) if he wanted to. The difference in
this case was that spotipy had a good amount of users at that point, and a
couple of them ended up stopping Felix from completely breaking backward
compatibility, so he made it into a brand new library instead and left the
maintainance tasks to the new devs in charge. Tekore still is, in my very biased
opinion and at the time of this writing, a much nicer to use library than
spotipy, but it has taken a lot of time to get a user base starting from
scratch, and it's still not as popular as spotipy by far.

Having gone through this, I also wanted to see if it would be possible to give
Rspotify a face wash without anyone complaining. Rspotify was still in beta --
version 0.10 -- so you can't expect to have a stable API, but that's far from a
full rewrite. At the very least I wanted to talk with Ramsay, the original
Rspotify developer, and see what his thoughts were. I proposed some big changes
like rewriting the `blocking` module <<gh-block-cleanup>> and @Kestrer wrote up
an issue with ~80 issues he had found when using the library <<gh-meta>>.

I think it's fair to release the new version 0.11 as such rather than as a new
library because of the following reasons:

* Ramsay, the author, also wanted to help.
* The fundamentals of the library would remain the same: being the most
  user-friendly feature-full library for the Spotify API.
* It was considered a necessary evil. In my opinion, the library was doomed
  without a big rewrite. Otherwise it'd eventually become really hard to maintain and work
  with. I admit that said breaking changes could've been
  smaller, but I thought that while I'm at it I might as well make it as close
  as possible to my perfect Rust interface.

Note that I am in no way associated with Spotify. I'm just a Computer Science
student whose sole goal was to use Rust for a non-trivial case, from start to
finish. I was somewhat experienced with the Spotify API, so I decided Rspotify
was a good choice.

Now that most of the stuff I talk about in this article is finished, you can
read about the changes in detail
https://github.com/ramsayleung/rspotify/blob/master/CHANGELOG.md[in the
CHANGELOG]. The following sections will talk about what I learned about API
Design, and some tips for those writing one in Rust.

[[actual_start]]
== Making the API HTTP-client agnostic

Rspotify is now HTTP-client agnostic, which means that it can work with
whichever HTTP library the user configures, with no considerable overhead. For
now, we support {{< crate ureq >}} and {{< crate reqwest >}} <<gh-clients>>. The
HTTP client can be either blocking (`ureq`) or asynchronous (`reqwest`), which
is the non-trivial part.

While it's fully implemented in the new version, it's the only part of the new
version that isn't finished yet and that's subject to change. This has to do
with the way we support both async and sync HTTP clients under the same trait.
In order to have a common interface for both kinds of programming, we use the
{{< crate maybe_async >}}, which lets us switch between them with a feature.

The trait used as a base for any HTTP client is implemented with async. That
way, if the `maybe_async/is_sync` feature is disabled, the trait and its
implementations remain the same, and if it's enabled, all the occurrences of
`async` and `.await` are removed. This works perfectly, but unfortunately breaks
a rule in Cargo's feature system: features must be strictly additive, and
``maybe_async``'s feature is a _toggle_ -- you can't have both a sync and an
async client at the same time.

Since we don't follow that rule, those who depend on Rspotify with both async
and async (directly or indirectly) won't be able to compile their project. I
won't get into much detail beacuse I'm writing an entire separate post dedicated
for this issue that I'll publish once this whole ordeal is fixed. We're keeping
track of it in https://github.com/ramsayleung/rspotify/issues/221[#221] for now,
for those who want to lean more.

For now, I'll just explain how it works for clients of the same type: either
synchronous or asynchronous. Since the usage for an HTTP client in an API is
often very basic, i.e. you only need to make requests and get the results, we
can cover its usage under a single interface. For example:

[source, rust]
----
pub trait HttpClient: Send + Default {
   type Error;

    fn get(
        &self,
        url: &str,
        headers: Option<&Headers>,
        payload: &Query,
    ) -> Result<String, Self::Error>;

    fn post(
        &self,
        url: &str,
        headers: Option<&Headers>,
        payload: &Value,
    ) -> Result<String, Self::Error>;
    
    // etc
}
----

Then, we can add an implementation for each of our supported clients:

[source, rust]
----
#[derive(Default, Debug, Clone)]
pub struct UreqClient {}

impl HttpClient for UreqClient {
    type Error = ureq::Transport;

    #[inline]
    fn get(
        &self,
        url: &str,
        headers: Option<&Headers>,
        payload: &Query,
    ) -> Result<String, Self::Error> {
        let request = ureq::get(url);
        let sender = |mut req: Request| {
            for (key, val) in payload.iter() {
                req = req.query(key, val)
            }
            req.call()
        };
        self.request(request, headers, sender) // Internal more complex handler
    }

    // etc
}
----

And we can finally make our client generic over its internal HTTP client:

[source, rust]
----
#[derive(Default, Debug, Clone)]
pub struct Spotify<Http: HttpClient> {
    http: Http,
    // etc
}

impl<Http: HttpClient> Spotify<Http> {
    pub fn endpoint(&self) -> String {
        let headers = todo!();
        let payload = todo!();
        self.http.get("/some/endpoint", headers, payload)
    }
}
----

While this additional complexity might be completely unnecessary for your own
API wrapper, this was definitely something interesting for Rspotify. Some crates
that already depend on us like https://github.com/hrkfdn/ncspot[`ncspot`] or
https://github.com/Spotifyd/spotifyd[`spotifyd`] are blocking, and others like
https://github.com/Rigellute/spotify-tui[`spotify-tui`] use async. I thought I
might as well try, and I've finally figured out how to make it work, even for
both async and sync.

We implement all of this in the crate
https://github.com/ramsayleung/rspotify/tree/master/rspotify-http[`rspotify-http`],
which I plan on https://github.com/ramsayleung/rspotify/issues/234[moving into a
separate crate] once it's working as I want it to. I think it's a pretty neat
feature for an API client that will hopefully become easier to implement with in
the future.

== Architecture based on authorization methods

Another interesting refactor I worked on for Rspotify was its architecture. The
Spotify API in particular has
https://developer.spotify.com/documentation/general/guides/authorization-guide/[multiple
authorization methods] that give you access to a different set of endpoints. For
example, if you're using _client credentials_ (the most basic one), then you
can't access an endpoint to modify the user's data. It used to work with the
https://doc.rust-lang.org/1.0.0/style/ownership/builders.html[_builder
pattern_], following this structure (though not exactly the same):

[source, rust]
----
// OAuth information
let oauth = SpotifyOAuth::default()
    .redirect_uri("http://localhost:8888/callback")
    .scope("user-modify-playback-state")
    .build()
    .unwrap();

// Basic information
let creds = SpotifyClientCredentials::default()
    .client_id("this-is-my-client-id")
    .client_secret("this-is-my-client-secret")
    .build()
    .unwrap();

// Obtaining the access token
let token = get_token(&mut oauth).unwrap();

// The client itself
let spotify = Spotify::default()
    .client_credentials_manager(creds)
    .token_info(token)
    .build()
    .unwrap();

// Performing a request
spotify.seek_track(25000, None).unwrap();
----

I wanted something more tailored towards our specific application. I think the
builder pattern is great, but it might become too verbose or confusing:

* Do we really need it for `Credentials`, which always takes the same two
  parameters?
* Which authorization method are we using above again? Currently it's possible
  to call `seek_track` after having followed an authorization process that
  doesn't give access to it. So what if we have a Spotify client for each
  authorization method?
* Wouldn't it be better have some type safety? The `unwrap` hurts my eyes.

After removing the builder pattern and being more explicit about the
authorization method that's being used, this is what we get:

[source, rust]
----
// OAuth information
let oauth = OAuth::new("http://localhost:8888/callback", "user-read-currently-playing");
// Basic information
let creds = Credentials::new("my-client-id", "my-client-secret");
// The client itself, now clearly with the "authorization code" method
let mut spotify = AuthCodeSpotify::new(creds, oauth);

// Obtaining the access token
let url = spotify.get_authorize_url(false).unwrap();
spotify.prompt_for_token(&url).await.unwrap();

// Performing a request
spotify.seek_track(25000, None).unwrap();
----

And if the user wants something more advanced, they can always write this:

[source, rust]
----
let oauth = OAuth {
    redirect_uri: "http://localhost:8888/callback",
    state: generate_random_string(16, alphabets::ALPHANUM),
    scopes: "user-read-currently-playing",
    ..Default::default()
};
----

Using the regular initialization pattern is more than enough for this case
because we don't even need validation. If we did, we could always just add a few
setters and we're done. Ask yourself: do you really need the builder pattern? In
this case we certainly didn't.

The most complicated part about this is having a client for each authorization
method, and making sure the user can only call those endpoints they have access
to. There are _many_ ways to approach this, I just had to decide which one was
the best. I gave this a lot of thought <<gh-auth>> <<reddit-auth>>.

Having multiple clients seems trivial with inheritance, with a base from which
they can extend. We could follow the typical "`composition over inheritance`"
principle, but we'd be repeating a ton of code, and it'd end up quite messy:

[source, rust]
----
pub struct EndpointsBase {
    http: Rc<Http> // Shared with the rest of the endpoints
}
impl EndpointsBase {
    pub fn endpoint1(&self) { self.http.put("/endpoint1") }
    pub fn endpoint2(&self) { self.http.get("/endpoint2") }
    // etc
}

pub struct EndpointsOAuth {
    token: Token,
    http: Rc<Http>
}
impl EndpointsOAuth {
    pub fn endpoint3(&self) { self.http.get("/endpoint3", self.token) }
    pub fn endpoint4(&self) { self.http.post("/endpoint4", self.token) }
    // etc
}

pub struct AuthCodeSpotify(EndpointsBase, EndpointsOAuth);
impl AuthCodeSpotify {
    pub fn authenticate(&self) { /* ... */ }

    pub fn endpoint1(&self) { self.0.endpoint1() }
    pub fn endpoint2(&self) { self.0.endpoint2() }
    pub fn endpoint3(&self) { self.1.endpoint3() }
    pub fn endpoint4(&self) { self.1.endpoint4() }
    // etc
}
----

In order to make requests in each group of endpoints we'd have to share a single
HTTP client and other information such as the config or the token, which can
become complicated. If we want to make it easy for the user, we also need to
manually delegate every single endpoint into each of the specific clients. We
could also use `Deref` and `DerefMut` in order to avoid the delegation, but
that'd be a common anti-pattern <<deref-antipattern>>.

I tried different approaches, but they ended up falling apart at some point.
What ended up working best for me was a trait-based interface:

[source, rust]
----
pub trait EndpointsBase {
    fn get_http(&self) -> &Http;

    fn endpoint1(&self) { self.get_http().put("/endpoint1") }
    fn endpoint2(&self) { self.get_http().get("/endpoint2") }
    // etc
}

pub trait EndpointsOAuth: EndpointsBase {
    fn get_token(&self) -> &Token;

    fn endpoint3(&self) { self.get_http().get("/endpoint3", self.get_token()) }
    fn endpoint4(&self) { self.get_http().post("/endpoint4", self.get_token()) }
    // etc
}

pub struct AuthCodeSpotify(Http, Token);
impl AuthCodeSpotify {
    pub fn authenticate(&self) { /* ... */ }
}
impl EndpointsBase for AuthCodeSpotify {
    fn get_http(&self) -> &Http { &self.0 }
}
impl EndpointsOAuth for AuthCodeSpotify {
    fn get_token(&self) -> &Http { &self.1 }
}
----

With traits, we don't have any problems regarding sharing HTTP clients or
tokens. All we need to do is provide them as getters, and then the default
implementations can implement the endpoints.

However, I've found the following downsides:

* Since the functionality is provided by the trait, and not the client, the user
  will always need to import the trait in order to use the endpoints. This can
  be fixed somewhat easily by
  https://stackoverflow.com/questions/36384840/what-is-the-prelude[providing a
  prelude] with whatever traits are necessary, so that the user can just do `use
  rspotify::prelude::*` and forget about it.
* You can't really have private functions in the trait. For instance, we have a
  `endpoint_get` method that wraps `http.get` to include the authentication
  headers used for the endpoints. It's defined in the trait because it's useful
  for every client, but the end user doesn't really need access to it; it's just
  noise in the documentation. There are two possible workarounds, so it's not a
  big deal:
** Declare the method in the trait with `#[doc(hidden)]` so that it doesn't
   appear in the documentation.
** Use a private function outside the trait instead.
* You can't use `\-> impl Trait` in trait methods as of Rust 1.55
  <<trait-ret-impl>>, which we unfortunately need. Specially if you're using an
  asynchronous client, because async trait methods are `\-> impl Future` after
  all. We can erase these types with the {{< crate async-trait >}} crate for
  now, until this is fixed thanks to GATs being implemented, which isn't too far
  off <<gats>>.

So yeah, it's far from an ideal solution, but it's definitely the best one I
could find.

* PKCE Authentication <<gh-pkce>>.

== Configuration

There were several parts of the Spotify client that could be configured. 

== Documentation

== Type safety

* More idiomatic code: type safety <<gh-ids>><<gh-derive-builder>>, less `unwrap`s, macros, error handling <<gh-errors>>.

== Macros

== Goodies

* Automatically refreshing token
* Cached token
* Automatic pagination <<gh-pagination>>
* ??

== Sane defaults

* Saner <<gh-wrappers>> and more lightweight defaults <<gh-cleanup>>, more consistent interface <<gh-meta>> <<gh-opt>>.
* Using `from_env`

== Helping with the changes

TODO issue about new version

TODO mention changelog

== Measuring the changes

TODO talk about the bench

=== The Good

TODO: make graphs and similars

* async code has dropped from 206 (!!) compilation units (~1 min 29s on my machine) to 154 (~1min 10s)
* blocking code has dropped from 207 compilation units (~1min 34s) to 103 (~1 min 1s) and now uses ureq
* LoC? Not really fair
* Benchmarks

=== The Bad

* New bugs! Probably lots of 'em!
* Lots of work: I started in ~August of 2020.
* Somewhat more complex codebase.

== Thanks to

This release has been possible thanks to:

* https://github.com/ramsayleung[@ramsayleung]
* https://github.com/kstep[@kstep]
* https://github.com/hellbound22[@hellbound22]
* https://github.com/Qluxzz[@Qluxzz]
* https://github.com/icewind1991[@icewind1991]
* https://github.com/aramperes[@aramperes]
* https://github.com/Sydpy[@Sydpy]
* https://github.com/arlyon[@arlyon]

[bibliography]
== References

- [[[gh-clients,         1]]]
  https://github.com/ramsayleung/rspotify/pull/129[#129 - Multiple clients via
  features]
- [[[gh-pagination,      2]]]
  https://github.com/ramsayleung/rspotify/issues/124[#124 - Add unlimited
  endpoints]
- [[[gh-auth,            2]]]
  https://github.com/ramsayleung/rspotify/issues/173[#173 - Restructure the
  authentication process]
- [[[reddit-auth,        2]]]
  https://www.reddit.com/r/rust/comments/lkdw6o/designing_a_new_architecture_for_rspotify_based/[Designing
  a new architecture for Rspotify based on trait inheritance, need opinions -
  Reddit]
- [[[deref-antipattern,  2]]]
  https://github.com/rust-unofficial/patterns/blob/main/anti_patterns/deref.md[`Deref`
  polymorphism]
- [[[trait-ret-impl,     2]]]
  https://stackoverflow.com/questions/39482131/is-it-possible-to-use-impl-trait-as-a-functions-return-type-in-a-trait-defini[Is
  it possible to use `impl Trait` as a function's return type in a trait
  definition? - StackOverFlow]
- [[[gats,               2]]]
  https://github.com/rust-lang/rust/issues/44265[rust-lang/rust#4426 - Tracking
  issue for generic associated types (GAT)]
- [[[gh-ids,             3]]]
  https://github.com/ramsayleung/rspotify/pull/161[#161 - Initial id type
  proposal] and https://github.com/ramsayleung/rspotify/pull/244[#244 - Fix IDs
  v4].
- [[[gh-errors,          3]]]
  https://github.com/ramsayleung/rspotify/issues/137[#137 - Clean up and
  re-structure the errors]
- [[[gh-cleanup,         4]]]
  https://github.com/ramsayleung/rspotify/issues/108[#108 - Reducing rspotify's
  core dependencies]
- [[[gh-wrappers,        5]]]
  https://github.com/ramsayleung/rspotify/issues/149[#149 - The way to reduce
  wrapper object]
- [[[gh-derive-builder,  6]]]
  https://github.com/ramsayleung/rspotify/issues/109[#109 - Using
  `derive_builder` to avoid repetition with the builder pattern]
- [[[gh-block-cleanup,   TODO]]]
  https://github.com/ramsayleung/rspotify/issues/112[#112 - Cleaning up the
  blocking module]
- [[[gh-pkce,            7]]]
  https://github.com/ramsayleung/rspotify/issues/150[#150 - Authorization Code
  Flow with Proof Key for Code Exchange (PKCE) is missing]
- [[[gh-meta,            8]]]
  https://github.com/ramsayleung/rspotify/issues/127[#127 - Meta-Issue]
- [[[gh-opt,             9]]]
  https://github.com/ramsayleung/rspotify/issues/134[#134 - Optional Parameters]
  and http://localhost:1313/blog/rust-parameters/[Optional Parameters In Rust
  (nullderef.com)].
- [[[spotipy-absent,     10]]] https://github.com/plamere/spotipy/issues/387
- [[[aspotify-release,   11]]]
  https://www.reddit.com/r/rust/comments/ehz66s/aspotify_an_asynchronous_rust_spotify_web_api/[aspotify:
  An asynchronous Rust Spotify web API client - r/rust]
