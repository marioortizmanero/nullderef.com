---
title: "Tremor Journal I: The Beginnings"
description: "My personal experience with Tremor when starting the PDK
implementation"
summary: "Getting to know the Tremor team was exciting. Implementing the PDK
wasn't going to be easy, but it certainly sounded fun thanks to their dynamics.
I had to start somewhere, and this was the moment."
author: "Mario Ortiz Manero"
tags: ["journal"]
series: ["rust-plugins"]
date: 2021-08-06
GHissueID: ??
---

== Getting to know the team

My first official meeting with the Tremor team took place in the beginnings of
August. I had already been lurking in their Discord server before, and I'd
talked with them a few times, so I more or less knew what to expect. But I was
still surprised by their welcomingness and how refreshing their dynamics were.

Starting to work on Tremor for the first time with such a large task at first
sounds daunting. I was somewhat overwhelmed by that and felt quite some pressure
on me. But their words helped me de-stress about it; finishing the PDK would of
course be hard, but no need to worry about things you can't control yet.

I particularly liked the three "`rules`" of their workflow:

* Have fun
* Take good notes
* Don't worry

Matthias, Darach and Heinz seemed like very different kinds of people; something
they knew and took advantage of. Decision-taking is hard; it requires good
communication and an open mind. I also took note of this quote (roughly) from
them:

[quote, Darach]
____
When I have an idea about something, I just post it on the Discord server and
wait for it to be destroyed by someone else.
____

== Getting to know other mentees

In the first meeting I was suggested to meet the other LFX mentee at that
moment, @aryan9600 on Discord, which seemed like a good idea. I'd seen him a
couple times and knew he'd been contributing to Tremor even before the
mentorship.

Aryan turned out to be a very nice colleague! He was very enthusiastic about the
project and he explained me his progress in detail. In summary, he was starting
to add gRPC support to Tremor, and wasn't sure how to approach it so that new
interfaces could be added outside the compilation time. He had multiple ideas on
how to implement this, but the one that interested me the most was via Wasm or
dynamic linking, which was exactly what I was trying to do as well for the PDK.
Which meant I'd probably spend more time with him, as our projects were more
interconnected than I thought.

== Getting started

Up until that point I had mostly investigated about the
https://nullderef.com/blog/plugin-tech/[technologies] that could be used for the
PDK, but I was suggested that I should first take a look at how the interfaces
would actually look like. That way it would be easier to decide how to approach
the PDK's implementation, according to the requirements for these interfaces.

I always knew their original intent was the typical architecture via dynamic
linking, but I wanted to explore the viability of Wasm before ruling it out.
Would this idea be destroyed by someone in the end, or does it stand a chance?
In order to know that I'd first need to find more specific requisites by
defining the basic interfaces in the PDK. Which is very hard at first because
you need to know more about the internals of Tremor.

Luckily, Matthias spent the second meeting explaining me how Tremor works, with
the help of some drawings, taking a look at the code, and running it. He also
taught me the concept of a _connector_, which is just an abstraction over both
sources and sinks. The thing was that connectors were still Work In Progress,
and Matthias needed to know how the PDK would work to adapt the `Connector`
interface. This is when the following questions arose:

* Is it possible to use generics in the PDK?
* Otherwise, is it possible to use `dyn` in the PDK?
* Otherwise, what can be done to represent a "`generic`" trait object in the
  interface Tremor exports for plugins?

Back when I talked to Aryan we ended up asking ourselves the same exact things.
Turns out that the generated code with `tonic` for gRPC uses generics, which
might not be compatible with dynamic loading.

This meant I had to do more research. I spent a few days reading multiple
articles. It's a rabbit hole ðŸ°. For example:

* https://fasterthanli.me/articles/so-you-want-to-live-reload-rust[So you want
  to live-reload Rust - fasterthanli.me]
* https://adventures.michaelfbryan.com/posts/wasm-as-a-platform-for-abstraction/[WebAssembly
  as a Platform for Abstraction - adventures.michaelfbryan.com], recommended to
  me by Aryan
* https://adventures.michaelfbryan.com/posts/ffi-safe-polymorphism-in-rust/[FFI-Safe
  Polymorphism: Thin Trait Objects - adventures.michaelfbryan.com]
* https://adventures.michaelfbryan.com/posts/plugins-in-rust/[Plugins in Rust -
  adventures.michaelfbryan.com]
* https://michael-f-bryan.github.io/rust-ffi-guide/dynamic_loading.html[Dynamic
  Loading & Plugins - michael-f-bryan.github.io]

By the way, thanks a lot to Michael F. Bryan for writing so many articles
regarding dynamic loading!

== Experimenting with plugins

=== Dynamic Loading

Firstly, I've created the
https://github.com/marioortizmanero/pdk-experiments[pdk-experiments] repository,
where I'll write various examples of how the PDK might work. The first one I've
created is in the
https://github.com/marioortizmanero/pdk-experiments/tree/master/dynamic-simple[`dynamic-simple`
directory], with a small example of how to dynamically load plugins with Rust.

We first need a common library, called `tremor-core`, which defines the
interface exported by the plugin so that the main binary may load it. In this
case it's just a function:

.`tremor-core/src/lib.rs`
[source, rust]
----
pub type MinFunction = fn(i32, i32) -> i32;
----

With it, the plugin crate may export its own implementation. In this case I'll
declare a `static` variable, but the example also showcases how `extern` may
work as well. The crate's value of `crate-type` must be set to a
https://doc.rust-lang.org/reference/linkage.html[dynamic library]. Note that
`#[no_mangle]` is necessary so that the variable's name is known when loading it
from the main binary.

.`plugin-sample/src/lib.rs`
[source, rust]
----
#[no_mangle]
pub static plugin_function: MinFunction = min;

fn min(a: i32, b: i32) -> i32 {
    a.min(b)
}
----

Finally, the main binary can load the library with `libloading`:

.`src/main.rs`
[source, rust]
----
fn run_plugin(path: &str) -> Result<(), libloading::Error> {
    unsafe {
        let library = Library::new(path)?;
        let min = library.get::<*mut MinFunction>(b"plugin_function\0")?.read();
        println!("Running plugin:");
        println!("  min(1, 2): {}", min(1, 2));
        println!("  min(-10, 10): {}", min(-10, 10));
        println!("  min(2000, 2000): {}", min(2000, 2000));
    }

    Ok(())
}
----

Running it:

[source, commandline]
----
$ cd plugin-sample
$ cargo build
$ cd ..
$ cargo run -- plugin-sample/target/debug/libplugin_sample.so
Running plugin:
  min(1, 2): 1
  min(-10, 10): -10
  min(2000, 2000): 2000
----

Cool! My research raises a few questions that I should learn more about:

. Many plugin tutorials use `extern "C"` for the exported function's type in the
  plugin. What exactly does that mean? Do we need it if the FFI is Rust-to-Rust?
  Would https://doc.rust-lang.org/std/keyword.extern.html[`extern "Rust"`] work
  any better?
. There are many different options to configure `crate-type` as a
  https://doc.rust-lang.org/reference/linkage.html[dynamic library]. What are
  they and which one should I choose?
. I faintly remember that `rlib` files are Rust-only objects with additional
  metadata for things like generics. Could that possibly work at runtime? As in,
  is there an equivalent to
  https://en.wikipedia.org/wiki/Component_Object_Model[COM] in Rust, or maybe
  like JAR files in Java?

=== 1. `extern` values

The `extern` keyword can be used to either declare function interfaces that Rust
code can call foreign code by, or to export Rust code <<extern>>. Its parameter
specifies what ABI it should use, of which the only interesting values in this
case are:

* `extern "Rust"`: for the Rust ABI
* `extern "C"`: for the default C compiler's ABI in your system

Though most tutorials use `export "C"`, `export "Rust"` is the best choice for
Rust-to-Rust FFI because with it one can easily export Rust-only features like
enums with data fields (at the cost of not being a stable ABI). Otherwise, we'd
get this error:

[source, text]
----
warning: `extern` fn uses type `EnumWithDataFields`, which is not FFI-safe
  --> src/lib.rs:24:50
   |
24 | pub extern "C" fn with_extern(a: i32, b: i32) -> EnumWithDataFields {
   |                                                  ^^^^^^^^^^^^^^^^^^ not FFI-safe
   |
   = note: `#[warn(improper_ctypes_definitions)]` on by default
   = help: consider adding a `#[repr(C)]`, `#[repr(transparent)]`, or integer `#[repr(...)]` attribute to this enum
   = note: enum has no representation hint
note: the type is defined here
  --> src/lib.rs:3:1
   |
3  | / pub enum EnumWithDataFields {
4  | |     A,
5  | |     B(i32),
6  | |     C
7  | | }
   | |_^
----

Note that the default value for the ABI is `"C"`, so `"Rust"` must be explicitly
specified always when using `extern`.

=== 2. `crate-type` values

There are https://doc.rust-lang.org/reference/linkage.html[two ways to configure
dynamic linking with the `crate-type` field] in the crate's `Cargo.toml`:

* `dylib`
* `cdylib`

Once again, this difference has to do with the ABIs in the dynamic library
<<dylib>>. `cdylib` is meant for linking into C/C++ programs, and `dylib` for
Rust ones. `cdylib` will strip away all functions that aren't publicly exported.
`dylib` means that `extern` isn't even needed; you just need to set the external
items as `pub`.

=== 3. `rlib` files

Also listed in the previous section, `rlib` is a value for `crate-type` that
might be of interest. `rlib` files are Rust *static* libraries, which can then
be imported with `extern crate crate_name` <<dylib>>. Since `rlib` files are
static libraries, they can't be loaded at runtime.

So here's a crazy idea: What if the `rlib` files were dynamically loaded as
plugins with the help of https://github.com/rust-lang/miri[MIRI]? I recently
learned about it, and quoting its official documentation:

[quote]
____
[MIRI is] an experimental interpreter for Rust's mid-level intermediate
representation (MIR). It can run binaries and test suites of cargo projects and
detect certain classes of undefined behavior.

#You can use Miri to emulate programs on other targets#, e.g. to ensure that
byte-level data manipulation works correctly both on little-endian and
big-endian systems.
____

Hmm. Could it possibly be used to interpret Rust code? In some way this would be
very similar to using WebAssembly, but theoretically with less friction, as MIR
is specific to Rust and plugin development would be as easy as in the case of
dynamic loading with Rust-to-Rust FFI. A few things to consider:

. *Is this even possible?*
+
The Rust compiler itself uses MIRI to evaluate constant expressions
<<miri-compiler>> via the
https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/index.html[`rustc_mir`
crate]. But taking a quick look it seems to be created specifically for the
compiler, at a very low level, and without that much documentation. Plus, it's
nightly-only. It does seem possible, but I wasn't able to get a simple example
working.
. *Is MIR stable?*
+
MIR is unfortunately unstable <<miri-unstable>>, so we'd have the same
incompatibility problems between plugins and the main binary.
. *Is the overhead of MIRI worth it?*
+
Considering the previous answers, no, this approach is most likely not the way
to go.

=== WebAssembly

And, in the case of Wasm:

[source, rust]
----
----

What I wanted to see if there was any
way around it and how complicated it was.

The thing is: generics are almost inevitable in Rust. In a trait, you might want
to use them to:

* TODO: more?
* Handle lifetimes
* Async (in the future). A trait with an `async` method will work thanks to
  generics (https://github.com/rust-lang/rust/issues/44265[GATs]).

There are ways to work around these, but they of course mean additional
overhead:

* Lifetimes: smart pointers like `Rc<T>`, `Arc<T>` (TODO: raw pointers + unsafe?)
* Async (GATs): just like how it works nowadays with `async_trait`, by boxing
  the `Future`. TODO: add reference and example.

It turns out I wasn't the first person to ask that question, and Michael had a
few ideas about it.

== First prototype with dynamic linking

TODO

The first approach for the PDK used dynamic linking. I was looking forward to
using a library other than `libloading` because of how easy it seems to end up
with undefined behaviour in that case. I found out `sharedlib` was abandoned, as
no commits had been made since 2017, leaving `dlopen` as the only alternative.

I also had to investigate first, so I did some reading about dynamic linking in
order to know more about how it works:

== Supporting generics in plugins

I already imagined that generics with dynamic linking is fundamentally
impossible. Rust needs to know the size of the objects it's dealing with at
compile-time -- which is when generics works -- something that's not available
when using dynamically loaded libraries. It's really easy to prove in Rust with
the following example:

[source, rust]
----
extern {
    fn foo<T>();
}
----

Which results in the error:

[source, text]
----
error[E0044]: foreign items may not have type parameters
 --> src/lib.rs:2:5
  |
2 |     fn foo<T>();
  |     ^^^^^^^^^^^^ can't have type parameters
  |
  = help: replace the type parameters with concrete types like `u32`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0044`.
----

Interestingly enough, you can export `extern` functions declared _in Rust_. This
will compile:

[source, rust]
----
extern fn foo<T>() {}
----

This confused me in the beginning; it made me think generic functions through
FFI would be possible. But as described in
https://github.com/rust-lang/rust/pull/15831[the original issue that allowed
them], they're only supported to pass callbacks to C functions.

[bibliography]
== References

- [[[extern,        1]]] https://doc.rust-lang.org/std/keyword.extern.html
- [[[dylib,         2]]] https://users.rust-lang.org/t/what-is-the-difference-between-dylib-and-cdylib/28847
- [[[miri-compiler, 3]]] https://rustc-dev-guide.rust-lang.org/miri.html
- [[[miri-unstable, 4]]] https://github.com/rust-lang/miri/blob/master/CONTRIBUTING.md#preparing-the-build-environment
