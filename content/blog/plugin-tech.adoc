---
title: "Plugins in Rust: The Technologies"
description: "A more in-depth look at Rust PDKs"
author: "Mario Ortiz Manero"
tags: ["rust", "gsoc"]
categories: ["project"]
date: 2021-04-13
draft: true
---

== Abstract

Summary + best options. Maybe this should be a conclusion section at the end
instead?

== Introduction

In this article I will futher analyze how a Plugin Development Kit could be
implemented in Rust with more investigation and other ideas I've found. This is
all based on the Google Summer of Code proposal for
https://www.tremor.rs/[Tremor], which you can find link:{{< ref
"gsoc-proposal.adoc" >}}[here].

== Requirements

After showing the proposal to the Tremor team, I was given an important
suggestion: in this case there isn't really a need to be able to write plugins
from multiple programming languages; it's not worth the additional complexity.
It would definitely be interesting but with this I can focus on the main problem
I discovered in my proposal: the ABI instability.

Besides that, the rest of the main points to consider remain the same:

. *Mandatory:* Being able to load/unload the plugins both at start-time and at
  run-time.
. *Mandatory:* Cross-platform support
. *Mandatory:* Low overhead
. *Mandatory:* Available at least from Rust
. *Extra:* As little `unsafe` usage as possible
. *Extra:* Binary compatibility
. *Extra*: Not much work to port from the current implementations

[[safety]]
== Safety Concerns

I've been wanting to take a look at the possible safety concerns a PDK could
bring to Tremor since the initial proposal.

Depending on the approach that is taken for the Plugin System, implementing
solutions to some of the points I make below can be really complex, so I don't
plan on implementing them for the initial proposal. Hopefully, though, this will
serve for future upgrades to the PDK. For now, it's something we have to be
aware of.

=== Unsafe code

Many of the technologies that can be used to implement a plugin system work with
unsafe code, like <<ffi,FFIs>> or <<memory-sharing,Memory Sharing>>. This isn't
necessarily a problem if it's self-contained and thoroughly reviewed, but it
definitely increases the maintenance cost of the library and we lose some of the
safety guarantees Rust provides us.

It takes much more work to make sure the implementation is sound, even with
tools like https://github.com/rust-lang/miri[MIRI], which I plan on integrating
into Tremor if I do end up having to use `unsafe`.

=== Error resilience

Rust doesn't protect its users from leaking memory. In fact, it's as easy as
calling `mem::forget`. The thing is that if a plugin leaks memory, the entire
process also does, meaning that Tremor's performance could be affected by
incorrectly developed plugins.

This doesn't happen just with memory leaks; a plugin could panic and crash the
entire thing very easily, and I'm not sure if `catch_unwind` can be used for
e.g. dynamically loaded libraries.

Ideally, Tremor could detect plugins that aren't performing well and stop them
before it's too late. The rest of the setup could continue running, and perhaps
warn the user about its malfunctioning, for optimal error resilience.

=== Remote Code Execution via Plugins

https://en.wikipedia.org/wiki/Component_Object_Model#Security[This was a problem
with Internet Explorer], for example. It used COM and ActiveX, which implement
no sandboxing at all and were ran directly on the user's machine, allowing
malware to be included in plugins and execute arbitrary code. This can be less
of a problem installing only trusted plugins with digital signatures, but it's
still a huge risk.

In the case of Tremor plugins this is a similar problem. The end user in this
case is developers, who should be more wary of what they're including in their
own projects -- but the truth is that it isn't any better.

I would compare the situation more specifically to how package managers like
https://www.npmjs.com/[npm] work (or anything that deals with dependencies). The
entire infrastructure is usually based on trust; noone's really stopping you
from uploading a malicious package/crate for remote code execution or to steal
data <<npm-trust>>. Plugins are like dependencies in this case, which may be
malicious and have full access to the host's computer.

An improved approach would be something like
https://github.com/denoland/deno[Deno], which is a secure by default
JavaScript/TypeScript runtime. This is enabled thanks to sandboxing, and
requires the developer to manually toggle e.g. access to the filesystem or to
the network. This is no panacea because people might end up enabling whatever
permission is required by the dependency they want to install without thinking
about it, but it's similar to `unsafe`: at least it makes you aware that you
might mess up.

== Possible Approaches

The following are the most sensible technologies that could be used as the base
of the PDK. Some of the won't match the requirements I mentioned earlier, but
it's a good idea to at least _consider_ all of them. I haven't implemented
anything yet, so if an approach were to catch a Tremor developer's eye we could
investigate more about it.

// TODO: is the ranking ok?

I will rate each of the options in a scale from 1 to 5 in order to take the
final decision. So, roughly ranked from worse to best for Tremor's usage:

:rank-same: olive white-background txt-margin-right txt-round
:rank-up: green white-background txt-margin-right txt-round
:rank-down: red white-background txt-margin-right txt-round

[[scripting-langs]]
=== Scripting Languages

Plently of projects use scripting languages to extend their functionality at
runtime, like Python, Ruby, Perl, Bash or JavaScript. Most notably, Vim created
its own scripting language, Vimscript, in order to be fully customizable, and
NeoVim is now pushing http://www.lua.org/[Lua] as a first-class language for
configuration. Even Tremor itself has the interpreted query language
https://docs.tremor.rs/tremor-query/[`tremor-query`] for configuration.

Lua is seen in game development; it's a quite simple language with a very
performant JIT implementation, which in any case I think would be the best
option. It could be embedded into Tremor (it's only 247 kB compiled!
<<lua-wiki>>) and used to load plugins at either start-time or run-time. And
knowing it's used in games, which are _obsessed_ with performance, it might not
be that much of a big deal in that regard.

There are libraries in Rust like https://github.com/amethyst/rlua[`rlua`] which
provide bindings for interoperability with Lua. `rlua` in particular seems to
focus on having an idiomatic and safe interface, which is rare for a bindings
library and good news, though it seems to be currently semi-abandoned, and
forked by https://github.com/khvzak/mlua[`mlua`]. Unfortunately, after digging a
bit the Rust ecosystem for Lua bindings doesn't seem to be as mature as I'd like
for a project this big; there's still some work to do to reach more stability.

Anyhow, the main deal breaker with scripting languages in this case is that it
would be extremely complicated to port everything in Tremor so that it can be
used from Lua. For new projects this could perhaps be something interesting, but
not if the entirety of the already existing plugins have to be rewritten.

Still, it's a pretty interesting option for new projects, as you have ABI
stability guarantees, don't need unsafe code, and is very straightforward to
use.

. [{rank-same}]*5/5* *Loading at start-time and run-time*
. [{rank-same}]*5/5* *Cross-platform support*
. [{rank-same}]*4/5* *Low overhead*
. [{rank-same}]*3/5* *Rust availability*
. [{rank-same}]*5/5* *No `unsafe` usage*
. [{rank-same}]*5/5* *Binary compatibility*
. [{rank-same}]*0/5* *Ease of porting current implementations*

[[ipc]]
=== Inter-Process Communication

Another possibility for plugins is to define a protocol for Inter-Process
Communication, turning Tremor into a server that extends its capabilities by
connecting to external plugins. For instance, most text editors use this method
to support the https://microsoft.github.io/language-server-protocol/[Language
Server Protocol], which uses JSON-RPC.

There are of course multiple ways to do IPC, which I'll briefly list below.
Performance-wise, <<ipc-wisc>> shows a comparison of the overhead of each of
them:

image::/blog/plugin-tech/ipc-comparison.png[IPC comparison, width=60%, align=center]

[[sockets]]
==== Based on Sockets

Sockets are the worst-performing alternative in the previous chart, but they're
so common and easy to use in most languages that it's worth taking a look at.
Using relatively lightweight protocols like Protocol Buffers<<protobuf>>, the
performance would be close to passing raw structs, but with improved
backwards/forwards compatibility <<protobuf-perf>>. JSON would probably not make
that big of a difference in terms of performance either. This would make it
possible to write a plugin in any language as well -- including Rust -- as long
as there's an implementation of the protocol available. But there's still
noticeable overhead when communicating via sockets; sending and receiving the
messages can be much costlier than just calling a function, even if this happens
on localhost.

The main issue with this alternative is shared with <<scripting-langs>>. In this
case at least we don't have to completely rewrite everything, since we could
still use Rust, but Tremor would have to declare a protocol to communicate
between the Tremor core and its plugins, which is a lot of work and makes this a
not really feasible option.

Overall, though, it seems more reasonable than <<scripting-langs>>. It does
require a lot of work, but it helps a lot in terms of <<safety>>. Separate
processes imply that malfunctioning plugins don't affect Tremor, and it
basically consists on implementing basic servers, which require no `unsafe` at
all and means that there's much more support for that in Rust.

. [{rank-same}]*5/5* *Loading at startdowntime and rundowntime*
. [{rank-same}]*5/5* *Crossdownplatform support*
. [{rank-down}]#*3/5* (-1)# *Low overhead*
. [{rank-up}]#*5/5* (+1)# *Rust availability*
. [{rank-same}]*5/5* *No `unsafe` usage*
. [{rank-same}]*5/5* *Binary compatibility*
. [{rank-same}]*2/5* *Ease of porting current implementations*

[[pipes]]
==== Based on Pipes

Named Pipes are really popular specifically on Linux, and enable Inter-Process
Communication with less overhead than sockets. They are made to be ran on the
same machine, which is exactly what we need. The terminal file manager
https://github.com/jarun/nnn[nnn] uses this approach: plugins can use a FIFO
(Named Pipe) to receive selections from nnn (lists of files or directories) and
act accordingly.

The rest is basically the same as with <<sockets, Sockets>>, maybe with extra
points for performance, and less for Rust availability, since there don't seem
to be any reliable libraries for pipes, besides `std`.

. [{rank-same}]*5/5* *Loading at start-time and run-time*
. [{rank-same}]*5/5* *Cross-platform support*
. [{rank-up}]#*4/5* (+1)# *Low overhead*
. [{rank-down}]#*3/5* (-2)# *Rust availability*
. [{rank-same}]*5/5* *No `unsafe` usage*
. [{rank-same}]*5/5* *Binary compatibility*
. [{rank-same}]*2/5* *Ease of porting current implementations*

[[memory-sharing]]
==== Based on Memory Sharing

Knowing that the plugins are intended to be on the same machine as the core of
Tremor, there's no need to actually send and receive messages. One can share
memory between multiple processes and send notifications to receive updates.

// TODO: find a source for "the performance may vary depending on how the system
// is configured"

This feature depends on the Operating System, though, so it may hurt the
"Cross-Compatibility" requirement. While there are ways to create a common
interface for all the OS we want to support, the performance may vary depending
on how the system is configured. But overall, the overhead is probably
comparable to using a <<ffi>>, as the overhead is minimal.

There are libraries like https://docs.rs/shared_memory[`shared_memory`] +
https://docs.rs/raw_sync[`raw_sync`] in Rust that allow us to do this, but they
don't seem to be nowhere near as popular as most of the other alternatives.
While the wrapper itself is quite simple, there isn't that much information
about IPC shared memory for Rust. And the examples for `shared_memory` _do_ use
`unsafe`.

Maybe if it was easier to use this would be a good idea, but IPC shared memory
doesn't seem to be any better than <<ffi>.

[[ffi]]
=== FFI

// TODO

This is possibly the _least weird_ way to do this, or at least the most common
one for what we actually need in a Plugin Development Kit.

https://docs.rs/libloading/[`libloading`]

https://github.com/emoon/dynamic_reload[`dynamic_reload`]

==== C

==== Rust

Using Rust FFI is the easiest because it doesn't force Tremor to define a strict
internal ABI, which can be a lot of work, as discussed in the previous section.

https://github.com/dtolnay/inventory[`inventory`]

https://github.com/rodrimati1992/abi_stable_crates[`abi_stable`]

* It only supports native dynamic libraries right now,since AFAIK extern "C" fn
  with arbitrary types is not supported in the WASM abi.
* It requires that you use some types from abi_stable instead of stdlib ones for
  the values you'll pass through ffi.
* It's still immature,lacking a Map<K,V> type for example,since I've had to
  reinvent the wheel for many Rust types.

=== Webassembly Interface

// TODO

Now, this is what I wanted to emphasize in this article! Turns out Wasm isn't
limited to web development anymore; it's slowly evolving into a portable
binary-code format. This is how it's described in their official website:

[quote, https://webassembly.org/]
____
WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based
virtual machine. Wasm is designed as a portable compilation target for
programming languages, enabling deployment on the web for client and server
applications.
____

https://github.com/bytecodealliance/wasmtime/blob/main/docs/WASI-tutorial.md#from-rust[WASI]

https://freemasen.com/blog/wasmer-plugin-pt-1/[Wasmer Tutorial]

https://github.com/FreeMasen/wasmer-plugin/[`wasmer-plugin`]

== Prior Art

It's very important to take a look at projects that have already done this in
the past in order to learn from their mistakes and not start from scratch.

Rust is relatively new, so I also took a look at similar languages that also
don't 

Here's a list of some of the libraries I found with PDKs, specifically written
in Rust:

* https://github.com/zellij-org/zellij[`zellij`]
* https://github.com/xi-editor/xi-editor[`xi`] (JSON RPC), described
  https://raphlinus.github.io/xi/2020/06/27/xi-retrospective.html#json[here in
  detail].
+
--

Text editors specifically are very interesting, because they must be built with
extensibility in mind and thus have to implement some kind of plugin system.

* Visual Studio is based on Electron, so it has a renderer process for the
  frontend, and a main process with Node. Its extensions share the same event
  loop,
  https://github.com/microsoft/vscode/issues/75627#issuecomment-519125065[which
  has been an issue for a long time in case an extension blocks temporarily],
  causing lag.
* Eclipse's plugin architecture is based on Java classes <<eclipse>> loaded at
  runtime and configured with XML manifests.

--
* https://lib.rs/crates/plugin-system[`plugin-system`] (2019, obsolete)
* Firefox?

[bibliography]
== References

// TODO: sort

- [[[michael,1]]] https://adventures.michaelfbryan.com/posts/plugins-in-rust/
- [[[fasterthanlime,2]]] https://fasterthanli.me/articles/so-you-want-to-live-reload-rust
- [[[lua-wiki,3]]] https://en.wikipedia.org/wiki/Lua_(programming_language)
- [[[protobuf,4]]] https://developers.google.com/protocol-buffers
- [[[protobuf-perf,5]]] https://google.github.io/flatbuffers/flatbuffers_benchmarks.html
- [[[serde,6]]] https://serde.rs/
- [[[ipc-wisc,7]]] http://pages.cs.wisc.edu/~adityav/Evaluation_of_Inter_Process_Communication_Mechanisms.pdf
- [[[eclipse,8]]] http://www.eclipse.org/articles/Article-Plug-in-architecture/plugin_architecture.html
- [[[npm-trust,9]]] https://jamie.build/how-to-build-an-npm-worm
