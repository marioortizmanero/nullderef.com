---
title: "Plugins in Rust: The Technologies"
description: "A more in-depth look at Rust PDKs"
author: "Mario Ortiz Manero"
tags: ["rust", "gsoc"]
categories: ["project"]
date: 2021-04-13
draft: true
---

:sectnums:

== Abstract

Summary + best options. Maybe this should be a conclusion section at the end
instead?

== Introduction

In this article I will futher analyze how a Plugin Development Kit could be
implemented in Rust with more investigation and other ideas I've found. This is
all based on the Google Summer of Code proposal <<proposal>> for
https://www.tremor.rs/[Tremor] I started with.

== Requirements

After showing the proposal to the Tremor team, I was given an important
suggestion: in this case there isn't really a need to be able to write plugins
from multiple programming languages; it's not worth the additional complexity.
It would definitely be interesting but with this I can focus on the main problem
I discovered in my proposal: the ABI instability.

Besides that, the rest of the main points to consider remain the same:

. *Mandatory:* Being able to load/unload the plugins both at start-time and at
  run-time.
. *Mandatory:* Cross-platform support
. *Mandatory:* Low overhead
. *Mandatory:* Available at least from Rust
. *Extra:* <<safety,Safety>>
. *Extra:* Backwards compatibility
. *Extra*: Not much work to port from the current implementations

[[safety]]
== Safety Concerns

I've been wanting to take a look at the possible safety concerns a PDK could
bring to Tremor since the initial proposal.

Depending on the approach that is taken for the Plugin System, implementing
solutions to some of the points I make below can be really complex, so I don't
plan on implementing them for the initial proposal. Hopefully, though, this will
serve for future upgrades to the PDK. For now, it's something we have to be
aware of.

=== Unsafe code

Many of the technologies that can be used to implement a plugin system work with
unsafe code, like <<ffi,FFIs>> or <<memory-sharing,Memory Sharing>>. This isn't
necessarily a problem if it's self-contained and thoroughly reviewed, but it
definitely increases the maintenance cost of the library and we lose some of the
safety guarantees Rust provides us.

It takes much more work to make sure the implementation is sound, even with
tools like https://github.com/rust-lang/miri[MIRI], which I plan on integrating
into Tremor if I do end up having to use `unsafe`.

=== Error resilience

Rust doesn't protect its users from leaking memory. In fact, it's as easy as
calling `mem::forget`. The thing is that if a plugin leaks memory, the entire
process also does, meaning that Tremor's performance could be affected by
incorrectly developed plugins.

This doesn't happen just with memory leaks; a plugin could panic and crash the
entire thing very easily, and I'm not sure if `catch_unwind` can be used for
e.g. dynamically loaded libraries.

Ideally, Tremor could detect plugins that aren't performing well and stop them
before it's too late. The rest of the setup could continue running, and perhaps
warn the user about its malfunctioning, for optimal error resilience.

=== Remote Code Execution via Plugins

https://en.wikipedia.org/wiki/Component_Object_Model#Security[This was a problem
with Internet Explorer], for example. It used COM and ActiveX, which implement
no sandboxing at all and were ran directly on the user's machine, allowing
malware to be included in plugins and execute arbitrary code. This can be less
of a problem installing only trusted plugins with digital signatures, but it's
still a huge risk.

In the case of Tremor plugins this is a similar problem. The end user in this
case is developers, who should be more wary of what they're including in their
own projects -- but the truth is that it isn't any better.

I would compare the situation more specifically to how package managers like
https://www.npmjs.com/[npm] work (or anything that deals with dependencies). The
entire infrastructure is usually based on trust; noone's really stopping you
from uploading a malicious package/crate for remote code execution or to steal
data <<npm-trust>>. Plugins are like dependencies in this case, which may be
malicious and have full access to the host's computer.

An improved approach would be something like
https://github.com/denoland/deno[Deno], which is a secure by default
JavaScript/TypeScript runtime. This is enabled thanks to sandboxing, and
requires the developer to manually toggle e.g. access to the filesystem or to
the network. This is no panacea because people might end up enabling whatever
permission is required by the dependency they want to install without thinking
about it, but it's similar to `unsafe`: at least it makes you aware that you
might mess up.

== Possible Approaches

The following are the most sensible technologies that could be used as the base
of the PDK. Some of the won't match the requirements I mentioned earlier, but
it's a good idea to at least _consider_ all of them. I haven't implemented
anything yet, so if an approach were to catch a Tremor developer's eye we could
investigate more about it.

// TODO: is the ranking ok?

I will now rate each of the options in a scale from 1 to 5 in order to take the
final decision:

:rank-meh: olive white-background txt-margin-right txt-round
:rank-good: green white-background txt-margin-right txt-round
:rank-bad: red white-background txt-margin-right txt-round

[[scripting-langs]]
=== Scripting Languages

Plently of projects use scripting languages to extend their functionality at
runtime, like Python, Ruby, Perl, Bash or JavaScript. Most notably, Vim created
its own scripting language, Vimscript, in order to be fully customizable, and
NeoVim is now pushing http://www.lua.org/[Lua] as a first-class language for
configuration. Even Tremor itself has the interpreted query language
https://docs.tremor.rs/tremor-query/[`tremor-query`] for configuration.

Lua is seen in game development; it's a quite simple language with a very
performant JIT implementation, which in any case I think would be the best
option. It could be embedded into Tremor (it's only 247 kB compiled!
<<lua-wiki>>) and used to load plugins at either start-time or run-time. And
knowing it's used in games, which are _obsessed_ with performance, it might not
be that much of a big deal in that regard.

There are libraries in Rust like https://github.com/amethyst/rlua[`rlua`] which
provide bindings for interoperability with Lua. `rlua` in particular seems to
focus on having an idiomatic and safe interface, which is rare for a bindings
library and good news, though it seems to be currently semi-abandoned, and
forked by https://github.com/khvzak/mlua[`mlua`]. Unfortunately, after digging a
bit the Rust ecosystem for Lua bindings doesn't seem to be as mature as I'd like
for a project this big; there's still some work to do to reach more stability.

Lua gets extra points in safety. It's possible to sandbox it by blocking
whichever functions you don't want users to access <<lua-sandbox>> (though it's
"`tricky and generally speaking difficult to get right`"). Similarly, one can
also handle resource exhaustion issues within Lua programs. Not to mention that
this wouldn't require `unsafe` at all with an optimal set of bindings.

Anyhow, the main deal breaker with scripting languages in this case is that it
would be extremely complicated to port everything in Tremor so that it can be
used from Lua. For new projects this could perhaps be something interesting, but
not if the entirety of the already existing plugins have to be rewritten.

Still, it's a pretty interesting option for new projects, as you have ABI
stability guarantees, don't need unsafe code, and is very straightforward to
use.

. [{rank-good}]*5/5* *Loading at start-time and run-time*
. [{rank-good}]*5/5* *Cross-platform support*
. [{rank-good}]*4/5* *Low overhead*
. [{rank-meh}]*3/5* *Rust availability*
. [{rank-good}]*4/5* *Safety*
. [{rank-good}]*5/5* *Backwards compatibility*
. [{rank-bad}]*0/5* *Ease of porting current implementations*

[[ipc]]
=== Inter-Process Communication

Another possibility for plugins is to define a protocol for Inter-Process
Communication, turning Tremor into a server that extends its capabilities by
connecting to external plugins. For instance, most text editors use this method
to support the https://microsoft.github.io/language-server-protocol/[Language
Server Protocol], which uses JSON-RPC.

There are of course multiple ways to do IPC, which I'll briefly list below.
Performance-wise, <<ipc-wisc>> shows a comparison of the overhead of each of
them:

image::/blog/plugin-tech/ipc-comparison.png[IPC comparison, width=60%, align=center]

[[sockets]]
==== Based on Sockets

Sockets are the worst-performing alternative in the previous chart, but they're
so common and easy to use in most languages that it's worth taking a look at.
Using relatively lightweight protocols like Protocol Buffers<<protobuf>>, the
performance would be close to passing raw structs, but with improved
backwards/forwards compatibility <<protobuf-perf>>. JSON would probably not make
that big of a difference in terms of performance either. This would make it
possible to write a plugin in any language as well -- including Rust -- as long
as there's an implementation of the protocol available. But there's still
noticeable overhead when communicating via sockets; sending and receiving the
messages can be much costlier than just calling a function, even if this happens
on localhost.

This alternative is much more interesting than <<scripting-langs>>: we don't
have to completely rewrite everything, since Rust can still be used, and
implementing the protocol to communicate between the Tremor core and its plugins
should be as easy as `\#[derive(Serialize)]` for sending and
`#[derive(Deserialize)]` for receiving.

As to safety, separate processes imply that malfunctioning plugins don't affect
Tremor directly, and the PDK basically consists on implementing servers, which
require no `unsafe` at all and has much more popularity and support in Rust.
It's still hard to properly sandbox plugins, though.

Overall, I consider this a very solid solution, with its main drawback being
performance. I can't really guess the effect this would have in Tremor's speed,
so I would love to create a quick benchmark when I get to implement the first
prototypes to see if it's actually the best choice, if Tremor devs agree with me
on this one.

. [{rank-good}]*5/5* *Loading at start-time and run-time*
. [{rank-good}]*5/5* *Cross-platform support*
. [{rank-meh}]*3/5* *Low overhead*
. [{rank-good}]*5/5* *Rust availability*
. [{rank-good}]*4/5* *Safety*
. [{rank-good}]*5/5* *Backwards compatibility*
. [{rank-good}]*4/5* *Ease of porting current implementations*

[[pipes]]
==== Based on Pipes

Named Pipes have always been fairly popular specifically on Unix systems, and
enable Inter-Process Communication with less overhead than sockets. They are
made to be ran on the same machine, which is exactly what we need. The terminal
file manager https://github.com/jarun/nnn[nnn] uses this approach: plugins can
read from a FIFO (Named Pipe) to receive selections from nnn (lists of files or
directories) and act accordingly.

The rest is basically the same as with <<sockets, Sockets>>, maybe with extra
points for performance, and less for Rust availability, since there don't seem
to be any reliable libraries for pipes, besides `std` (maybe
https://docs.rs/interprocess/1.1.1/interprocess/[`interprocess`] or
https://crates.io/crates/ipipe[`ipipe`]).

. [{rank-good}]*5/5* *Loading at start-time and run-time*
. [{rank-good}]*5/5* *Cross-platform support*
. [{rank-good}]*4/5* *Low overhead*
. [{rank-meh}]*3/5* *Rust availability*
. [{rank-good}]*5/5* *Safety*
. [{rank-good}]*5/5* *Backwards compatibility*
. [{rank-good}]*4/5* *Ease of porting current implementations*

[[memory-sharing]]
==== Based on Memory Sharing

Knowing that the plugins are intended to be on the same machine as the core of
Tremor, there's no need to actually send and receive messages. One can share
memory between multiple processes and send notifications to receive updates. The
performance is comparable to using a <<ffi>>, since the only overhead is the
initial cost from setting up the shared pages, having regular memory access
afterwards <<memory-share-so>>.

This feature heavily depends on the system's kernel, so it may hurt the
"Cross-Compatibility" requirement. We have libraries like
https://docs.rs/shared_memory[`shared_memory`] pass:[+]
https://docs.rs/raw_sync[`raw_sync`] in Rust that wrap all the OS
implementations under the same interface, but admittedly, they don't seem
anywhere near as popular as most of the other alternatives. Not to mention that
the examples for `shared_memory` _do_ use `unsafe`, and a lot of it.

Maybe if it was easier to use this would be a good idea, but IPC shared memory
doesn't seem to be any better than <<ffi>> or <<pipes,Pipes>>.

. [{rank-good}]*5/5* *Loading at start-time and run-time*
. [{rank-good}]*5/5* *Cross-platform support*
. [{rank-good}]*5/5* *Low overhead*
. [{rank-bad}]*2/5* *Rust availability*
. [{rank-bad}]*0/5* *Safety*
. [{rank-meh}]*3/5* *Backwards compatibility*
. [{rank-good}]*4/5* *Ease of porting current implementations*

// TODO: add sum of points

[[ffi]]
=== FFI

// TODO

This is possibly the _least weird_ way to implement a Plugin Development Kit,
i.e. it's the most popular method I've seen. A Foreign Function Interface can
allow us to directly access resources in separately compiled objects, and also
after the linking phase with dynamic loading. It's one of the fastest options
available because there's no overhead at all after dynamically loading the
library.

The main library for this is `libloading`. It seems to be a lower-level
implementation for any kind of FFI that requires `unsafe` for almost everything
-- what I was expecting. Based on it there's `dynamic_reload`, which is very
interesting in order to "`live reload`" the plugins when they are recompiled.
This would be useful for plugin development, since it also handles unloading the
_same plugin_ seamlessly, but that's not a goal for this project so I don't plan
on using it.

==== With C

I already discussed this quite a bit in the proposal <<proposal>> and came to
the conclusion that, the same way as with <<scripting-langs>>, it's not viable
to create an internal interface for Tremor through C.

==== With Rust

Using Rust FFI is the easiest, but it still has a couple of inconvenients:

. Awful safety: lots of `unsafe` usage is required. No sandboxing either. And
  plugins can abort Tremor's core execution when panicking/leaking
  memory/similars (I haven't been able to find information about using
  `catch_unwind` with Rust-to-Rust FFIs).
. Binary compatibility is not good. Any minor change to either Tremor's
  interface or the version it was compiled with will break the plugin.

As a way to improve the binary compatibility aspect, one can use the
https://github.com/rodrimati1992/abi_stable_crates[`abi_stable`] crate, which
supposedly guarantee Rust ABI's stability unofficially.

Its own author lists the following inconvenients:

* It only supports native dynamic libraries right now,since AFAIK extern "C" fn
  with arbitrary types is not supported in the WASM abi.
* It requires that you use some types from abi_stable instead of stdlib ones for
  the values you'll pass through ffi.
* It's still immature,lacking a Map<K,V> type for example,since I've had to
  reinvent the wheel for many Rust types.

. [{rank-meh}]*5/5* *Loading at start-time and run-time*
. [{rank-meh}]*5/5* *Cross-platform support*
. [{rank-good}]*5/5* *Low overhead*
. [{rank-bad}]*2/5* *Rust availability*
. [{rank-bad}]*1/5* *Safety*
. [{rank-meh}]*5/5* *Backwards compatibility*
. [{rank-good}]*4/5* *Ease of porting current implementations*

=== Webassembly Interface

// TODO

Now, this is what I wanted to emphasize in this article! Turns out Wasm isn't
limited to web development anymore; it's slowly evolving into a portable
binary-code format. This is how it's described in their official website:

[quote, https://webassembly.org/]
____
WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based
virtual machine. Wasm is designed as a portable compilation target for
programming languages, enabling deployment on the web for client and server
applications.
____

https://github.com/bytecodealliance/wasmtime/blob/main/docs/WASI-tutorial.md#from-rust[WASI]

https://freemasen.com/blog/wasmer-plugin-pt-1/[Wasmer Tutorial]

https://github.com/FreeMasen/wasmer-plugin/[`wasmer-plugin`]

== Prior Art

It's very important to take a look at projects that have already done this in
the past in order to learn from their mistakes and not start from scratch.

Rust is relatively new, so I also took a look at similar languages that also
don't 

Here's a list of some of the libraries I found with PDKs, specifically written
in Rust:

* https://github.com/zellij-org/zellij[`zellij`]
* https://github.com/xi-editor/xi-editor[`xi`]
  (https://docs.rs/xi-rpc/0.3.0/xi_rpc/[JSON RPC]), described
  https://raphlinus.github.io/xi/2020/06/27/xi-retrospective.html#json[here in
  detail].
+
--

Text editors specifically are very interesting, because they must be built with
extensibility in mind and thus have to implement some kind of plugin system.

* Visual Studio is based on Electron, so it has a renderer process for the
  frontend, and a main process with Node. Its extensions share the same event
  loop,
  https://github.com/microsoft/vscode/issues/75627#issuecomment-519125065[which
  has been an issue for a long time in case an extension blocks temporarily],
  causing lag.
* Eclipse's plugin architecture is based on Java classes <<eclipse>> loaded at
  runtime and configured with XML manifests.

--
* https://lib.rs/crates/plugin-system[`plugin-system`] (2019, obsolete)
* Firefox?

[bibliography]
== References

// TODO: sort

- [[[proposal,0]]] {{< ref "gsoc-proposal.adoc" >}}
- [[[michael,1]]] https://adventures.michaelfbryan.com/posts/plugins-in-rust/
  and https://michael-f-bryan.github.io/rust-ffi-guide/dynamic_loading.html
- [[[fasterthanlime,2]]] https://fasterthanli.me/articles/so-you-want-to-live-reload-rust
- [[[lua-wiki,3]]] https://en.wikipedia.org/wiki/Lua_(programming_language)
- [[[protobuf,4]]] https://developers.google.com/protocol-buffers
- [[[protobuf-perf,5]]] https://google.github.io/flatbuffers/flatbuffers_benchmarks.html
- [[[serde,6]]] https://serde.rs/
- [[[ipc-wisc,7]]] http://pages.cs.wisc.edu/~adityav/Evaluation_of_Inter_Process_Communication_Mechanisms.pdf
- [[[eclipse,8]]] http://www.eclipse.org/articles/Article-Plug-in-architecture/plugin_architecture.html
- [[[npm-trust,9]]] https://jamie.build/how-to-build-an-npm-worm
- [[[memory-share-so,10]]] https://stackoverflow.com/a/14512554/11488352
- [[[lua-sandbox,11]]] http://lua-users.org/wiki/SandBoxes
