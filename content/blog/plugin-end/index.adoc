---
title: "Plugins in Rust: TODO"
description: "The last finishing touches to the plugin system so that it can be
released in Tremor's new version"
author: "Mario Ortiz Manero"
tags: ["rust", "rustlang", "plugin", "benchmarking", "testing", "deployment"]
series: ["rust-plugins"]
date: 2022-07-09
GHissueID: TODO
---

:sectnums:
:stem: latexmath

:repr-c: pass:quotes[`#[repr\(C)]`]
:repr-rust: pass:quotes[`#[repr(Rust)]`]
:work: pass:quotes["`just make it work`"]

////
TODO: use appropiate benchmarks for each case, and indicate where the
improvements may occur in specific. Indicate assumptions and known bias as well.

NOTE: histogram units are nanoseconds
////

Welcome to the final article of this
https://nullderef.com/series/rust-plugins/[series]! Here I'll implement some
late-stage cleanups and optimizations so that our plugin system is ready for
deployment. These may require performing benchmarks to ensure that the changes
are actually worth it.

== Benchmarking

=== Tooling

There are all kinds of ways to measure the performance of a system, and it's
important to take as many of them as possible into account. Here are the ones I
used myself:

* *Raw metrics*: Tremor is able to measure its own raw throughput, latency
  ranges, or standard deviation. They serve as an overall score and are very
  easy to compare against eachother.
* *`perf.data`*: the command
  https://perf.wiki.kernel.org/index.php/Main_Page[`perf`] measures performance
  at runtime thanks to monitoring capabilities in the Linux kernel. It generates
  a file with the full execution trace, which can be visualized in multiple
  ways:
** https://www.brendangregg.com/flamegraphs.html[Flamegraphs]: they help
   visualize the stack traces hierarchically.
** Display the results with the integrated CLI, `perf report` (I personally used
   the `--no-children` flag as well).
* *High Dynamic Range (HDR) histograms*: Tremor also outputs its latency
  percentiles, which can later be turned into a more visual graph with
  https://hdrhistogram.github.io/HdrHistogram/plotFiles.html[this site].

There are many other methods and techniques available for benchmarking, though.
I wasn't able to get into finer details, such as checking cache misses or lower
level performance indicators. Thanks to this part of the project I've discovered
how hard it is to benchmark a program reliably; I would suggest checking out
other dedicated learning sources on the topic. It also heavily depends on the
specific program, as performance may be reported in different ways.

=== Methodology

My first issue was only having my laptop available for the benchmarks. It's a
decent machine, but caused greater variance due to the processes running on the
background, the battery status, or overheating. I was able to fix these issues
more or less, but it was quite slow and annoying to work like this. The Tremor
team helped me out by granting me access to their dedicated benchmarking server:

.Full specs of both machines
|===
|Machine |CPU |RAM |Disk |OS

|*Laptop (Dell Vostro 5481)*
|Intel i5-8265U
|16 GB @ 2667 MHz
|SSD
|Arch Linux, 5.18 kernel, 64 bits

|*Benchmarking Machine*
|Intel Xeon E-2278G
|32 GB @ 2667 MHz
|SSD
|Ubuntu 20.04, 5.4 kernel, 64 bits
|===

I ended up developing https://nullderef.com/blog/plugin-end/bench.sh[this
script] to run all the tests properly:

* It first validates the configuration, including what benchmarks to run and
  what binaries to compare. It was quite annoying to run into a typo 2 hours
  into the benchmarks...
* It performes a few warmup rounds before the actual benchmarks. This was
  specially important when I used my laptop at the beginning; the device started
  to overheat after the first few rounds, and its performance started to
  degrade.

One great way to ensure the variance isn't too high is to run the exact same
benchmark twice:

.Variance comparison with the entire setup. Unexpectedly, the server ended up being worse in that regard here, but it was good enough to continue anyway.
image::/blog/plugin-end/histogram_variance.png[]

I would strongly recommend anyone to get a separate machine to run benchmarks.
Not only will they be more reliable, but also you will be able to continue
working while the benchmarks run.

== Experiments

There were two kinds of experiments:

* Those that were always a good idea to implement. They may also clean up the
  code or make it more robust, so the experiment just checks the impact after
  implementing it.
* Those performed to come up with new optimizaton ideas.

=== Type conversions

One of my main performance concerns in the first PDK version had to do with
https://nullderef.com/blog/plugin-impl/#_reaching_reprc_blockers[the issues I
had found when trying to convert external types to the C ABI]. I had a
relatively complex type `Value` and needed to make it FFI-compatible for the
plugin system. However, it was used throughout the entire codebase, and
modifying it would've required a large amount of changes for just the initial
version. Thus, I created the copy `PdkValue` and converted to `Value` and back
when going through the FFI boundary. `PdkValue` was only used in the plugin
system context, so it required no unnecesary changes.

I was able to prove the performance impact of these conversions with some
flamegraphs:

.Flamegraph with two ``Value``s. Highlighted in pink are the occurrences of `From`, `Into`, and `FromIterator`, which add up to 9.4% of all the calls in the execution.
image::/blog/plugin-end/with_value_conv.png[]

.Flamegraph with a single `Value`. The conversion calls add up to 5.2% now, and the highlighted parts are much harder to notice.
image::/blog/plugin-end/without_value_conv.png[]

The program was spending 4.2% more of its execution time just converting between
`Value` and `PdkValue`. Thus, an obvious optimization was to fix it properly and
have a single `Value` type.

However, this also showcases one of my failures in the benchmarking process.
Initially, I was only using the `passthrough` benchmarking setup. 
TODO

* connectors vs pdk vs pdk-singlevalue

// TODO: steps may have to do with allocations: erased types with boxes??

.Ran on the laptop
image::/blog/plugin-end/histogram_pdk.png[]

[align=center, width="100%"]
|===
|Original |With `PdkValue` |Single `Value`

// |817.6k
// |545.1k
// |521.2k
|100
|66.67
|63.74
|===

=== Double `Box`

* pdk-box vs pdk-nobox

.Ran on the benchmarking server
image::/blog/plugin-end/histogram_box.png[]

// TODO: how to center this??

[align=center, width="100%"]
|===
|Double `Box` (%) |Single `Box` (%)

// |1085.1k
// |1094.0k
|100
|100.82
|===

=== Hashmap optimization

Over main branch:

// TODO:
.Ran on the benchmarking server
image::/blog/plugin-end/histogram_halfbrown.png[]

.Ran on the benchmarking server
image::/blog/plugin-end/histogram_knownkey.png[]

Second version:

image::/blog/plugin-end/histogram_pdk_v2_passthrough.png[]

image::/blog/plugin-end/histogram_pdk_v2_passthrough_two_inputs.png[]

image::/blog/plugin-end/histogram_pdk_v2_throughput_logging_json.png[]

image::/blog/plugin-end/histogram_pdk_v2_throughput_logging_msgpack.png[]


.Relative performance for number of events processed per second
|===
|Benchmark |Main (%) |No Known Key (%) |Hashbrown (%) |Halfbrown (%)

|*Passthrough*
// |1189.5
// |920.6
// |842.9
// |908.0
|100
|77.39
|70.86
|76.33

|*Passthrough Two Inputs*
// |938.2
// |660.0
// |645.2
// |654.7
|100
|70.34
|68.76
|69.78

|*Throughput Logging JSON*
// |556.8
// |365.1
// |385.4
// |364.6
|100
|65.57
|69.21
|64.48

|*Throughput Logging MsgPack*
// |600.2
// |400.2
// |424.3
// |393.3
|100
|66.66
|70.69
|65.52

|*Average*
|100
|69.99
|69.88
|69.02
|===

=== `abi_stable`

I also tried to figure out what bottlenecks had been introduced by `abi_stable`
specifically. Apart from the type validation step before loading a plugin, it
included many other overheads, including more complex destructors. The `Drop`
implementation had to access a vtable and, in cases like `RBox`, deal with
additional logic.

.``abi_stable``'s complex destructors, shown in pink.
image::/blog/plugin-end/with_destructor.png[]

I thought these were going to be more relevant than they were. Once I zoomed
out, there was almost no trace of destructors:

.``abi_stable``'s complex destructors, globally.
image::/blog/plugin-end/with_destructor_globally.png[]

This was one of my many attempts that ended up not being worth continuing to
look into, or at least for now. There are many other ways to measure
``abi_stable``'s performance impact, but I wasn't able to look into it more.

== Other ideas

Unfortunately, I'm unable to continue this investigation, as I've already been
involved with Tremor for almost a year. I will soon start working somewhere
else and face a completely different set of problems. Here are some ideas I had
to improve the plugin system:

=== Dive deeper into benchmark results

=== Investigate wrappers overhead

=== Improve error handling and reporting

=== Use `TD_Opaque` instead of `TD_CanDowncast`

This one is specific to `abi_stable` users.

=== Create a dedicated crate for the plugin system interface

=== Merge and simplify opaque types

=== Simplify the interface further

=== Benchmark `async_ffi`

=== Investigate async runtime conflicts

Check what happens when plugin uses different async runtime from the main
  executable

=== Improve cross-platform support

=== Performance impact of panic handling

`abi_stable` has to track all panic occurrences so that they didn't pass through
the FFI boundary. Otherwise, as we discussed previously, we would be invoking
undefined behaviour.


=== Use `-Zrandomize-layout` to find FFI bugs

=== Optimize backward compatibility

Add `last_prefix_field` for backward compatibility


=== Extend the plugin system to more components

== Conclusion

* Throughput degraded by 35% initially
* Latency had also been affected considerably at every percentile (TODO insert
  histogram here)
* After X iterations, throughput was degraded only by Y%.

I won't be able and work on most of these ideas myself before releasing the
plugin system into its first version in production. If everything goes well, the
Tremor team will take care of it. I look forward to seeing how the plugin system
continues to evolve with the program!

== Thanks

// TODO: Link to Annex I
Lastly, I've found it especially rewarding to do all of this in an open source
environment. Even if you're working for a company with propietary software,
please try to contribute upstream instead of forking or patching. Try to be nice
to those who are saving you so much work, and submit a PR or an issue:

[bibliography]
== References

- [[[empty,      1]]] http://google.com

[appendix]
== Open Source Contributions

One of my favorite parts of the project has been contributing so much to all
kinds of open source dependencies, so I've maintained a list of its occurrences.
Some are more important than others, but it's still a decent metric for my
results. This skips the issues or pull requests that:

* Contributed nothing (e.g., asking questions or discarded ideas).
* Were repetitive (e.g., I made a few identical PRs in Tremor when I was fixing
  problems with Git).

=== External Contributions

These include repositories not directly related to Tremor:

. {{< gh issue "rust-lang/nomicon" 338 "Subtyping and Variance - Trait variance not covered" >}}
. {{< gh issue "szymonwieloch/rust-dlopen" 42 "`dlerror` *is* thread-safe on some platforms" >}}
. {{< gh issue "wasmerio/wasmer" 2539 "Add deprecation notice to the crate `wasmer-runtime`" >}}
. {{< gh pr "oxalica/async-ffi" 10 "Support for `abi_stable`" >}}
. {{< gh pr "oxalica/async-ffi" 11 "Cbindgen support" >}}
. {{< gh issue "oxalica/async-ffi" 12 "Procedural macro for boilerplate" >}}
. {{< gh issue "rodrimati1992/abi_stable_crates" 52 "Generating C bindings" >}}
. {{< gh issue "rodrimati1992/abi_stable_crates" 60 "Stable ABI for floating point numbers" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 55 "Fix 'carte' typo" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 57 "Fix some more typos" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 58 "Add support for .keys() and .values() in RHashMap" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 59 "Implement `Index` for slices and vectors" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 61 "Support for `f32` and `f64`" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 68 "Implement `ROption::as_deref`" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 70 "Implement `RVec::append`" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 76 "Fix `R*` lifetimes" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 77 "Fix inconsistencies with `RVec` in respect to `Vec`" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 82 "Implement `ROption::{ok_or,ok_or_else}`" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 83 "`RHashMap::raw_entry[_mut]` support" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 85 "Fix hasher" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 88 "Only implement `Default` once" >}}
. {{< gh pr "simd-lite/simd-json-derive" 9 "Support for `abi_stable`" >}}
. {{< gh issue "simd-lite/simd-json-derive" 10 "No docs for v0.3.0" >}}
. {{< gh pr "simd-lite/value-trait" 14 "Add support for StableAbi" >}}
. {{< gh pr "simd-lite/value-trait" 16 "User friendliness for the win! (close #15)" >}}
. {{< gh pr "simd-lite/value-trait" 18 "Update abi_stable after upstreamed changes" >}}
. {{< gh pr "nagisa/rust_libloading" 94 "Small typo" >}}
. {{< gh pr "szymonwieloch/rust-dlopen" 40 "Fix typo" >}}
. {{< gh pr "Licenser/halfbrown" 13 "Implement `remove_entry`" >}}
. {{< gh pr "Licenser/halfbrown" 14 "Implement `Clone` and `Debug` for `Iter`" >}}
. {{< gh pr "Licenser/halfbrown" 16 "Relax constraints" >}}
. {{< gh pr "Licenser/halfbrown" 17 "Same `Default` constraints" >}}
. {{< gh pr "Licenser/halfbrown" 18 "Fix `Clone` requirements for `Iter`" >}}

=== Internal Contributions

Here are the issues and pull requests created within Tremor's repositories,
including those for the PDK and other unrelated improvements:

. {{< gh pr "tremor-rs/tremor-runtime" 1434 "PDK support" >}}
. {{< gh pr "marioortizmanero/tremor-runtime" 11 "PDK with a single value" >}}
. {{< gh pr "tremor-rs/tremor-runtime" 1447 "Fix `makefile bench`" >}}
. {{< gh pr "marioortizmanero/tremor-runtime" 2 "Adding `abi_stable` support for `tremor-script`" >}} (second attempt)
. {{< gh pr "marioortizmanero/tremor-runtime" 1 "Adding `abi_stable` support for `tremor-runtime`" >}} (second attempt)
. {{< gh pr "tremor-rs/tremor-runtime" 1303 "Adding `abi_stable` support for `tremor-value`" >}} (second attempt)
. {{< gh pr "tremor-rs/tremor-runtime" 1287 "Plugin Development Kit: Connectors" >}} (first attempt)
. {{< gh issue "tremor-rs/tremor-runtime" 1353 "`deny` statemements in `lib.rs` should be enforced in the CI rather than in the code" >}}
. {{< gh issue "tremor-rs/tremor-runtime" 1812 "`KnownKey` relies on a deterministic hash builder" >}}
. {{< gh pr "tremor-rs/tremor-www" 72 "Fix wrong links in getting started" >}}
. {{< gh issue "tremor-rs/tremor-www" 73 "Redirect `docs.tremor.rs` to `www.tremor.rs/docs`" >}}
. {{< gh pr "tremor-rs/tremor-www" 186 "Links pinned to 0.12 don't work" >}}
. {{< gh pr "tremor-rs/tremor-www" 187 "Small fix in code snippet" >}}
. {{< gh issue "tremor-rs/tremor-www" 195 "No margins in benchmark page" >}}
. {{< gh pr "tremor-rs/tremor-www" 219 "Fix typos in benchmarks page" >}}

[appendix]
== Other Achievements

=== Breaking the Compiler

I also managed to break the Rust compiler while working on this plugin system.
It may not be as rare as one would think, but for some reason I felt oddly proud
to achieve it, so I'll share it here :)

image::/blog/plugin-end/rustc_crash.png[width=100%, align=center]

It's seemingly related to incremental compilation, and
https://github.com/rust-lang/rust/issues/90608[someone had already reported it
before]. It should be fixed in a future version, and I haven't come across it
again.

=== LFX Mentorship Showcase

I already shared this in a previous article, but for completeness I'll repeat it
here. This online event made it possible to showcase my work back in January
with a https://youtu.be/htLCyqY0kt0?t=3166[quick 15-minute presentation]. I
couldn't get into many technical details, but I'm sure it will be useful to
someone else considering a https://lfx.linuxfoundation.org/tools/mentorship/[LFX
Mentorship] or https://summerofcode.withgoogle.com/[Google Summer of Code].

=== My Final Year Project

Finally, I have recently submitted this as
https://github.com/marioortizmanero/final-year-project[my bachelor's Final Year
Project]. It takes a more academic approach, and I rigorously reorganized
everything so that even developers unfamiliar with Rust can understand it. The
abstract is in English, but unfortunately, the rest is in Spanish due to absurd
university rules.

=== KubeCon + CloudNativeCon 2022

Thanks to the Tremor team, I was also able to presentially attend
https://events.linuxfoundation.org/kubecon-cloudnativecon-europe/[KubeCon +
CloudNativeCon] 2022 in Valencia, Spain! It was my first conference and I was
very pleasantly surprised by how nice everyone was. I had tons of fun and met
smart folk with all kinds of backgrounds. If you're on the fence about attending
something similar, I strongly recommend you to go for it!

.Paella! https://www.linkedin.com/feed/update/urn:li:share:6934450596049539072[From my LinkedIn profile].
image::/blog/plugin-end/paella.jpg[width=50%, align=center]
