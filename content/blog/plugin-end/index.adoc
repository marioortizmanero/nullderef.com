---
title: "Plugins in Rust: Preparing for Deployment"
description: "The last finishing touches to the plugin system so that it can be
released in Tremor's new version"
author: "Mario Ortiz Manero"
tags: ["rust", "rustlang", "plugin", "benchmarking", "testing", "deployment"]
series: ["rust-plugins"]
date: 2021-11-09
GHissueID: TODO
---

:sectnums:
:stem: latexmath

:repr-c: pass:quotes[`#[repr\(C)]`]
:work: pass:quotes["`just make it work`"]

////
TODO: use appropiate benchmarks for each case, and indicate where the
improvements may occur in specific. Indicate assumptions and known bias as well.

real world: throughput-logging-json
////

This final article will focus mostly on getting our plugin system ready for
deployment. This means verifying the behaviour is what we expect, and
benchmarking thoroughly to ensure the performance demands are met.

== Benchmarking process

Before running any benchmarks, we should ensure our process is appropiate so
that we will get precise results.

=== Measuring performance

* Flamegraph
* `perf.data`: `perf report --no-children -i FILE`: reduced `memmove` doesn't
  mean there's more move necessarily, just that something else got slower. Tip:
  take a screenshot and draw lines. TODO: look into what kernel.kallsyms and
  similars are.
* Raw metrics: throughput, maximum and minimum latency, standard deviation, etc.
* https://hdrhistogram.github.io/HdrHistogram/plotFiles.html[Visual histograms]

=== Hardware availability

My first issue was that the only machine that I currently have available for
free is a laptop. It's not too bad, but it's not the best thing for
benchmarking. I had to close all the programs that were open before running
anything, and it often throttled.

The Tremor team ended up helping me out by adding me to the dedicated
benchmarking server they have. This made the process much easier, and more
accurate.

One great way to ensure the result variance is too high is to run the exact same
benchmark twice after all the initial setup:

// TODO: make names shorter

image::/blog/plugin-end/histogram_variance.png[]

=== Running the benchmarks

I started with just a few command line instructions and ended up with a
decently-sized bash script:

* It validated the configuration (the chosen benchmarks and binaries) before
  running anything. This way I avoided waiting for half an hour for the
  benchmarks to finish, only to find an error in one of them and have to start
  from scratch.
* It performed a few warmup rounds before the actual benchmarks. This was
  specially important when I used my laptop at the beginning; the first few runs
  were the fastest, but as the device started to overhead, its performance
  degraded considerably.

.Variance when ran on the laptop without warming up
image::/blog/plugin-end/histogram_variance_laptopnowarmup.png[]

[source]
----
# TODO: mention `bench.sh` script
$ sudo env "PATH=$PATH" ./bench.sh
----

== Results

These were performed iteratively. The speed should improve as more and more
experiments are done.

=== Experiments

==== Conversions

.Converting ``Value``s
image::/blog/plugin-end/with_value_conv.png[]

.Not converting ``Value``s
image::/blog/plugin-end/without_value_conv.png[]

.Half the execution time of `on_event` was `Value` conversions
image::/blog/plugin-end/perf_event_conv.png[]

.Percentage of cycles wasted on `Value` conversions
image::/blog/plugin-end/cycles_into_value.png[]

.Percentage of cycles wasted on `ValueAndMeta` conversions
image::/blog/plugin-end/cycles_into_valueandmeta.png[]

According to the flamegraph 7% of the execution time was just conversions
between regular and PDK types (TODO insert screenshot with search)

==== `abi_stable`

.Using `abi_stable`
image::/blog/plugin-end/with_abi_stable.png[]

.Not using `abi_stable`
image::/blog/plugin-end/without_abi_stable.png[]

.Specifically, ``abi_stable``'s complex destructors
image::/blog/plugin-end/with_destructor.png[]

.Specifically, ``abi_stable``'s complex destructors, globally
image::/blog/plugin-end/with_destructor_globally.png[]

==== Change of HashMap

.Using `RHashMap`
image::/blog/plugin-end/with_rhashmap.png[]

.Using `RHashMap`, globally
image::/blog/plugin-end/with_rhashmap_globally.png[]

.Not using `RHashMap`
image::/blog/plugin-end/without_rhashmap.png[]

.Not using `RHashMap`, globally
image::/blog/plugin-end/without_rhashmap_globally.png[]

=== Initial PDK impact

* connectors vs pdk vs pdk-singlevalue

// TODO: steps may have to do with allocations: erased types with boxes??

.Ran on the laptop
image::/blog/plugin-end/histogram_pdk.png[]

=== Double box impact

* pdk-box vs pdk-nobox

.Ran on the benchmarking server
image::/blog/plugin-end/histogram_box.png[]

=== Hashmap optimization impact

* pdk-hashbrown vs pdk-halfbrown
* knownkey vs noknownkey

// TODO: mention how the passthrough benchmark isn't enough; passthrough:
// optimal case.

// TODO:
.Ran on the benchmarking server
image::/blog/plugin-end/histogram_halfbrown.png[]

.Ran on the benchmarking server
image::/blog/plugin-end/histogram_knownkey.png[]

== Conclusion

* Throughput degraded by 35% initially
* Latency had also been affected considerably at every percentile (TODO insert
  histogram here)
* After X iterations, throughput was degraded only by Y%.

== Thanks

// TODO: Link to Annex I
Lastly, I've found it especially rewarding to do all of this in an open source
environment. Even if you're working for a company with propietary software,
please try to contribute upstream instead of forking or patching. Try to be nice
to those who are saving you so much work, and submit a PR or an issue:

[bibliography]
== References

- [[[empty,      1]]] http://google.com

== Appendix I: Contributions

// LAST UPDATE: 09-02-2022
// TODO: use GitHub shortcodes
// TODO: count and add like "Pull Requests (14):"

I've been keeping track of the contributions I made as a reference and out of
curiosity. Some of them are more important than others, but it's still a decent
metric for the results of the mentorship, in my opinion. This skips the issues
or pull requests that:

* Contributed nothing (e.g., asking questions or discarded ideas).
* Were repetitive (e.g., I made a few identical PRs in Tremor when I was fixing
  problems with Git).

////
TODO: Maybe remove typo fixing as well, or list separately?
* abi_stable#55
* abi_stable#57
* libloading#94
* tremor-www#72
* dlopen#40
////

////
NOTE: dirty & quick script for parsing URLs to macros, requires PyGithub:

import re
import fileinput
from github import Github

URL_REGEX = r'https?://github\.com/([\w_-]+/[\w_-]+)/(\w+)/(\d+)'
AUTH = 'TODO'


def get_kind(base: str, state: str) -> str:
    if base == 'pull':
        return 'pr'
    else:
        return 'issue'


g = Github(AUTH)

for url in fileinput.input():
    matches = re.search(URL_REGEX, url)
    if matches is None:
        print(f"`{url}` isn't an URL, skipping...")
        continue

    repo_name = matches.group(1)
    kind_base = matches.group(2)
    number = int(matches.group(3))

    repo = g.get_repo(repo_name)
    issue = repo.get_issue(number=number)
    kind = get_kind(kind_base, issue.state)
    print(f"{{{{< gh {kind} \"{repo_name}\" {number} \"{issue.title}\" >}}}}")
////

External:

* {{< gh issue "rust-lang/nomicon" 338 "Subtyping and Variance - Trait variance not covered" >}}
* {{< gh issue "szymonwieloch/rust-dlopen" 42 "`dlerror` *is* thread-safe on some platforms" >}}
* {{< gh issue "wasmerio/wasmer" 2539 "Add deprecation notice to the crate `wasmer-runtime`" >}}
* {{< gh pr "oxalica/async-ffi" 10 "Support for `abi_stable`" >}}
* {{< gh pr "oxalica/async-ffi" 11 "Cbindgen support" >}}
* {{< gh issue "oxalica/async-ffi" 12 "Procedural macro for boilerplate" >}}
* {{< gh issue "rodrimati1992/abi_stable_crates" 52 "Generating C bindings" >}}
* {{< gh issue "rodrimati1992/abi_stable_crates" 60 "Stable ABI for floating point numbers" >}}
* {{< gh pr "rodrimati1992/abi_stable_crates" 55 "Fix 'carte' typo" >}}
* {{< gh pr "rodrimati1992/abi_stable_crates" 57 "Fix some more typos" >}}
* {{< gh pr "rodrimati1992/abi_stable_crates" 58 "Add support for .keys() and .values() in RHashMap" >}}
* {{< gh pr "rodrimati1992/abi_stable_crates" 59 "Implement `Index` for slices and vectors" >}}
* {{< gh pr "rodrimati1992/abi_stable_crates" 61 "Support for `f32` and `f64`" >}}
* {{< gh pr "rodrimati1992/abi_stable_crates" 68 "Implement `ROption::as_deref`" >}}
* {{< gh pr "rodrimati1992/abi_stable_crates" 70 "Implement `RVec::append`" >}}
* {{< gh pr "rodrimati1992/abi_stable_crates" 76 "Fix `R*` lifetimes" >}}
* {{< gh pr "rodrimati1992/abi_stable_crates" 77 "Fix inconsistencies with `RVec` in respect to `Vec`" >}}
* {{< gh pr "rodrimati1992/abi_stable_crates" 82 "Implement `ROption::{ok_or,ok_or_else}`" >}}
* {{< gh pr "rodrimati1992/abi_stable_crates" 83 "`RHashMap::raw_entry[_mut]` support" >}}
* {{< gh pr "rodrimati1992/abi_stable_crates" 85 "Fix hasher" >}}
* {{< gh pr "rodrimati1992/abi_stable_crates" 88 "Only implement `Default` once" >}}
* {{< gh pr "simd-lite/simd-json-derive" 9 "Support for `abi_stable`" >}}
* {{< gh issue "simd-lite/simd-json-derive" 10 "No docs for v0.3.0" >}}
* {{< gh pr "simd-lite/value-trait" 14 "Add support for StableAbi" >}}
* {{< gh pr "simd-lite/value-trait" 16 "User friendliness for the win! (close #15)" >}}
* {{< gh pr "simd-lite/value-trait" 18 "Update abi_stable after upstreamed changes" >}}
* {{< gh pr "nagisa/rust_libloading" 94 "Small typo" >}}
* {{< gh pr "szymonwieloch/rust-dlopen" 40 "Fix typo" >}}
* {{< gh pr "Licenser/halfbrown" 13 "Implement `remove_entry`" >}}
* {{< gh pr "Licenser/halfbrown" 14 "Implement `Clone` and `Debug` for `Iter`" >}}
* {{< gh pr "Licenser/halfbrown" 16 "Relax constraints" >}}
* {{< gh pr "Licenser/halfbrown" 17 "Same `Default` constraints" >}}
* {{< gh pr "Licenser/halfbrown" 18 "Fix `Clone` requirements for `Iter`" >}}

Internal:

* {{< gh pr "tremor-rs/tremor-runtime" 1434 "PDK support" >}}
* {{< gh pr "marioortizmanero/tremor-runtime" 11 "PDK with a single value" >}}
* {{< gh pr "tremor-rs/tremor-runtime" 1447 "Fix `makefile bench`" >}}
* {{< gh pr "marioortizmanero/tremor-runtime" 2 "Adding `abi_stable` support for `tremor-script`" >}} (second attempt)
* {{< gh pr "marioortizmanero/tremor-runtime" 1 "Adding `abi_stable` support for `tremor-runtime`" >}} (second attempt)
* {{< gh pr "tremor-rs/tremor-runtime" 1303 "Adding `abi_stable` support for `tremor-value`" >}} (second attempt)
* {{< gh pr "tremor-rs/tremor-runtime" 1287 "Plugin Development Kit: Connectors" >}} (first attempt)
* {{< gh issue "tremor-rs/tremor-runtime" 1353 "`deny` statemements in `lib.rs` should be enforced in the CI rather than in the code" >}}
* {{< gh pr "tremor-rs/tremor-www" 72 "Fix wrong links in getting started" >}}
* {{< gh issue "tremor-rs/tremor-www" 73 "Redirect `docs.tremor.rs` to `www.tremor.rs/docs`" >}}
* {{< gh pr "tremor-rs/tremor-www" 186 "Links pinned to 0.12 don't work" >}}
* {{< gh pr "tremor-rs/tremor-www" 187 "Small fix in code snippet" >}}
* {{< gh issue "tremor-rs/tremor-www" 195 "No margins in benchmark page" >}}

I also managed to break the compiler while working on this plugin system. It may
not be as rare as one would think, but for some reason I felt oddly proud to
achieve it, so I'll share it here :)

image::/blog/plugin-end/rustc_crash.png[width=100%, align=center]

It's seemingly related to incremental compilation and
https://github.com/rust-lang/rust/issues/90608[already reported on their GitHub
repo].
