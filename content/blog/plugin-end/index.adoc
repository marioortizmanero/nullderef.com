---
title: "Plugins in Rust: Wrapping Up"
description: "The last finishing touches to the plugin system so that it can be
released in Tremor's new version"
author: "Mario Ortiz Manero"
tags: ["rust", "rustlang", "plugin", "benchmarking", "testing", "deployment"]
series: ["rust-plugins"]
date: 2022-07-09
GHissueID: TODO
---

:sectnums:
:stem: latexmath

:repr-c: pass:quotes[`#[repr\(C)]`]
:repr-rust: pass:quotes[`#[repr(Rust)]`]
:work: pass:quotes["`just make it work`"]

////
TODO: use appropiate benchmarks for each case, and indicate where the
improvements may occur in specific. Indicate assumptions and known bias as well.

NOTE: histogram units are nanoseconds
////

Welcome to the final article of this
https://nullderef.com/series/rust-plugins/[series]! Here I'll clean up and
optimize our plugin system so that it's ready for deployment. These may require
performing benchmarks to ensure that the changes are actually worth it.

== Benchmarking

=== Tooling

There are all kinds of ways to measure the performance of a system, and it's
important to take as many of them as possible into account. Here are the ones I
used myself:

* *Raw metrics*: Tremor is able to measure its own raw throughput, latency
  ranges, or standard deviation. They serve as an overall score and are very
  easy to compare against eachother.
* *`perf.data`*: the command
  https://perf.wiki.kernel.org/index.php/Main_Page[`perf`] measures performance
  at runtime thanks to monitoring capabilities in the Linux kernel. It generates
  a file with the full execution trace, which can be visualized in multiple
  ways, including:
** https://www.brendangregg.com/flamegraphs.html[Flamegraphs]: hierarchical and
   simple graphs.
** `perf report`: the integrated CLI, which is more detailed but harder to
   understand.
* *High Dynamic Range (HDR) histograms*: Tremor's latency percentiles can be
  turned into a graph with
  https://hdrhistogram.github.io/HdrHistogram/plotFiles.html[this site].

There are many other techniques available for benchmarking, though. I wasn't
able to get into lower level performance indicators like cache misses.

This part of the project has helped me realize how hard it is to benchmark a
program reliably; I would suggest checking out other dedicated learning sources
on the topic. You should also tune the process according to your use-case, since
it may vary heavily between programs.

=== Methodology

My first issue was only having my laptop available for the benchmarks. It's a
decent machine, but it caused greater variance in the results, and it wasn't
very productive, since I had to stop everything I was doing to exclusively run
them. The Tremor team helped me out by granting me access to their dedicated
benchmarking server:

.Full specs of both machines, for reference
|===
|Machine |CPU |RAM |Disk |Operating System

|*Laptop (Dell Vostro 5481)*
|Intel i5-8265U
|16 GB @ 2667 MHz
|SSD
|Arch Linux, 5.18 kernel, 64 bits

|*Benchmarking Machine*
|Intel Xeon E-2278G
|32 GB @ 2667 MHz
|SSD
|Ubuntu 20.04, 5.4 kernel, 64 bits
|===

I ended up developing https://nullderef.com/blog/plugin-end/bench.sh[a custom
script] to run all the tests properly:

* It first validates the configuration, including what benchmarks to run and
  what binaries to compare. It was quite annoying to run into a typo 2 hours
  into the benchmarks...
* It performs a few warmup rounds before the actual benchmarks. This was
  specially important when using my laptop, since it started to overheat after
  the first few rounds, degrading its performance.

One way to ensure the variance isn't too high is to run the exact same benchmark
twice:

.Histogram for both machines. Unexpectedly, the server ended up having greater variance with this test, but it was good enough to continue anyway.
image::/blog/plugin-end/histogram_variance.png[]

I would strongly recommend anyone to get a separate machine to run benchmarks.
Not only will they be more reliable, but also you will be able to continue
working while the benchmarks run.

== Experiments

We can divide that experiments in two categories:

. _For tracking_: this change is always going to be a good idea, because it may
  also clean up the code or make it more robust. We just measure its performance
  impact to report the results and avoid surprises.
. _For investigation_: the change increases the complexity to explicitly improve
  performance, so we need to make sure it's worth our time. This improvement may
  occur directly with the change, or indirectly, by helping to come up with
  other optimizations.

Benchmarking is only essential in the latter, but I thought it would be a great
idea in both cases to fully understand the impact of the change. It also makes
it possible to write up a report like this article, explaining the improvements
I worked on.

=== Type conversions

The most important performance concern in the first PDK version had to do with
https://nullderef.com/blog/plugin-impl/#_reaching_reprc_blockers[the issues I
had found when trying to convert external types to the C ABI]. In short, I had a
relatively complex type `Value` and needed to make it FFI-compatible for the
plugin system. However, it was used throughout the entire codebase, and
modifying it would've required a large amount of changes for just the initial
version. Thus, I created the copy `PdkValue` and converted to `Value` and back
when going through the FFI boundary. `PdkValue` was only used for the plugin
system, making it quite easy to implement in contrast.

An obvious experiment was to fix this problem properly by making `Value`
FFI-compatible and removing `PdkValue`. Unless the performance degraded
considerably, this was always going to be a great change because it simplifies
the code.

After the fix, I was able to investigate about the impact of these conversions
with some flamegraphs:

.With both `Value` and `PdkValue`. Highlighted in pink are the occurrences of `From`, `Into`, and `FromIterator`, which add up to 9.4% of all the calls in the execution.
image::/blog/plugin-end/with_value_conv.png[]

.With a single `Value`. The conversion calls add up to 5.2% now, and the highlighted parts are much harder to notice.
image::/blog/plugin-end/without_value_conv.png[]

The flamegraphs pointed out that Tremor was spending roughly 4.2% more of its
execution time just converting between `Value` and `PdkValue`. This metric is
tricky, though. Spending less time on type conversions doesn't mean that the
overall program is faster. The percentages are relative to the specific
execution, and it's possible that the rest of the program just got slower in the
case of a single `Value`.

By checking other metrics we discover that this is more or less the case. The
histogram shows that a single `Value` improves the latency, but the overall
throughput actually decreases:

.Histogram without the PDK (`connectors` branch) vs. first version vs. single `Value`.
image::/blog/plugin-end/histogram_pdk.png[]

// TODO: how to center this table?

.Relative throughput comparison
[align=center, width="100%"]
|===
|No PDK (%) |With `PdkValue` (%) |Single `Value` (%)

// |817.6k
// |545.1k
// |521.2k
|100
|66.67
|63.74
|===

However, this showcases one of my initial mistakes. My comparison only used the
`passthrough` benchmark, which simply forwards all input events to the output.
For a more realistic use-case, I should've tried with other configurations,
which may include different payloads or event processing logic.

Anyway, the results make sense to some degree. Converting `Value` to an
FFI-compatible type requires using, e.g., `RHashMap` instead of `HashMap`
internally. Tremor's `HashMap` was taken from the {{< crate halfbrown >}} crate,
which was more performant than the standard library version, and much more than
``abi_stable``'s. Converting between types might actually be faster than using
less performant types internally.

=== Double `Box`

* pdk-box vs pdk-nobox

.Note that this test was run on the benchmarking server, while the previous one used my laptop. These tests aren't meant to be compared between different sections.
image::/blog/plugin-end/histogram_box.png[]

// TODO: how to center this??

[align=center, width="100%"]
|===
|Double `Box` (%) |Single `Box` (%)

// |1085.1k
// |1094.0k
|100
|100.82
|===

=== Hashmap optimization

Over main branch:

// TODO:
.Ran on the benchmarking server
image::/blog/plugin-end/histogram_halfbrown.png[]

.Ran on the benchmarking server
image::/blog/plugin-end/histogram_knownkey.png[]

Second version:

image::/blog/plugin-end/histogram_pdk_v2_passthrough.png[]

image::/blog/plugin-end/histogram_pdk_v2_passthrough_two_inputs.png[]

image::/blog/plugin-end/histogram_pdk_v2_throughput_logging_json.png[]

image::/blog/plugin-end/histogram_pdk_v2_throughput_logging_msgpack.png[]


.Relative performance for number of events processed per second
|===
|Benchmark |No PDK (%) |No Known Key (%) |Hashbrown (%) |Halfbrown (%)

|*Passthrough*
// |1189.5
// |920.6
// |842.9
// |908.0
|100
|77.39
|70.86
|76.33

|*Passthrough Two Inputs*
// |938.2
// |660.0
// |645.2
// |654.7
|100
|70.34
|68.76
|69.78

|*Throughput Logging JSON*
// |556.8
// |365.1
// |385.4
// |364.6
|100
|65.57
|69.21
|64.48

|*Throughput Logging MsgPack*
// |600.2
// |400.2
// |424.3
// |393.3
|100
|66.66
|70.69
|65.52

|*Average*
|100
|69.99
|69.88
|69.02
|===

=== `abi_stable`

I also tried to figure out what bottlenecks had been introduced by `abi_stable`
specifically. Apart from the type validation step before loading a plugin, it
included many other overheads, including more complex destructors. The `Drop`
implementation had to access a vtable and, in cases like `RBox`, deal with
additional logic.

.``abi_stable``'s complex destructors, shown in pink.
image::/blog/plugin-end/with_destructor.png[]

I thought these were going to be more relevant than they were. Once I zoomed
out, there was almost no trace of destructors:

.``abi_stable``'s complex destructors, globally.
image::/blog/plugin-end/with_destructor_globally.png[]

This was one of my many attempts that ended up not being worth continuing to
look into, or at least for now. There are many other ways to measure
``abi_stable``'s performance impact, but I wasn't able to look into it more.

== Other ideas

Unfortunately, I'm unable to continue this investigation, as I've already been
involved with Tremor for almost a year. I will soon start working somewhere
else and face a completely different set of problems. Here are some ideas I had
to improve the plugin system:

=== Dive deeper into benchmark results

=== Investigate wrappers overhead

=== Improve error handling and reporting

=== Use `TD_Opaque` instead of `TD_CanDowncast`

This one is specific to `abi_stable` users.

=== Create a dedicated crate for the plugin system interface

=== Merge and simplify opaque types

=== Simplify the interface further

=== Benchmark `async_ffi`

=== Investigate async runtime conflicts

Check what happens when plugin uses different async runtime from the main
  executable

=== Improve cross-platform support

=== Performance impact of panic handling

`abi_stable` has to track all panic occurrences so that they didn't pass through
the FFI boundary. Otherwise, as we discussed previously, we would be invoking
undefined behaviour.


=== Use `-Zrandomize-layout` to find FFI bugs

=== Optimize backward compatibility

Add `last_prefix_field` for backward compatibility


=== Extend the plugin system to more components

== Conclusion

* Throughput degraded by 35% initially
* Latency had also been affected considerably at every percentile (TODO insert
  histogram here)
* After X iterations, throughput was degraded only by Y%.

I won't be able and work on most of these ideas myself before releasing the
plugin system into its first version in production. If everything goes well, the
Tremor team will take care of it. I look forward to seeing how the plugin system
continues to evolve with the program!

== Thanks

// TODO: Link to Annex I
Lastly, I've found it especially rewarding to do all of this in an open source
environment. Even if you're working for a company with propietary software,
please try to contribute upstream instead of forking or patching. Try to be nice
to those who are saving you so much work, and submit a PR or an issue:

[bibliography]
== References

- [[[empty,      1]]] http://google.com

[appendix]
== Open Source Contributions

One of my favorite parts of the project has been contributing so much to all
kinds of open source dependencies, so I've maintained a list of its occurrences.
Some are more important than others, but it's still a decent metric for my
results. This skips the issues or pull requests that:

* Contributed nothing (e.g., asking questions or discarded ideas).
* Were repetitive (e.g., I made a few identical PRs in Tremor when I was fixing
  problems with Git).

=== External Contributions

These include repositories not directly related to Tremor:

. {{< gh issue "rust-lang/nomicon" 338 "Subtyping and Variance - Trait variance not covered" >}}
. {{< gh issue "szymonwieloch/rust-dlopen" 42 "`dlerror` *is* thread-safe on some platforms" >}}
. {{< gh issue "wasmerio/wasmer" 2539 "Add deprecation notice to the crate `wasmer-runtime`" >}}
. {{< gh pr "oxalica/async-ffi" 10 "Support for `abi_stable`" >}}
. {{< gh pr "oxalica/async-ffi" 11 "Cbindgen support" >}}
. {{< gh issue "oxalica/async-ffi" 12 "Procedural macro for boilerplate" >}}
. {{< gh issue "rodrimati1992/abi_stable_crates" 52 "Generating C bindings" >}}
. {{< gh issue "rodrimati1992/abi_stable_crates" 60 "Stable ABI for floating point numbers" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 55 "Fix 'carte' typo" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 57 "Fix some more typos" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 58 "Add support for .keys() and .values() in RHashMap" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 59 "Implement `Index` for slices and vectors" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 61 "Support for `f32` and `f64`" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 68 "Implement `ROption::as_deref`" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 70 "Implement `RVec::append`" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 76 "Fix `R*` lifetimes" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 77 "Fix inconsistencies with `RVec` in respect to `Vec`" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 82 "Implement `ROption::{ok_or,ok_or_else}`" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 83 "`RHashMap::raw_entry[_mut]` support" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 85 "Fix hasher" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 88 "Only implement `Default` once" >}}
. {{< gh pr "simd-lite/simd-json-derive" 9 "Support for `abi_stable`" >}}
. {{< gh issue "simd-lite/simd-json-derive" 10 "No docs for v0.3.0" >}}
. {{< gh pr "simd-lite/value-trait" 14 "Add support for StableAbi" >}}
. {{< gh pr "simd-lite/value-trait" 16 "User friendliness for the win! (close #15)" >}}
. {{< gh pr "simd-lite/value-trait" 18 "Update abi_stable after upstreamed changes" >}}
. {{< gh pr "nagisa/rust_libloading" 94 "Small typo" >}}
. {{< gh pr "szymonwieloch/rust-dlopen" 40 "Fix typo" >}}
. {{< gh pr "Licenser/halfbrown" 13 "Implement `remove_entry`" >}}
. {{< gh pr "Licenser/halfbrown" 14 "Implement `Clone` and `Debug` for `Iter`" >}}
. {{< gh pr "Licenser/halfbrown" 16 "Relax constraints" >}}
. {{< gh pr "Licenser/halfbrown" 17 "Same `Default` constraints" >}}
. {{< gh pr "Licenser/halfbrown" 18 "Fix `Clone` requirements for `Iter`" >}}

=== Internal Contributions

Here are the issues and pull requests created within Tremor's repositories,
including those for the PDK and other unrelated improvements:

. {{< gh pr "tremor-rs/tremor-runtime" 1434 "PDK support" >}}
. {{< gh pr "marioortizmanero/tremor-runtime" 11 "PDK with a single value" >}}
. {{< gh pr "tremor-rs/tremor-runtime" 1447 "Fix `makefile bench`" >}}
. {{< gh pr "marioortizmanero/tremor-runtime" 2 "Adding `abi_stable` support for `tremor-script`" >}} (second attempt)
. {{< gh pr "marioortizmanero/tremor-runtime" 1 "Adding `abi_stable` support for `tremor-runtime`" >}} (second attempt)
. {{< gh pr "tremor-rs/tremor-runtime" 1303 "Adding `abi_stable` support for `tremor-value`" >}} (second attempt)
. {{< gh pr "tremor-rs/tremor-runtime" 1287 "Plugin Development Kit: Connectors" >}} (first attempt)
. {{< gh issue "tremor-rs/tremor-runtime" 1353 "`deny` statemements in `lib.rs` should be enforced in the CI rather than in the code" >}}
. {{< gh issue "tremor-rs/tremor-runtime" 1812 "`KnownKey` relies on a deterministic hash builder" >}}
. {{< gh pr "tremor-rs/tremor-www" 72 "Fix wrong links in getting started" >}}
. {{< gh issue "tremor-rs/tremor-www" 73 "Redirect `docs.tremor.rs` to `www.tremor.rs/docs`" >}}
. {{< gh pr "tremor-rs/tremor-www" 186 "Links pinned to 0.12 don't work" >}}
. {{< gh pr "tremor-rs/tremor-www" 187 "Small fix in code snippet" >}}
. {{< gh issue "tremor-rs/tremor-www" 195 "No margins in benchmark page" >}}
. {{< gh pr "tremor-rs/tremor-www" 219 "Fix typos in benchmarks page" >}}

[appendix]
== Other Achievements

=== Breaking the Compiler

I also managed to break the Rust compiler while working on this plugin system.
It may not be as rare as one would think, but for some reason I felt oddly proud
to achieve it, so I'll share it here :)

image::/blog/plugin-end/rustc_crash.png[width=100%, align=center]

It's seemingly related to incremental compilation, and
https://github.com/rust-lang/rust/issues/90608[someone had already reported it
before]. It should be fixed in a future version, and I haven't come across it
again.

=== LFX Mentorship Showcase

I already shared this in a previous article, but for completeness I'll repeat it
here. This online event made it possible to showcase my work back in January
with a https://youtu.be/htLCyqY0kt0?t=3166[quick 15-minute presentation]. I
couldn't get into many technical details, but I'm sure it will be useful to
someone else considering a https://lfx.linuxfoundation.org/tools/mentorship/[LFX
Mentorship] or https://summerofcode.withgoogle.com/[Google Summer of Code].

=== My Final Year Project

Finally, I have recently submitted this as
https://github.com/marioortizmanero/final-year-project[my bachelor's Final Year
Project]. It takes a more academic approach, and I rigorously reorganized
everything so that even developers unfamiliar with Rust can understand it. The
abstract is in English, but unfortunately, the rest is in Spanish due to absurd
university rules.

=== KubeCon + CloudNativeCon 2022

Thanks to the Tremor team, I was also able to presentially attend
https://events.linuxfoundation.org/kubecon-cloudnativecon-europe/[KubeCon +
CloudNativeCon] 2022 in Valencia, Spain! It was my first conference and I was
very pleasantly surprised by how nice everyone was. I had tons of fun and met
smart folk with all kinds of backgrounds. If you're on the fence about attending
something similar, I strongly recommend you to go for it!

.Paella! https://www.linkedin.com/feed/update/urn:li:share:6934450596049539072[From my LinkedIn profile].
image::/blog/plugin-end/paella.jpg[width=50%, align=center]
