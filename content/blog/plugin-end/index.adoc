---
title: "Plugins in Rust: Wrapping Up"
description: "The last finishing touches to the plugin system so that it can be
released in Tremor's new version"
author: "Mario Ortiz Manero"
tags: ["rust", "rustlang", "plugin", "benchmarking", "testing", "deployment"]
series: ["rust-plugins"]
date: 2022-07-09
GHissueID: 11
---

:sectnums:
:stem: latexmath

:repr-c: pass:quotes[`#[repr\(C)]`]
:repr-rust: pass:quotes[`#[repr(Rust)]`]
:work: pass:quotes["`just make it work`"]

////
TODO: use appropiate benchmarks for each case, and indicate where the
improvements may occur in specific. Indicate assumptions and known bias as well.

NOTE: histogram units are nanoseconds
////

Welcome to the final article of this
https://nullderef.com/series/rust-plugins/[series]! Here I'll clean up and
optimize our plugin system so that it's ready for deployment. These may require
performing benchmarks to ensure that the changes are actually worth it.

== Benchmarking

=== Tooling

There are all kinds of ways to measure the performance of a system, and it's
important to take as many of them as possible into account. Here are the ones I
used myself:

* *Raw metrics*: Tremor is able to measure its own raw throughput, latency
  ranges, or standard deviation. They serve as an overall score and are very
  easy to compare against eachother.
* *`perf.data`*: the command
  https://perf.wiki.kernel.org/index.php/Main_Page[`perf`] measures performance
  at runtime thanks to monitoring capabilities in the Linux kernel. It generates
  a file with the full execution trace, which can be visualized in multiple
  ways, including:
** https://www.brendangregg.com/flamegraphs.html[Flamegraphs]: hierarchical and
   simple graphs.
** `perf report`: the integrated CLI, which is more detailed but harder to
   understand.
* *High Dynamic Range (HDR) histograms*: Tremor's latency percentiles can be
  turned into a graph with
  https://hdrhistogram.github.io/HdrHistogram/plotFiles.html[this site].

There are many other techniques available for benchmarking, though. I wasn't
able to get into lower level performance indicators like cache misses.

This part of the project has helped me realize how hard it is to benchmark a
program reliably; I would suggest checking out other dedicated learning sources
on the topic. You should also tune the process according to your use-case, since
it may vary heavily between programs.

=== Methodology

My first issue was only having my laptop available for the benchmarks. It's a
decent machine, but it caused greater variance in the results, and it wasn't
very productive, since I had to stop everything I was doing to exclusively run
them. The Tremor team helped me out by granting me access to their dedicated
benchmarking server:

.Full specs of both machines, for reference
|===
|Machine |CPU |RAM |Disk |Operating System

|*Laptop (Dell Vostro 5481)*
|Intel i5-8265U
|16 GB @ 2667 MHz
|SSD
|Arch Linux, 5.18 kernel, 64 bits

|*Benchmarking Machine*
|Intel Xeon E-2278G
|32 GB @ 2667 MHz
|SSD
|Ubuntu 20.04, 5.4 kernel, 64 bits
|===

I ended up developing https://nullderef.com/blog/plugin-end/bench.sh[a custom
script] to run all the tests properly:

* It first validates the configuration, including what benchmarks to run and
  what binaries to compare. It was quite annoying to run into a typo 2 hours
  into the benchmarks...
* It performs a few warmup rounds before the actual benchmarks. This was
  specially important when using my laptop, since it started to overheat after
  the first few rounds, degrading its performance.

One way to ensure the variance isn't too high is to run the exact same benchmark
twice:

.Histogram for both machines. Unexpectedly, the server ended up having greater variance with this test, but it was good enough to continue anyway.
image::/blog/plugin-end/histogram_variance.png[]

I would strongly recommend anyone to get a separate machine to run benchmarks.
Not only will they be more reliable, but also you will be able to continue
working while the benchmarks run.

== Experiments

We can divide that experiments in two categories:

. _For tracking_: this change is always going to be a good idea, because it may
  also clean up the code or make it more robust. We just measure its performance
  impact to report the results and avoid surprises.
. _For investigation_: the change increases the complexity to explicitly improve
  performance, so we need to make sure it's worth our time. This improvement may
  occur directly with the change, or indirectly, by helping to come up with
  other optimizations.

Benchmarking is only essential in the latter, but I thought it would be a great
idea in both cases to fully understand the impact of the change. It also makes
it possible to write up a report like this article, explaining the improvements
I worked on.

=== Type conversions

The most important performance concern in the first PDK version had to do with
https://nullderef.com/blog/plugin-impl/#_reaching_reprc_blockers[the issues I
had found when trying to convert external types to the C ABI]. In short, I had a
relatively complex type `Value` and needed to make it FFI-safe for the plugin
system. However, it was used throughout the entire codebase, and modifying it
would've required a large amount of changes for just the initial version. Thus,
I created the copy `PdkValue` and converted to `Value` and back when going
through the FFI boundary. `PdkValue` was only used for the plugin system, making
it quite easy to implement in contrast.

An obvious experiment was to fix this problem properly by making `Value`
FFI-safe and removing `PdkValue`. Unless the performance degraded considerably,
this was always going to be a great change because it simplifies the code.

After the fix, I was able to investigate about the impact of these conversions
with some flamegraphs:

.With both `Value` and `PdkValue`. Highlighted in pink are the occurrences of `From`, `Into`, and `FromIterator`, which add up to 9.4% of all the calls in the execution.
image::/blog/plugin-end/with_value_conv.png[]

.With a single `Value`. The conversion calls add up to 5.2% now, and the highlighted parts are much harder to notice.
image::/blog/plugin-end/without_value_conv.png[]

The flamegraphs pointed out that Tremor was spending roughly 4.2% more of its
execution time just converting between `Value` and `PdkValue`. This metric is
tricky, though. Spending less time on type conversions doesn't mean that the
overall program is faster. The percentages are relative to the specific
execution, and it's possible that the rest of the program just got slower in the
case of a single `Value`.

By checking other metrics we discover that this is more or less the case. The
histogram shows that a single `Value` improves the latency, but the overall
throughput actually decreases:

.Histogram without the PDK (`connectors` branch) vs. first version vs. single `Value`.
image::/blog/plugin-end/histogram_pdk.png[]

// TODO: how to center this table?

.Relative throughput comparison (higher is better)
[cols="^,^,^"]
|===
|No PDK (%) |With `PdkValue` (%) |Single `Value` (%)

// |817.6k
// |545.1k
// |521.2k
|100
|66.67
|63.74
|===

However, this showcases one of my initial mistakes. My comparison only used the
`passthrough` benchmark, which simply forwards all input events to the output.
For a more realistic use-case, I should've tried with other configurations,
which may include different payloads or event processing logic. That's why, in
retrospect, these results should be taken with a grain of salt.

Anyway, the results make sense to some degree. Converting `Value` to an FFI-safe
type requires using, e.g., `RHashMap` instead of `HashMap` internally. Tremor's
original `HashMap` was taken from the {{< crate halfbrown >}} crate, which was
more performant than the standard library version, and much more than
``abi_stable``'s. Converting between types might actually be faster than using
less performant types internally.

=== Double `Box`

I later came up with an improvement over the previous experiment. The `HashMap`
within `Value` was stored inside a `Box` to reduce the overall size of the enum.
In the new type, I just converted it to a `RBox` and called it a day:

[source, diff]
----
 enum Value {
     // ...
-    Object(Box<HashMap<String, Value>>),
+    Object(RBox<RHashMap<RString, Value>>),
     // ...
 }
----

However, turns out that unlike `RString` or `RCow`, `RHashMap` isn't a
re-implementation of the underlying type. Writing a hash table from scratch is
too complex, so the author just made it an opaque type that wraps the standard
library version.

Since `RHashMap` is an opaque type, it was already on the heap internally thanks
to another `RBox`. `Value` basically had a doubly boxed type, which is
unnecessary, since the size of `RHashMap` is already minimal. Having to allocate
every hash table twice was probably quite costly, and fixing this counted as a
clean-up, so it was a no-brainer.

The subsequent benchmarks showed a slight improvement in performance, though I
was still only using the `passthrough` benchmark at this point. I kept the
change because it didn't make much sense to leave the doubly boxed hash table,
and it improved the readability of the code a bit.

.Histogram of a double box vs. a single box. Note that this test was run on the benchmarking server, while the previous one used my laptop. These tests aren't meant to be compared between different sections.
image::/blog/plugin-end/histogram_box.png[]

.Relative throughput comparison (higher is better)
[cols="^,^"]
|===
|Double `RBox` (%) |Single `RBox` (%)

// |1085.1k
// |1094.0k
|100
|100.82
|===

=== Hash table optimization

Using a single `Value` improved the ergonomics of the code, at the cost of a
slight performance impact. This regression can be fixed by creating an FFI-safe
wrapper for the original hash table from {{< crate halfbrown >}}. Tremor used it
both because it's faster for their usecase, and because it has access to lower
level functionality. The
https://github.com/rust-lang/rust/issues/56167[`raw_entry`] interface is only
available on nightly Rust, while `halfbrown` exports it in its stable version.
`raw_entry` makes it possible to memoize hashes, which enables an optimization
in Tremor's JSON handling.

NOTE: This may actually be a bad idea in the long term, because `raw_entry` is
actually not going to make it to stable <<raw-entry-unstable>>. The Rust team is
working on a different interface, but it will probably be similar enough that
updating our `raw_entry` usage won't be too complicated.

////
NOTE: skipped this because it only used passthrough as well.

==== For the main branch

The wrapper will still have a small overhead over the original type, but it
should still be a noticeable change that's worth trying. The first step is to
take a look at the difference on the main branch, without the PDK. It's possible
that `halfbrown` has stopped being worth it with time.

.Histogram comparing the `raw_entry` optimizations disabled vs. enabled. Both use the `halfbrown` hash table, though.
image::/blog/plugin-end/histogram_knownkey.png[]

.Relative throughput comparison (higher is better)
[cols="^,^"]
|===
|No `raw_entry` (%) |With `raw_entry` (%)

// |1361.5k
// |1349.1k
|100
|99.08
|===

==== For the plugin system
////

This time I did it right since the beginning, and tried with multiple kinds of
benchmark. The results are richer.

image::/blog/plugin-end/histogram_pdk_v2_passthrough.png[]

image::/blog/plugin-end/histogram_pdk_v2_passthrough_two_inputs.png[]

image::/blog/plugin-end/histogram_pdk_v2_throughput_logging_json.png[]

image::/blog/plugin-end/histogram_pdk_v2_throughput_logging_msgpack.png[]


.Relative performance for number of events processed per second (higher is better)
[cols="<,^,^,^,^"]
|===
|Benchmark |No PDK (%) |Halfbrown, No Known Key (%) |Halfbrown (%) |Hashbrown (%)

|*Passthrough*
// |1189.5
// |920.6
// |908.0
// |842.9
|100
|77.39
|76.33
|70.86

|*Passthrough Two Inputs*
// |938.2
// |660.0
// |654.7
// |645.2
|100
|70.34
|69.78
|68.76

|*Throughput Logging JSON*
// |556.8
// |365.1
// |364.6
// |385.4
|100
|65.57
|64.48
|69.21

|*Throughput Logging MsgPack*
// |600.2
// |400.2
// |393.3
// |424.3
|100
|66.66
|65.52
|70.69

|*Average*
|100
|69.99
|69.02
|69.88
|===

=== `abi_stable`

We can also look at a case where I decided the experiment wasn't worth pursuing,
which actually happened many other times. `abi_stable` imposes all kinds of
overheads, apart from the type validation step before loading a plugin. I wanted
to learn more about the `Drop` implementations, which require accessing to a
vtable, and in cases like `RBox`, dealing with additional logic to ensure
everything is safe <<abi-stable-box-drop>>.

After zooming into specific sections, we can see this overhead by ourselves in
the call stack:

.Flamegraph with ``abi_stable``'s complex destructors, shown in pink and zoomed.
image::/blog/plugin-end/with_destructor.png[]

However, I overestimated the importance of this problem. Taking a look at the
global picture, it's obvious that optimizing ``RBox``'s implementation of `Drop`
would be premature at the moment:

.Flamegraph with ``abi_stable``'s complex destructors, shown in pink, and without zooming in.
image::/blog/plugin-end/with_destructor_globally.png[]

I'm definitely taking note of this idea in order to investigate about it in the
future for further performance squeezing. But I currently have lots of other
more impactful experiments in mind with a higher priority.

== Other ideas

It's already been a year since I started working with Tremor. I've extended the
mentorship from three months to twelve so that I can use this work as my
bachelor's thesis (see <<thesis>>).

But now that I have finally graduated and need to find a full-time job, I won't
be able to continue experimenting with the plugin system. My hope is that with
the information in this series, the Tremor team can continue to evolve the
plugin system, and optimize it so that it's ready for deployment.

Here are some ideas worth considering that I haven't been able to carry out:

=== More detailed benchmarking

`perf` can track much more information than just the call stack. For example,
`perf stat` provides statistics like cache or branch misses <<perf-stat>>. Other
profiling tools like https://valgrind.org/[Valgrind],
https://developer.amd.com/amd-uprof/[AMD μProf], or
https://valgrind.org/[Valgrind] may provide more specialized insights
<<profiling>>. The whole
https://nnethercote.github.io/perf-book/title-page.html[The Rust Performance
Book] is a good read for more resources and ideas.

=== Investigate wrapper overhead

The communication between runtime and plugins is handled through the C ABI at a
lower level. To improve the ergonomics internally, the interface is accompanied
by a set of wrappers, which convert the types to the standard library.

Instead of returning a `Result`, the following raw function uses the FFI-safe
alternative `RResult`, which doesn't even work with `?` for error handling. This
example is quite specific to `abi_stable`, but what's important is that we just
wrap the base function `connect` and transform it to an easier to use one:

.Low-level interface to communicate between binaries.
[source, rust]
----
#[abi_stable::sabi_trait]
pub trait RawConnector: Send {
    fn connect<'a>(
        &'a mut self,
        ctx: &'a ConnectorContext,
        attempt: &'a Attempt,
    ) -> BorrowingFfiFuture<'a, RResult<bool>>;
}

/// Alias for the FFI-safe dynamic connector type
pub type BoxedRawConnector = RawConnector_TO<'static, RBox<()>>;
----

.High-level wrapper for what essentially is a `Box<dyn RawConnector>`.
[source, rust]
----
pub(crate) struct Connector(BoxedRawConnector);
impl Connector {
    #[inline]
    pub async fn connect(&mut self, ctx: &ConnectorContext, attempt: &Attempt) -> Result<bool> {
        self.0
            .connect(ctx, attempt)
            .await
            .map_err(Into::into) // RBoxError -> Error::PluginError
            .into() // RResult -> Result
    }
}
----

Here we just convert the return types, but we can also do that for the
parameters or whatever boilerplate is needed for that function. Note that this
wrapper only needs to be available in the runtime crate; the plugin is only
meant to implement `RawConnector`.

The problem is that, even though wrappers avoid quite a bit of boilerplate, they
might also affect performance-critical parts considerably. `connect` is only
called at the beginning of the program, but `on_event` is invoked for every
single event, making it our _hot loop_. Any small operation, like a type
conversion, will have a much greater impact in there. This experiment consists
on iteratively removing wrappers and looking for performance improvements.

=== Investigate async runtime conflicts

As far as I understand, the runtime and the plugins don't share the same async
runtime state. Every binary has its own thread pool and works independently. It
would be best to share everything between runtime and plugins, though it sounds
quite complicated, and it would most likely require contributions to the async
runtimes themselves.

I also wonder what happens when the runtime and the plugin use different async
runtimes, even if they are independent in the binaries. Tremor's core is
implemented with {{< crate async_std >}}, but an external plugin could freely
use {{< crate tokio >}}, for example. I've heard that this could break in many
ways, since async runtimes heavily rely on global state.

Testing different async runtimes should be easy, so it should at least be done
before reaching production just to document the behavior. What I'm not so sure
about is how to avoid the conflict, in case it was problematic. The fix would
probably be quite hacky, as this is a somewhat obscure problem.

=== Benchmark `async_ffi`

Checking how much of a performance impact {{< crate async_ffi >}} causes sounds
like a good idea. It's actually a quite simple library; all it really does is
implement opaque wrappers for the async-related types. But this is done so often
(once per call), that it may end up being noticeable.

I'm sure that if `async_ffi` ended up being an issue, it could be optimized
internally in various ways. We could also use `async` only when strictly
necessary to reduce the overhead.

=== Improve error reporting

For simplicity, errors in our interface are indicated via ``abi_stable``'s
https://docs.rs/abi_stable/0.10.4/abi_stable/std_types/type.SendRBoxError.html[`SendRBoxError`],
which is basically a `Box<dyn Error + Send>`. It's really the only way to do it,
because a plugin could have any kind of error, and we can't know them at
compile-time.

Using `Box<dyn Error>` instead of a concrete type makes it really hard to
identify errors in order to handle them. We could implement our own `Error`
subtrait that provides more plugin-related information. An easier option is to
define a more organized data structure with common kinds of errors:

.Example of a more organized error type, even if it still uses `Box<dyn Error>`
[source, rust]
----
pub struct PluginError {
    err: SendRBoxError,
    kind: PluginErrorKind
}

pub enum PluginErrorKind {
    Internal, // Implementation-defined errors we can't handle
    ConnectionFailed, // Edge cases in `connect`
    // ...
}
----

=== Reduce error handling boilerplate

Furthermore, in FFI contexts we have to use an FFI-safe type like `RResult`
instead of `Result`. Since the `Try` trait isn't stable <<try-trait>>, we can't
use the `?` operator yet. `abi_stable` exports the
https://docs.rs/abi_stable/0.10.4/abi_stable/macro.rtry.html[`rtry` macro] as a
substitute for `?`, but in my experience it introduces noise in the code, making
it uglier and harder to maintain.

Depending on how much `Try` is going to take to stabilize, creating a procedural
macro might be worth our time. It would just replace `?` with `rtry` or whatever
is configred, which should be somewhat simple to write. I'm surprised I couldn't
find an existing crate for that yet.

.Readibility would improve in longer functions with lots of error handling
[source, diff]
----
+#[try_with(rtry)]
 fn fallible() -> RResult<()> {
-    if rtry!(fallible_op_1()) && rtry!(fallible_op_2()) {
-        rtry!(fallible_op_3());
+    if fallible_op_1()? && fallible_op_2()? {
+        fallible_op_3()?;
     }
 
     ROk(())
 }
----

Admittedly, the example above is an oversimplification. In reality, a single
function may mix both `Result` and `RResult`, or require type conversions. The
proc macro would probably be a bit more complex, but it might be worth
considering regardless.

=== Reduce async boilerplate

`async_ffi` would really benefit with a procedural macro as well. It always
requires using `async move { /* ... */ }.into_ffi()`, which is quite a bit of
boilerplate and increases the indentation level by one.

.Without the procedural macro
[source, rust]
----
use async_ffi::{FfiFuture, FutureExt};

#[no_mangle]
pub extern "C" fn work(arg: u32) -> FfiFuture<u32> {
    async move {
        let ret = do_some_io(arg).await;
        do_some_sleep(42).await;
        ret
    }
    .into_ffi()
}
----

.With the procedural macro
[source, rust]
----
use async_ffi::async_ffi;

#[no_mangle]
#[async_ffi]
pub async extern "C" fn work(arg: u32) -> u32 {
    let ret = do_some_io(arg).await;
    do_some_sleep(42).await;
    ret
}
----

I already opened an issue about this with more details for whoever wants to give
it a try:

[.text-center]
{{< gh issue "oxalica/async-ffi" 12 "Procedural macro for boilerplate" >}} 

=== Improve cross-platform support

As I mentioned in earlier articles, our PDK will only work on Windows, macOS,
and Linux <<thread-safe>>. It will still compile on other platforms, but
possibly with data races in the dynamic linking internals.

Specifically, {{< crate libloading >}}, which is used by `abi_stable`, states
that its error handling isn't fully thread-safe on some platforms
<<libloading-threadsafe>>, such as `dlerror` on FreeBSD. Its only consequence
should be garbage error messages, but I still wouldn't risk it. There are two
ways to approach this:

. *Quick fix*: add a compile-time error for any platform that isn't explicitly
  supported. Before supporting a new platform, we will have to  manually ensure
  that its dynamic loading error handling is thread-safe.
+
[source, rust]
----
// Ideally, there should be a comment here with references that state the
// thread-safety of the supported platforms.
#[cfg(not(any(unix, windows, target_os = "macos")))]
compile_error!(
    "This platform isn't currently supported. Please open a ticket on GitHub."
);
----
. *Proper fix*: fix the data races upstream with an internal mutex. This is what
  the alternative {{< crate dlopen >}} does, though in their case they _always_
  have the mutex, which is unnecessary in some platforms <<dlopen-mutex>>.

=== Performance impact of panic handling

`abi_stable` has to track all panic occurrences so that they don't propagate
through the FFI boundary. Otherwise, as discussed in other articles <<panic-1>>
<<panic-2>>, we would be invoking undefined behaviour. `async_ffi` also has
special handling for panicking, which overcomplicates the crate a bit.

There are two interesting experiments to be tried:

1. Comparing the performance of `panic = "abort"` and `panic = "unwind"`.
   Technically, aborting should optimize away most of the extra code
   <<panic-abort>>, but it should only be used for research, as it would make it
   incredibly hard to debug errors in production.
2. Preparing `abi_stable` and `async_ffi` for the stable release of
   https://rust-lang.github.io/rfcs/2945-c-unwind-abi.html[`extern "C-unwind"`],
   thanks to which all the additional panic handling could be removed. Unlike
   aborting, we would still be able to debug errors just fine.
+
For now, it's only available on nightly without a certain release date, but it
will surely be useful in the future, and we could measure how much panic
handling costs. Testing new features like that also speeds up their release,
since we could share feedback with the
https://github.com/rust-lang/project-ffi-unwind[project group].

=== Use `-Z randomize-layout` to find FFI bugs

The unstable compiler flag
https://github.com/rust-lang/compiler-team/issues/457[`-Z randomize-layout`]
randomizes the layout of {repr-rust} types. The Rust ABI is unstable, so it
explicitly doesn't specify much about the type layouts, and we must not rely on
them. However, in practice they're usually consistent, at least within the same
compiler version <<abi-instability>>, so these errors can be hard to catch
without a tool like this.

We use {repr-c} for the plugin system, so this flag shouldn't cause any
issues... unless we're mistakenly interacting with the Rust ABI. In that case,
the program would crash in random and unexpected ways, pointing out that there's
something wrong. It certainly won't be a super nice debugging experience, but
it's better than having it happen in production.

This may even catch other bugs unrelated to the PDK. Tremor implements
self-referential types and other optimizations, and it's possible that some of
them incorrectly rely on the Rust ABI.

Tremor's Continuous Integration tests could be run with `-Z randomize-layout` to
ensure that no opaque types export Rust types, even if `abi_stable` prevents
most cases within the PDK.

=== Try raw dynamic loading

What I didn't know at the beginning of this journey is that the hardest part
would be making everything {repr-c}. Using `abi_stable` is certainly very useful
for types like `RVec` and to create custom types, but at times I find the
library too much.

I think it would be best to have separate libraries for all the utilities
`abi_stable` provides, rather than having everything bundled in there. If it
became modularized, making it the "`community standard`" would be easier.

=== Simplify the interface further

=== Extend the plugin system to more components

== Conclusion

* Throughput degraded by around 36% initially
* Latency had also been affected considerably at every percentile (TODO insert
  histogram here)
* In the final version, throughput impact was reduced to 30%

I won't be able and work on most of these ideas myself before releasing the
plugin system into its first version in production. If everything goes well, the
Tremor team will take care of it. I look forward to seeing how the plugin system
continues to evolve with the program!

== Thanks

// TODO: Link to Annex I
Lastly, I've found it especially rewarding to do all of this in an open source
environment. Even if you're working for a company with propietary software,
please try to contribute upstream instead of forking or patching. Try to be nice
to those who are saving you so much work, and submit a PR or an issue:

Please <<comments,leave a comment at the bottom>> in case you have any questions
or suggestions. Also let me know if you have any updates on any of the ideas
above, so that I can add a link for future readers!

[bibliography]
== References

// TODO: add text placeholders

- [[[raw-entry-unstable,      1]]]
  https://github.com/rust-lang/rust/issues/56167#issuecomment-810457405[@Amanieu's
  comment -- Tracking issue for HashMap::raw_entry]
- [[[perf-stat,               2]]]
  https://perf.wiki.kernel.org/index.php/Tutorial#Counting_with_perf_stat[Counting
  with `perf stat` -- Perf Wiki]
- [[[profiling,               3]]]
  https://nnethercote.github.io/perf-book/profiling.html[Profilers -- The Rust
  Performance Book].
- [[[abi-stable-box-drop,     4]]]
  https://github.com/rodrimati1992/abi_stable_crates/blob/4514c38829548ef6f4201dac183c1e866bdd2401/abi_stable/src/std_types/boxed.rs#L597[`Drop`
  for `RBox` in `abi_stable/src/std_types/boxed.rs`]
- [[[try-trait,               5]]]
  https://rust-lang.github.io/rfcs/3058-try-trait-v2.html[Try trait v2 -- The
  Rust RFC Book]
- [[[thread-safe,             6]]]
  https://nullderef.com/blog/plugin-abi-stable/#_thread_safety[Thread safety --
  Plugins in Rust: Reducing the Pain with Dependencies, NullDeref]
- [[[libloading-threadsafe,   7]]]
  https://docs.rs/libloading/0.7.3/libloading/struct.Library.html#thread-safety[Thread-safety
  -- `libloading` v0.7.3 docs]
- [[[dlopen-mutex,            8]]]
  {{< gh issue "szymonwieloch/rust-dlopen" 42 "`dlerror` *is* thread-safe on some platforms" >}}
- [[[panic-1,                 9]]]
  https://nullderef.com/blog/plugin-abi-stable/#_panicking[Panicking -- Plugins
  in Rust: Reducing the Pain with Dependencies, NullDeref]
- [[[panic-2,                 9]]]
  https://nullderef.com/blog/plugin-dynload/#_panicking[Panicking -- Plugins in
  Rust: Diving into Dynamic Loading, NullDeref]
- [[[panic-abort,             9]]]
  https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html#unwinding-the-stack-or-aborting-in-response-to-a-panic[Unwinding
  the Stack or Aborting in Response to a Panic -- The Rust Programming Language]
- [[[abi-instability,        10]]]
  https://nullderef.com/blog/plugin-start/#_abi_unstability_its_much_worse_than_it_seems[ABI
  unstability, it’s much worse than it seems -- Plugins in Rust: Getting
  Started, NullDeref]

[appendix]
== Open Source Contributions

One of my favorite parts of the project has been contributing so much to all
kinds of open source dependencies, so I've maintained a list of its occurrences.
Some are more important than others, but it's still a decent metric for my
results. This skips the issues or pull requests that:

* Contributed nothing (e.g., asking questions or discarded ideas).
* Were repetitive (e.g., I made a few identical PRs in Tremor when I was fixing
  problems with Git).

=== External Contributions

These include repositories not directly related to Tremor:

. {{< gh issue "rust-lang/nomicon" 338 "Subtyping and Variance - Trait variance not covered" >}}
. {{< gh issue "szymonwieloch/rust-dlopen" 42 "`dlerror` *is* thread-safe on some platforms" >}}
. {{< gh issue "wasmerio/wasmer" 2539 "Add deprecation notice to the crate `wasmer-runtime`" >}}
. {{< gh pr "oxalica/async-ffi" 10 "Support for `abi_stable`" >}}
. {{< gh pr "oxalica/async-ffi" 11 "Cbindgen support" >}}
. {{< gh issue "oxalica/async-ffi" 12 "Procedural macro for boilerplate" >}}
. {{< gh issue "rodrimati1992/abi_stable_crates" 52 "Generating C bindings" >}}
. {{< gh issue "rodrimati1992/abi_stable_crates" 60 "Stable ABI for floating point numbers" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 55 "Fix 'carte' typo" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 57 "Fix some more typos" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 58 "Add support for .keys() and .values() in RHashMap" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 59 "Implement `Index` for slices and vectors" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 61 "Support for `f32` and `f64`" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 68 "Implement `ROption::as_deref`" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 70 "Implement `RVec::append`" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 76 "Fix `R*` lifetimes" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 77 "Fix inconsistencies with `RVec` in respect to `Vec`" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 82 "Implement `ROption::{ok_or,ok_or_else}`" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 83 "`RHashMap::raw_entry[_mut]` support" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 85 "Fix hasher" >}}
. {{< gh pr "rodrimati1992/abi_stable_crates" 88 "Only implement `Default` once" >}}
. {{< gh pr "simd-lite/simd-json-derive" 9 "Support for `abi_stable`" >}}
. {{< gh issue "simd-lite/simd-json-derive" 10 "No docs for v0.3.0" >}}
. {{< gh pr "simd-lite/value-trait" 14 "Add support for StableAbi" >}}
. {{< gh pr "simd-lite/value-trait" 16 "User friendliness for the win! (close #15)" >}}
. {{< gh pr "simd-lite/value-trait" 18 "Update abi_stable after upstreamed changes" >}}
. {{< gh pr "nagisa/rust_libloading" 94 "Small typo" >}}
. {{< gh pr "szymonwieloch/rust-dlopen" 40 "Fix typo" >}}
. {{< gh pr "Licenser/halfbrown" 13 "Implement `remove_entry`" >}}
. {{< gh pr "Licenser/halfbrown" 14 "Implement `Clone` and `Debug` for `Iter`" >}}
. {{< gh pr "Licenser/halfbrown" 16 "Relax constraints" >}}
. {{< gh pr "Licenser/halfbrown" 17 "Same `Default` constraints" >}}
. {{< gh pr "Licenser/halfbrown" 18 "Fix `Clone` requirements for `Iter`" >}}

=== Internal Contributions

Here are the issues and pull requests created within Tremor's repositories,
including those for the PDK and other unrelated improvements:

. {{< gh pr "tremor-rs/tremor-runtime" 1434 "PDK support" >}}
. {{< gh pr "marioortizmanero/tremor-runtime" 11 "PDK with a single value" >}}
. {{< gh pr "tremor-rs/tremor-runtime" 1447 "Fix `makefile bench`" >}}
. {{< gh pr "marioortizmanero/tremor-runtime" 2 "Adding `abi_stable` support for `tremor-script`" >}} (second attempt)
. {{< gh pr "marioortizmanero/tremor-runtime" 1 "Adding `abi_stable` support for `tremor-runtime`" >}} (second attempt)
. {{< gh pr "tremor-rs/tremor-runtime" 1303 "Adding `abi_stable` support for `tremor-value`" >}} (second attempt)
. {{< gh pr "tremor-rs/tremor-runtime" 1287 "Plugin Development Kit: Connectors" >}} (first attempt)
. {{< gh issue "tremor-rs/tremor-runtime" 1353 "`deny` statemements in `lib.rs` should be enforced in the CI rather than in the code" >}}
. {{< gh issue "tremor-rs/tremor-runtime" 1812 "`KnownKey` relies on a deterministic hash builder" >}}
. {{< gh pr "tremor-rs/tremor-www" 72 "Fix wrong links in getting started" >}}
. {{< gh issue "tremor-rs/tremor-www" 73 "Redirect `docs.tremor.rs` to `www.tremor.rs/docs`" >}}
. {{< gh pr "tremor-rs/tremor-www" 186 "Links pinned to 0.12 don't work" >}}
. {{< gh pr "tremor-rs/tremor-www" 187 "Small fix in code snippet" >}}
. {{< gh issue "tremor-rs/tremor-www" 195 "No margins in benchmark page" >}}
. {{< gh pr "tremor-rs/tremor-www" 219 "Fix typos in benchmarks page" >}}

[appendix]
== Other Achievements

=== Breaking the Compiler

I also managed to break the Rust compiler while working on this plugin system.
It may not be as rare as one would think, but for some reason I felt oddly proud
to achieve it, so I'll share it here :)

image::/blog/plugin-end/rustc_crash.png[width=100%, align=center]

It's seemingly related to incremental compilation, and
https://github.com/rust-lang/rust/issues/90608[someone had already reported it
before]. It should be fixed in a future version, and I haven't come across it
again.

=== LFX Mentorship Showcase

I already shared this in a previous article, but for completeness I'll repeat it
here. This online event made it possible to showcase my work back in January
with a https://youtu.be/htLCyqY0kt0?t=3166[quick 15-minute presentation]. I
couldn't get into many technical details, but I'm sure it will be useful to
someone else considering a https://lfx.linuxfoundation.org/tools/mentorship/[LFX
Mentorship] or https://summerofcode.withgoogle.com/[Google Summer of Code].

[[thesis]]
=== My Final Year Project

Finally, I have recently submitted this as
https://github.com/marioortizmanero/final-year-project[my bachelor's Final Year
Project]. It takes a more academic approach, and I rigorously reorganized
everything so that even developers unfamiliar with Rust can understand it. The
abstract is in English, but unfortunately, the rest is in Spanish due to absurd
university rules.

=== KubeCon + CloudNativeCon 2022

Thanks to the Tremor team, I was also able to presentially attend
https://events.linuxfoundation.org/kubecon-cloudnativecon-europe/[KubeCon +
CloudNativeCon] 2022 in Valencia, Spain! It was my first conference and I was
very pleasantly surprised by how nice everyone was. I had tons of fun and met
smart folk with all kinds of backgrounds. If you're on the fence about attending
something similar, I strongly recommend you to go for it!

.Paella! https://www.linkedin.com/feed/update/urn:li:share:6934450596049539072[From my LinkedIn profile].
image::/blog/plugin-end/paella.jpg[width=50%, align=center]
