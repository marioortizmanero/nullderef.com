---
title: "Surprised by Rust's Subtyping and Variance"
description: "One of the toughest bugs I've come across... Thanks to my good
friends Subtyping and Variance."
author: "Mario Ortiz Manero"
images: ["TODO"]
tags: ["tech", "programming", "rust", "rustlang", "variance", "subtyping", "abi_stable"]
date: 2022-01-29
GHissueID: TODO
draft: true
---

:sectnums:

:repr-c: pass:quotes[`#[repr\(C)]`]
:repr-rust: pass:quotes[`#[repr(Rust)]`]
:work: pass:quotes["`just make it work`"]
:heinz: https://twitter.com/heinz_gies/[Heinz]

_Subtyping and variance_ is a concept that works in the background, making your
life easier without you knowing about it. That is, until it starts making your
life harder instead. It's a good idea to know its pitfalls in case you end up
being an unlucky fool like me. So let's take a look at what went wrong, and how
it was resolved.

== The problem

As part of my https://nullderef.com/series/rust-plugins/[Plugin System in Rust]
series, I was making one of https://www.tremor.rs/[Tremor]'s core types
FFI-compatible (a.k.a. {repr-c}). This was possible thanks to the crate {{<
crate abi_stable >}}, which includes re-implementations of the standard library
that are {repr-c} for this exact purpose. Theoretically, the task should be as
easy as changing the `std` types in the core `enum` with theirs:

.Before (simplified)
{{< highlight "rust" >}}
pub enum Value {
    String(String),
    Array(Vec<Value>),
    Object(Box<HashMap<String, Value>>),
    Bytes(Vec<u8>),
}
{{< /highlight >}}

.After (simplified)
{{< highlight "rust" >}}
use abi_stable::std_types::{RString, RVec, RBox, RHashMap};

#[repr(C)]
pub enum Value {
    String(RString),
    Array(RVec<Value>),
    Object(RBox<RHashMap<RString, Value>>),
    Bytes(RVec<u8>),
}
{{< /highlight >}}

The `Value` type is used a lot in the codebase, so this breaking change brought
up lots of compilation errors. But for whatever reason, 70 of these errors were
related to lifetimes, which I hadn't changed at all...

== Debugging

{heinz}, my mentor at Tremor, managed to reproduce the issue:

{{< highlight "rust" >}}
use abi_stable::std_types::RCow;
use std::borrow::Cow;

// This works
fn cmp_cow<'a, 'b>(left: &Cow<'a, ()>, right: &Cow<'b, ()>) -> bool {
    left == right
}

// This fails to compile
fn cmp_rcow<'a, 'b>(left: &RCow<'a, ()>, right: &RCow<'b, ()>) -> bool {
    left == right
}
{{< /highlight >}}

With the following error:

{{< highlight "text" >}}
$ cargo b
   Compiling repro v0.1.0 (/home/mario/Downloads/repro)
error[E0623]: lifetime mismatch
  --> src/lib.rs:10:10
   |
9  | fn cmp_rcow<'a, 'b>(left: &RCow<'a, ()>, right: &RCow<'b, ()>) -> bool {
   |                            ------------          ------------
   |                            |
   |                            these two types are declared with different lifetimes...
10 |     left == right
   |          ^^ ...but data from `left` flows into `right` here

For more information about this error, try `rustc --explain E0623`.
error: could not compile `repro` due to previous error
{{< /highlight >}}

What? Why do lifetimes matter here if it's just a comparison?

This hinted that the issue was in the underlying library, not my code. `RCow` is
supposed to be a drop-in replacement for `Cow`. It also had something to do with
`PartialOrd`, which is the trait used for `==` here. The implementation of
`PartialOrd` seemed equivalent in both cases, though:

.Cow
{{< highlight "rust" >}}
impl<'a, B: ?Sized> PartialOrd for Cow<'a, B>
where
    B: PartialOrd + ToOwned,
{
    #[inline]
    fn partial_cmp(&self, other: &Cow<'a, B>) -> Option<Ordering> {
        PartialOrd::partial_cmp(&**self, &**other)
    }
}
{{< /highlight >}}

.RCow
{{< highlight "rust" >}}
impl<'a, B> PartialOrd<RCow<'a, B>> for RCow<'a, B>
where
    B: PartialOrd + BorrowOwned<'a> + ?Sized,
{
    #[inline]
    fn partial_cmp(&self, other: &RCow<'a, B>) -> Option<Ordering> {
        PartialOrd::partial_cmp(&**self, &**other)
    }
}
{{< /highlight >}}

There are more libraries providing drop-in replacements for `Cow`. And for
example, {{< crate "beef" >}} managed to get it right, somehow. I wasn't able to
reproduce the issue with their implementation... but why?

.Beef's Cow
{{< highlight "rust" >}}
impl<A, B, U, V> PartialOrd<Cow<'_, B, V>> for Cow<'_, A, U>
where
    A: Beef + ?Sized + PartialOrd<B>,
    B: Beef + ?Sized,
    U: Capacity,
    V: Capacity,
{
    #[inline]
    fn partial_cmp(&self, other: &Cow<'_, B, V>) -> Option<Ordering> {
        PartialOrd::partial_cmp(self.borrow(), other.borrow())
    }
}
{{< /highlight >}}

== Some progress... or not?

In reality, other traits like `PartialEq` also showed lifetime errors with a
similar snippet. After many wasted hours, I was tempted to use `transmute` and
call it a day. But I was afraid it'd backfire at some point. Here's what Heinz
suggested (_trigger warning_) -- and it actually worked! I'd just need to use
the wrapper `SCow` instead of `RCow`:

{{< highlight "rust" >}}
struct SCow<'a>(RCow<'a, ()>);
impl<'a, 'b> PartialEq<SCow<'a>> for SCow<'b> {
    fn eq(&self, other: &SCow<'a>) -> bool {
        unsafe {
            let other0: &RCow<'b, ()> = std::mem::transmute(&other.0);
            &self.0 == other0
        }
    }
}
{{< /highlight >}}

{{< highlight "rust" >}}
fn cmp_cow<'a, 'b>(left: &Cow<'a, ()>, right: &Cow<'b, ()>) -> bool {
    left == right
}
fn cmp_scow<'a, 'b>(left: &SCow<'a>, right: &SCow<'b>) -> bool {
    left == right
}
{{< /highlight >}}

But in this project, I already had too many things backfire. Traumatized, I
continued my debugging, which led to actually fixing some traits! By introducing
a new lifetime `'b` into the trait implementation, I was telling Rust that
comparing objects with different lifetimes is okay:

{{< highlight "diff" >}}
-impl<'a, B> PartialEq<RCow<'a, B>> for RCow<'a, B>
+impl<'a, 'b, B, C> PartialEq<RCow<'b, C>> for RCow<'a, B>
 where
     B: PartialEq + BorrowOwned<'a> + ?Sized,
+    C: BorrowOwned<'b> + ?Sized,
 {
-    fn eq(&self, other: &RCow<'a, B>) -> bool {
+    fn eq(&self, other: &RCow<'b, C>) -> bool {
         PartialEq::eq(&**self, &**other)
     }
 }
{{< /highlight >}}

This gave me some hope. But it could never work for the trait `Ord`, which also
failed. This is because this trait uses `Self` instead of another type, so I
can't just introduce another lifetime:

.Cow
{{< highlight "rust" >}}
impl<B: ?Sized> Ord for Cow<'_, B>
where
    B: Ord + ToOwned,
{
    #[inline]
    fn cmp(&self, other: &Self) -> Ordering {
        Ord::cmp(&**self, &**other)
    }
}
{{< /highlight >}}

.RCow
{{< highlight "rust" >}}
impl<'a, B: ?Sized> Ord for RCow<'a, B>
where
    B: Ord + BorrowOwned<'a>,
{
    #[inline]
    fn cmp(&self, other: &RCow<'a, B>) -> Ordering {
        Ord::cmp(&**self, &**other)
    }
}
{{< /highlight >}}

== Discovering

Some wonderful people on Rust's Discord server helped me learn about the root
cause: "Subtyping and Variance":

image::discord.png[Discord discussion, width=100%, align=center]

This topic isn't covered in the https://doc.rust-lang.org/book/[The Rust Book].
We'll only find it in its more obscure, unsafer brother,
https://doc.rust-lang.org/nomicon[The Rustonomicon]. It's actually incredibly
well explained in there, so I will refrain from repeating myself. I'd suggest to
check out yourself the following sources, as this article only covers the
specific issue I faced:

. https://doc.rust-lang.org/nomicon/subtyping.html["`Subtyping and Variance`" --
  The Rustonomicon]
. https://doc.rust-lang.org/reference/subtyping.html["`Subtyping and Variance`"
  -- The Rust Reference]
. https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)["`Covariance
  and contravariance`" -- Wikipedia]

There are also a couple blog posts with a more practical approach, like
https://medium.com/@orbitalK/rust-lifetime-subtype-variance-b58434fe36ed["`Rust
Lifetime Subtype Variance`" -- Prolific K] or
https://lcnr.de/blog/diving-deep-implied-bounds-and-variance/["`Diving Deep:
implied bounds and variance`" -- lcnr.de]. If you're more of a visual learner,
then https://www.youtube.com/watch?v=iVYWDIW71jk[this video from Jon Gjengset]
might be best for you.

== Conclusion

I would honestly say that the fact it took me so long to realize the error is
Rust's fault. There were no indications in the errors about variance. I
understand that there were

I was lucky to have such a great team at Tremor, and an OSS maintainer as smart
as Rodri. You can find all the details of the discussion in the following GitHub
issue:

[.text-center]
{{< gh issue "rodrimati1992/abi_stable_crates" 75 "lifetimes with R* types break compared to non R* types" "paragraph" >}}
