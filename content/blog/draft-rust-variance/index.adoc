---
title: "Surprised by Rust's Subtyping and Variance"
description: "One of the toughest bugs I've come across... Thanks to my good
friends Subtyping and Variance."
author: "Mario Ortiz Manero"
images: ["TODO"]
tags: ["tech", "programming", "rust", "rustlang", "variance", "subtyping", "abi_stable"]
date: 2022-01-29
GHissueID: TODO
draft: true
---

:sectnums:

:repr-c: pass:quotes[`#[repr\(C)]`]
:repr-rust: pass:quotes[`#[repr(Rust)]`]
:work: pass:quotes["`just make it work`"]
:heinz: https://twitter.com/heinz_gies/[Heinz]

_Subtyping and variance_ is a concept that works in the background, making your
life easier without you knowing about it. That is, until it starts making your
life harder instead. It's a good idea to know its pitfalls in case you end up
being an unlucky fool like me. So let's take a look at what went wrong, and how
it was resolved.

== The problem

As part of my https://nullderef.com/series/rust-plugins/[Plugin System in Rust]
series, I was making one of https://www.tremor.rs/[Tremor]'s core types
FFI-compatible (a.k.a. {repr-c}). This was possible thanks to the crate {{<
crate abi_stable >}}, which includes re-implementations of the standard library
that are {repr-c} for this exact purpose. Theoretically, the task should be as
easy as changing the `std` types in the core `enum` with theirs:

.Before (simplified)
{{< highlight "rust" >}}
pub enum Value {
    String(String),
    Array(Vec<Value>),
    Object(Box<HashMap<String, Value>>),
    Bytes(Vec<u8>),
}
{{< /highlight >}}

.After (simplified)
{{< highlight "rust" >}}
use abi_stable::std_types::{RString, RVec, RBox, RHashMap};

#[repr(C)]
pub enum Value {
    String(RString),
    Array(RVec<Value>),
    Object(RBox<RHashMap<RString, Value>>),
    Bytes(RVec<u8>),
}
{{< /highlight >}}

The `Value` type is used a lot in the codebase, so this breaking change brought
up lots of compilation errors. But for whatever reason, 70 of these errors were
related to lifetimes, which I hadn't changed at all...

== Debugging

{heinz}, my mentor at Tremor, managed to reproduce the issue:

{{< highlight "rust" >}}
use abi_stable::std_types::RCow;
use std::borrow::Cow;

// This works
fn cmp_cow<'a, 'b>(left: &Cow<'a, ()>, right: &Cow<'b, ()>) -> bool {
    left == right
}

// This fails to compile
fn cmp_rcow<'a, 'b>(left: &RCow<'a, ()>, right: &RCow<'b, ()>) -> bool {
    left == right
}
{{< /highlight >}}

With the following error:

{{< highlight "text" >}}
$ cargo b
   Compiling repro v0.1.0 (/home/mario/Downloads/repro)
error[E0623]: lifetime mismatch
  --> src/lib.rs:10:10
   |
9  | fn cmp_rcow<'a, 'b>(left: &RCow<'a, ()>, right: &RCow<'b, ()>) -> bool {
   |                            ------------          ------------
   |                            |
   |                            these two types are declared with different lifetimes...
10 |     left == right
   |          ^^ ...but data from `left` flows into `right` here

For more information about this error, try `rustc --explain E0623`.
error: could not compile `repro` due to previous error
{{< /highlight >}}

What? Why do lifetimes matter here if it's just a comparison?

This hinted that the issue was in the underlying library, not my code. `RCow` is
supposed to be a drop-in replacement for `Cow`. It also had something to do with
`PartialOrd`, which is the trait used for `==` here. The implementation of
`PartialOrd` seemed equivalent in both cases, though:

.Cow
{{< highlight "rust" >}}
impl<'a, B: ?Sized> PartialOrd for Cow<'a, B>
where
    B: PartialOrd + ToOwned,
{
    #[inline]
    fn partial_cmp(&self, other: &Cow<'a, B>) -> Option<Ordering> {
        PartialOrd::partial_cmp(&**self, &**other)
    }
}
{{< /highlight >}}

.RCow
{{< highlight "rust" >}}
impl<'a, B> PartialOrd<RCow<'a, B>> for RCow<'a, B>
where
    B: PartialOrd + BorrowOwned<'a> + ?Sized,
{
    #[inline]
    fn partial_cmp(&self, other: &RCow<'a, B>) -> Option<Ordering> {
        PartialOrd::partial_cmp(&**self, &**other)
    }
}
{{< /highlight >}}

There are more libraries providing drop-in replacements for `Cow`. And for
example, {{< crate "beef" >}} managed to get it right, somehow. I wasn't able to
reproduce the issue with their implementation... but why?

.Beef's Cow
{{< highlight "rust" >}}
impl<A, B, U, V> PartialOrd<Cow<'_, B, V>> for Cow<'_, A, U>
where
    A: Beef + ?Sized + PartialOrd<B>,
    B: Beef + ?Sized,
    U: Capacity,
    V: Capacity,
{
    #[inline]
    fn partial_cmp(&self, other: &Cow<'_, B, V>) -> Option<Ordering> {
        PartialOrd::partial_cmp(self.borrow(), other.borrow())
    }
}
{{< /highlight >}}

== Some progress... or not?

In reality, other traits like `PartialEq` also showed lifetime errors with a
similar snippet. By introducing
a new lifetime `'b` into the trait implementation, I was telling Rust that
comparing objects with different lifetimes is okay:

{{< highlight "diff" >}}
-impl<'a, B> PartialEq<RCow<'a, B>> for RCow<'a, B>
+impl<'a, 'b, B, C> PartialEq<RCow<'b, C>> for RCow<'a, B>
 where
     B: PartialEq + BorrowOwned<'a> + ?Sized,
+    C: BorrowOwned<'b> + ?Sized,
 {
-    fn eq(&self, other: &RCow<'a, B>) -> bool {
+    fn eq(&self, other: &RCow<'b, C>) -> bool {
         PartialEq::eq(&**self, &**other)
     }
 }
{{< /highlight >}}

I suddenly got a bit of hope. But this fix could never work for `Ord`, which
also failed. This trait uses `Self` instead of another type, so I can't just
introduce another lifetime:

.Cow
{{< highlight "rust" >}}
impl<B: ?Sized> Ord for Cow<'_, B>
where
    B: Ord + ToOwned,
{
    #[inline]
    fn cmp(&self, other: &Self) -> Ordering {
        Ord::cmp(&**self, &**other)
    }
}
{{< /highlight >}}

.RCow
{{< highlight "rust" >}}
impl<'a, B: ?Sized> Ord for RCow<'a, B>
where
    B: Ord + BorrowOwned<'a>,
{
    #[inline]
    fn cmp(&self, other: &Self) -> Ordering {
        Ord::cmp(&**self, &**other)
    }
}
{{< /highlight >}}

== Discovering the root cause

Some wonderful people on the Rust Discord server helped me understand what was
going on: "Subtyping and Variance". So I started to learn more about it.

image::discord.png[Discord discussion, width=100%, align=center]

This topic isn't covered in the https://doc.rust-lang.org/book/[The Rust Book].
We'll only find it in its more obscure, unsafer brother,
https://doc.rust-lang.org/nomicon[The Rustonomicon]. It's actually incredibly
well explained in there, so I will refrain from repeating myself. I'd suggest to
check out yourself the following sources, as this article only covers the
specific issue I faced:

. https://doc.rust-lang.org/nomicon/subtyping.html["`Subtyping and Variance`" --
  The Rustonomicon]
. https://doc.rust-lang.org/reference/subtyping.html["`Subtyping and Variance`"
  -- The Rust Reference]
. https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)["`Covariance
  and contravariance`" -- Wikipedia]

There are also a couple blog posts with a more practical approach, like
https://medium.com/@orbitalK/rust-lifetime-subtype-variance-b58434fe36ed["`Rust
Lifetime Subtype Variance`" -- Prolific K] or
https://lcnr.de/blog/diving-deep-implied-bounds-and-variance/["`Diving Deep:
implied bounds and variance`" -- lcnr.de]. If you're more of a visual learner,
then https://www.youtube.com/watch?v=iVYWDIW71jk[this video from Jon Gjengset]
might be best for you.

== Trying to fix it

The difference between `RCow` and `Cow` was the `BorrowOwned<'a>` trait. For
technical reasons, it was being used as a
https://doc.rust-lang.org/rust-by-example/trait/supertraits.html[subtrait] of
`ToOwned`. To add extra functionality, `BorrowOwned` had to bind to a lifetime
`'a`. Ultimately, this meant that `RCow` was _invariant_, while `Cow` was
_covariant_. We want `RCow` to be _covariant_ for this to work.

{{< highlight "diff" >}}
 impl<B: ?Sized> Ord for Cow<'a, B>
 where
-    B: Ord + ToOwned,  // in Cow
+    B: Ord + BorrowOwned<'a>,  // in RCow
 {
     #[inline]
     fn cmp(&self, other: &Self) -> Ordering {
         Ord::cmp(&**self, &**other)
     }
 }
{{< /highlight >}}

=== Attempt #1: GATs

I had an idea of using
https://blog.rust-lang.org/2022/10/28/gats-stabilization.html[Generic Associated
Types (GATs)]. Instead of binding the lifetime as `BorrowOwned<'a>`, I could do
so in an associated type. Then, I'd be able to use `BorrowOwned` instead of
`BorrowOwned<'a>`:

{{< highlight "rust" >}}
impl<T> BorrowOwned for T {
    type RBorrowed<'a> where T: 'a = &'a T;
}
{{< /highlight >}}

But
https://rustc-dev-guide.rust-lang.org/variance.html#variance-and-associated-types[a
section in the Rust Developer Book] states that "traits with associated types
must be invariant with respect to all of their inputs". So that still didn't
help make our type covariant.

Note I only found that statement in the book for developers of the compiler! I
opened https://github.com/rust-lang/nomicon/issues/338[an issue about that in
The Rustonomicon], and moved on to something else.

=== Attempt #2: `transmute`

After many wasted hours, I was tempted to use `transmute` and call it a day.
Here's what Heinz suggested (_trigger warning_):

{{< highlight "rust" >}}
fn compare<'a, 'b>(left: &RCow<'a, str>, right: &RCow<'b, str>) -> Ordering {
    unsafe {
        let right: &RCow<'a, str> = std::mem::transmute(right);
        left.cmp(right)
    }
}
{{< /highlight >}}

It worked! In theory, it's safe because both `'a` and `'b` will live for at
least as long as the function does, and we're returning an owned type.

Ideally, we'd abstract this away by writing a wrapper around `RCow` with the
fix. However, that wouldn't help because invariant relationships are inherited,
and the implementation of `Ord` would still use `BorrowOwned<'a>`.

{{< highlight "rust" >}}
struct SCow<'a>(RCow<'a, ()>);  // will still be invariant!
{{< /highlight >}}

One workaround would be to hide `RCow` under a `*const ()`. Then, I can
pointer-cast back and forth from it. But in this project, I already had too many
things backfire. Traumatized, I continued looking for a solution.

=== Attempt #3: getting rid of `BorrowOwned<'a>`



== Conclusion

Honestly, I think that why it took me so long to realize the error is Rust's
fault. There were no indications in the errors about variance. I understand that
there were

I was lucky to have such a great team at Tremor, and an OSS maintainer as smart
as Rodri. You can find all the details of the discussion in the following GitHub
issue:

[.text-center]
{{< gh issue "rodrimati1992/abi_stable_crates" 75 "lifetimes with R* types break compared to non R* types" "paragraph" >}}
