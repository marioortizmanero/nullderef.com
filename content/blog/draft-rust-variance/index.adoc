---
title: "Surprised by Rust's Subtyping and Variance"
description: "One of the toughest bugs I've come across... Thanks to my good
friends Subtyping and Variance."
author: "Mario Ortiz Manero"
images: ["TODO"]
tags: ["tech", "programming", "rust", "rustlang", "variance", "subtyping", "abi_stable"]
date: 2022-01-29
GHissueID: TODO
draft: true
---

:sectnums:

:repr-c: pass:quotes[`#[repr\(C)]`]
:repr-rust: pass:quotes[`#[repr(Rust)]`]
:work: pass:quotes["`just make it work`"]
:heinz: https://twitter.com/heinz_gies/[Heinz]

// Sources:
// https://doc.rust-lang.org/nomicon/subtyping.html
// https://lcnr.de/blog/diving-deep-implied-bounds-and-variance/

_Subtyping and variance_ is something that works in the background, making your
life easier without you even knowing about it. That is, until it starts making
your life harder instead. It might be a good idea to know its pitfalls in order
to know when you are running into these unlikely issues.

This topic isn't covered in the https://doc.rust-lang.org/book/[The Rust Book].
We'll only find it in its more obscure, unsafer brother,
https://doc.rust-lang.org/nomicon[The Rustonomicon]. It's actually incredibly
well explained in there, so I will refrain from repeating myself. If you want to
know more details, I would strongly recommend you to check out yourself the
following sources, as this will only cover part of the topic.

. https://doc.rust-lang.org/nomicon/subtyping.html["`Subtyping and Variance`" --
  The Rustonomicon]
. https://doc.rust-lang.org/reference/subtyping.html["`Subtyping and Variance`"
  -- The Rust Reference]
. https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)["`Covariance
  and contravariance`" -- Wikipedia]

There's also a couple blog posts with a more practical approach, like
https://medium.com/@orbitalK/rust-lifetime-subtype-variance-b58434fe36ed["`Rust
Lifetime Subtype Variance`" -- Prolific K] or
https://lcnr.de/blog/diving-deep-implied-bounds-and-variance/["`Diving Deep:
implied bounds and variance`" -- lcnr.de]. If you're more of a visual learner,
then https://www.youtube.com/watch?v=iVYWDIW71jk[this video from Jon Gjengset]
might be best for you.

Furthermore, this article may be unnecessarily verbose if you're _just_ trying
to learn about subtyping and variance. That's because I also wanted to cover the
steps I took to solve the issue. Specifically, I sometimes run into lifetime
issues that I don't even know how to approach. This is one of these cases, and I
think I learned quite a few important lessons.

== The problem

As part of my https://nullderef.com/series/rust-plugins/[Plugin System in Rust]
series, I was making one of Tremor's core types FFI-compatible (a.k.a.
{repr-c}). I was using the crate {{< crate abi_stable >}}, which includes
re-implementations of the standard library that are {repr-c} for this exact
purpose. Thanks to it, the task should be as easy as changing the `std` types in
my enum with theirs -- theoretically.

.Before (simplified)
{{< highlight "rust" >}}
pub enum Value {
    String(String),
    Array(Vec<Value>),
    Object(Box<HashMap<String, Value>>),
    Bytes(Vec<u8>),
}
{{< /highlight >}}

.After (simplified)
{{< highlight "rust" >}}
use abi_stable::std_types::{RString, RVec, RBox, RHashMap};

#[repr(C)]
pub enum Value {
    String(RString),
    Array(RVec<Value>),
    Object(RBox<RHashMap<RString, Value>>),
    Bytes(RVec<u8>),
}
{{< /highlight >}}

Naturally, this brought up lots of compilation errors; the `Value` type was used
a lot in the codebase, and its usage had changed. For whatever reason, 70 of
these errors were related to lifetimes, which I hadn't changed at all...

== Debugging

{heinz}, my mentor, managed to reproduce the issue:

{{< highlight "rust" >}}
use abi_stable::std_types::RCow;
use std::borrow::Cow;

// This works
fn cmp_cow<'a, 'b>(left: &Cow<'a, ()>, right: &Cow<'b, ()>) -> bool {
    left == right
}

// This fails to compile
fn cmp_rcow<'a, 'b>(left: &RCow<'a, ()>, right: &RCow<'b, ()>) -> bool {
    left == right
}
{{< /highlight >}}

With the following error:

{{< highlight "text" >}}
$ cargo b
   Compiling repro v0.1.0 (/home/mario/Downloads/repro)
error[E0623]: lifetime mismatch
  --> src/lib.rs:10:10
   |
9  | fn cmp_rcow<'a, 'b>(left: &RCow<'a, ()>, right: &RCow<'b, ()>) -> bool {
   |                            ------------          ------------
   |                            |
   |                            these two types are declared with different lifetimes...
10 |     left == right
   |          ^^ ...but data from `left` flows into `right` here

For more information about this error, try `rustc --explain E0623`.
error: could not compile `repro` due to previous error
{{< /highlight >}}

What? Why do lifetimes matter here, if it's just a comparison?

This hinted that the issue was in the underlying library, not my code. `RCow` is
supposed to be a drop-in replacement for `Cow`. It also had something to do with
`PartialOrd`, which is the trait used for `==` here. The implementation of
`PartialOrd` seemed equivalent in both cases, though:

.Cow
{{< highlight "rust" >}}
impl<'a, B: ?Sized> PartialOrd for Cow<'a, B>
where
    B: PartialOrd + ToOwned,
{
    #[inline]
    fn partial_cmp(&self, other: &Cow<'a, B>) -> Option<Ordering> {
        PartialOrd::partial_cmp(&**self, &**other)
    }
}
{{< /highlight >}}

.RCow
{{< highlight "rust" >}}
impl<'a, B> PartialOrd<RCow<'a, B>> for RCow<'a, B>
where
    B: PartialOrd + BorrowOwned<'a> + ?Sized,
{
    #[inline]
    fn partial_cmp(&self, other: &RCow<'a, B>) -> Option<Ordering> {
        PartialOrd::partial_cmp(&**self, &**other)
    }
}
{{< /highlight >}}

There are definitely more libraries that provide drop-in replacements for `Cow`.
And for example, {{< crate "beef" >}} managed to get it right, somehow. I wasn't
able to reproduce the issue with their implementation... but why?

.Beef's Cow
{{< highlight "rust" >}}
impl<A, B, U, V> PartialOrd<Cow<'_, B, V>> for Cow<'_, A, U>
where
    A: Beef + ?Sized + PartialOrd<B>,
    B: Beef + ?Sized,
    U: Capacity,
    V: Capacity,
{
    #[inline]
    fn partial_cmp(&self, other: &Cow<'_, B, V>) -> Option<Ordering> {
        PartialOrd::partial_cmp(self.borrow(), other.borrow())
    }
}
{{< /highlight >}}

== Some progress... or not?

Other traits like `PartialEq` also showed lifetime errors with a similar
snippet. I was tempted to use `transmute` and call it a day, but I was afraid
it'd backfire at some point. Here's what Heinz suggested (_trigger warning_) --
and it actually worked! I'd just need to use the wrapper `SCow` instead of
`RCow`:

{{< highlight "rust" >}}
struct SCow<'a>(RCow<'a, ()>);
impl<'a, 'b> PartialEq<SCow<'a>> for SCow<'b> {
    fn eq(&self, other: &SCow<'a>) -> bool {
        unsafe {
            let other0: &RCow<'b, ()> = std::mem::transmute(&other.0);
            &self.0 == other0
        }
    }
}
{{< /highlight >}}

{{< highlight "rust" >}}
fn cmp_cow<'a, 'b>(left: &Cow<'a, ()>, right: &Cow<'b, ()>) -> bool {
    left == right
}
fn cmp_scow<'a, 'b>(left: &SCow<'a>, right: &SCow<'b>) -> bool {
    left == right
}
{{< /highlight >}}

But in this project, I already had too many things backfire. Traumatized, I
continued my debugging, which led to actually fixing some traits! By introducing
`'b`, I was making it clear that the comparison shouldn't care about lifetimes:

{{< highlight "diff" >}}
-impl<'a, B> PartialEq<RCow<'a, B>> for RCow<'a, B>
+impl<'a, 'b, B, C> PartialEq<RCow<'b, C>> for RCow<'a, B>
 where
     B: PartialEq + BorrowOwned<'a> + ?Sized,
+    C: BorrowOwned<'b> + ?Sized,
 {
-    fn eq(&self, other: &RCow<'a, B>) -> bool {
+    fn eq(&self, other: &RCow<'b, C>) -> bool {
         PartialEq::eq(&**self, &**other)
     }
 }
{{< /highlight >}}

This gave me some hope, but it could never work for the trait `Ord`, which also
failed. This is because this trait uses `Self` instead of another type, so I
can't just introduce another lifetime.

.Cow
{{< highlight "rust" >}}
impl<B: ?Sized> Ord for Cow<'_, B>
where
    B: Ord + ToOwned,
{
    #[inline]
    fn cmp(&self, other: &Self) -> Ordering {
        Ord::cmp(&**self, &**other)
    }
}
{{< /highlight >}}

.RCow
{{< highlight "rust" >}}
impl<'a, B: ?Sized> Ord for RCow<'a, B>
where
    B: Ord + BorrowOwned<'a>,
{
    #[inline]
    fn cmp(&self, other: &RCow<'a, B>) -> Ordering {
        Ord::cmp(&**self, &**other)
    }
}
{{< /highlight >}}

== Discovering

You can see the entire discussion in the following GitHub issue to understand
all the details:

[.text-center]
{{< gh issue "rodrimati1992/abi_stable_crates" 75 "lifetimes with R* types break compared to non R* types" "paragraph" >}}

== Conclusion

I would honestly say that the fact it took me so long to realize the error is
Rust's fault. There were no indications in the errors about variance. I
understand that there were

Thanks a lot to {heinz} for the TODO help in this issue!
